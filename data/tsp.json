{
    "current_population": [
        {
            "id": "3a0514a7-d9b5-4230-8054-2d35bda348ab",
            "chromosome": {
                "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Mutated Strategy: DL Lifting + Explicit 2-Cycle + Conditional Domain Tightening\n    \n    # 1. Explicit 2-cycle elimination\n    # Retained from individual: Provides sparse, strong cuts for LP relaxation.\n    def sec2_cut_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2_cuts = pyo.Constraint(model.N, model.N, rule=sec2_cut_rule)\n    \n    # 2. Desrochers-Laporte (DL) Lifting & Depot Fixing\n    # Retained: Strengthens subtour elimination and fixes u when connected to depot.\n    def dl_lifting_rule(model, i, j):\n        if i == j: return pyo.Constraint.Skip\n        \n        # Internal Nodes (i, j != 1): Lifted MTZ constraint\n        if i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n        # Depot Outgoing (1 -> j): If x_1j=1, force u_j=2\n        if i == 1:\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n    \n        # Depot Incoming (i -> 1): If x_i1=1, force u_i=n\n        if j == 1:\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n    \n        return pyo.Constraint.Skip\n    model.enhanced_dl_mtz = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)\n    \n    # 3. Conditional Depot Bounds (Added Mutation)\n    # Enhances the strategy by tightening u-bounds for nodes NOT connected to the depot.\n    # Complements the fixing constraints above to partition the domain of u.\n    \n    # Lower Bound Tightening: If node i is NOT the first visited (x_1i=0), u_i must be >= 3.\n    # Logic: u_i >= 2 + (1 - x_1i) => u_i >= 3 - x_1i\n    def depot_lb_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        return model.u[i] >= 3 - model.x[1, i]\n    model.depot_conditional_lb = pyo.Constraint(model.N, rule=depot_lb_rule)\n    \n    # Upper Bound Tightening: If node i is NOT the last visited (x_i1=0), u_i must be <= n-1.\n    # Logic: u_i <= n - (1 - x_i1) => u_i <= n - 1 + x_i1\n    def depot_ub_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        return model.u[i] <= (n - 1) + model.x[i, 1]\n    model.depot_conditional_ub = pyo.Constraint(model.N, rule=depot_ub_rule)\n\n    return model\n",
                "added_cut": "# Mutated Strategy: DL Lifting + Explicit 2-Cycle + Conditional Domain Tightening\n\n# 1. Explicit 2-cycle elimination\n# Retained from individual: Provides sparse, strong cuts for LP relaxation.\ndef sec2_cut_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2_cuts = pyo.Constraint(model.N, model.N, rule=sec2_cut_rule)\n\n# 2. Desrochers-Laporte (DL) Lifting & Depot Fixing\n# Retained: Strengthens subtour elimination and fixes u when connected to depot.\ndef dl_lifting_rule(model, i, j):\n    if i == j: return pyo.Constraint.Skip\n    \n    # Internal Nodes (i, j != 1): Lifted MTZ constraint\n    if i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\n    # Depot Outgoing (1 -> j): If x_1j=1, force u_j=2\n    if i == 1:\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n\n    # Depot Incoming (i -> 1): If x_i1=1, force u_i=n\n    if j == 1:\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n\n    return pyo.Constraint.Skip\nmodel.enhanced_dl_mtz = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)\n\n# 3. Conditional Depot Bounds (Added Mutation)\n# Enhances the strategy by tightening u-bounds for nodes NOT connected to the depot.\n# Complements the fixing constraints above to partition the domain of u.\n\n# Lower Bound Tightening: If node i is NOT the first visited (x_1i=0), u_i must be >= 3.\n# Logic: u_i >= 2 + (1 - x_1i) => u_i >= 3 - x_1i\ndef depot_lb_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    return model.u[i] >= 3 - model.x[1, i]\nmodel.depot_conditional_lb = pyo.Constraint(model.N, rule=depot_lb_rule)\n\n# Upper Bound Tightening: If node i is NOT the last visited (x_i1=0), u_i must be <= n-1.\n# Logic: u_i <= n - (1 - x_i1) => u_i <= n - 1 + x_i1\ndef depot_ub_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    return model.u[i] <= (n - 1) + model.x[i, 1]\nmodel.depot_conditional_ub = pyo.Constraint(model.N, rule=depot_ub_rule)",
                "idea": "This mutation augments the Desrochers-Laporte and 2-cycle strategy with Conditional Domain Tightening. While the original cuts fixed u[i] to 2 or n when connected to the depot, the new constraints strictly tighten the bounds for the 'unconnected' case (forcing u[i] into [3, n-1] when x[1,i]=0 or x[i,1]=0). This strictly partitions the continuous domain of u based on depot adjacency, significantly tightening the LP relaxation and strengthening the Big-M implications for all internal DL constraints."
            },
            "fitness": 12.559533054020575,
            "solver_reports": [
                {
                    "gap": 9.983,
                    "total_time": 14.25,
                    "explored_nodes": 1,
                    "simplex_iterations": 2480,
                    "explored_time": 14.21,
                    "work_units": 10.0
                },
                {
                    "total_time": 11.61,
                    "explored_nodes": 1,
                    "simplex_iterations": 2767,
                    "explored_time": 11.53,
                    "work_units": 10.0
                },
                {
                    "gap": 13.5723,
                    "total_time": 12.08,
                    "explored_nodes": 369,
                    "simplex_iterations": 10792,
                    "explored_time": 12.06,
                    "work_units": 10.06
                },
                {
                    "total_time": 12.46,
                    "explored_nodes": 1,
                    "simplex_iterations": 1950,
                    "explored_time": 12.34,
                    "work_units": 10.0
                },
                {
                    "gap": 1.1852,
                    "total_time": 14.17,
                    "explored_nodes": 10783,
                    "simplex_iterations": 287126,
                    "explored_time": 14.16,
                    "work_units": 10.02
                },
                {
                    "gap": 17.5923,
                    "total_time": 12.82,
                    "explored_nodes": 1,
                    "simplex_iterations": 1661,
                    "explored_time": 12.73,
                    "work_units": 10.0
                },
                {
                    "gap": 0.0,
                    "total_time": 2.88,
                    "postsolve": 0.0,
                    "explored_nodes": 42403,
                    "simplex_iterations": 292937,
                    "explored_time": 2.88,
                    "work_units": 1.53
                },
                {
                    "gap": 1.9875,
                    "total_time": 14.65,
                    "explored_nodes": 2958,
                    "simplex_iterations": 57432,
                    "explored_time": 14.61,
                    "work_units": 10.0
                },
                {
                    "gap": 6.2986,
                    "total_time": 12.42,
                    "explored_nodes": 1,
                    "simplex_iterations": 1777,
                    "explored_time": 12.37,
                    "work_units": 10.0
                },
                {
                    "total_time": 13.63,
                    "explored_nodes": 1,
                    "simplex_iterations": 2314,
                    "explored_time": 13.56,
                    "work_units": 10.0
                }
            ],
            "generator": "General",
            "parents_id": [
                "dac64902-bc73-4360-b06f-a785302741fa"
            ]
        },
        {
            "id": "a926d17e-fed4-4d52-b1f2-e68f0a193cfa",
            "chromosome": {
                "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # 5. Explicit 4-Node Subtour Elimination (GSEC for |S|=4)\n    # Targets disjoint fractional subtours of length 4, which are the next minimal violation\n    # allowed by MTZ relaxations after size-3 eliminations.\n    # Applied to subsets of non-depot nodes to strictly target disjoint subtours.\n    if n > 4:\n        import itertools\n        # Focus on subsets excluding the depot (1) where MTZ is weakest against disjoint cycles.\n        nodes_no_depot = [i for i in model.N if i != 1]\n        \n        # Generate all subsets of size 4 from non-depot nodes.\n        model.sec4_quadruplets = pyo.Set(dimen=4, initialize=list(itertools.combinations(nodes_no_depot, 4)))\n    \n        def sec4_rule(model, i, j, k, l):\n            subset = [i, j, k, l]\n            # The sum of arcs strictly within the subset {i, j, k, l} must be <= 3.\n            # This prevents fractional cycles (e.g., 0.5 on 4 edges) forming a 'square'.\n            return sum(model.x[u, v] for u in subset for v in subset if u != v) <= 3\n    \n        model.sec4_cuts = pyo.Constraint(model.sec4_quadruplets, rule=sec4_rule)\n\n    return model\n",
                "added_cut": "# 5. Explicit 4-Node Subtour Elimination (GSEC for |S|=4)\n# Targets disjoint fractional subtours of length 4, which are the next minimal violation\n# allowed by MTZ relaxations after size-3 eliminations.\n# Applied to subsets of non-depot nodes to strictly target disjoint subtours.\nif n > 4:\n    import itertools\n    # Focus on subsets excluding the depot (1) where MTZ is weakest against disjoint cycles.\n    nodes_no_depot = [i for i in model.N if i != 1]\n    \n    # Generate all subsets of size 4 from non-depot nodes.\n    model.sec4_quadruplets = pyo.Set(dimen=4, initialize=list(itertools.combinations(nodes_no_depot, 4)))\n\n    def sec4_rule(model, i, j, k, l):\n        subset = [i, j, k, l]\n        # The sum of arcs strictly within the subset {i, j, k, l} must be <= 3.\n        # This prevents fractional cycles (e.g., 0.5 on 4 edges) forming a 'square'.\n        return sum(model.x[u, v] for u in subset for v in subset if u != v) <= 3\n\n    model.sec4_cuts = pyo.Constraint(model.sec4_quadruplets, rule=sec4_rule)",
                "idea": "Extends the combinatorial logic of Parent 1 (size-3 elimination) to subsets of size 4, specifically targeting non-depot nodes. While Parent 2 tightly constrains the position variables ($u$) and Parent 1 removes triangular fractional cycles, MTZ relaxations often settle on 'square' fractional subtours (e.g., $x_{ij}=x_{jk}=x_{kl}=x_{li}=0.5$) that satisfy potential constraints locally. This cut explicitly forbids such structures by enforcing Generalized Subtour Elimination Constraints (GSEC) for $|S|=4$. By restricting to non-depot nodes, it efficiently targets the disjoint subtours that MTZ fails to detect, complementing the global position invariants of Parent 2."
            },
            "fitness": 4.794806781608104,
            "solver_reports": [
                {
                    "total_time": 17.13,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 14.02,
                    "work_units": 10.37
                },
                {
                    "total_time": 208.61,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 174.49,
                    "work_units": 65.4
                },
                {
                    "total_time": 18.6,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 14.53,
                    "work_units": 10.37
                },
                {
                    "total_time": 392.01,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 324.32,
                    "work_units": 112.79
                },
                {
                    "total_time": 9.78,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 9.03,
                    "work_units": 10.2
                },
                {
                    "total_time": 124.93,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 101.35,
                    "work_units": 44.13
                },
                {
                    "gap": 6.6305,
                    "total_time": 13.24,
                    "explored_nodes": 27618,
                    "simplex_iterations": 182815,
                    "explored_time": 13.23,
                    "work_units": 10.01
                },
                {
                    "total_time": 15.27,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 11.99,
                    "work_units": 10.07
                },
                {
                    "total_time": 63.47,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 50.0,
                    "work_units": 23.98
                },
                {
                    "total_time": 96.01,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 76.56,
                    "work_units": 34.7
                }
            ],
            "generator": "Complement",
            "parents_id": [
                "0648bdd2-55a5-4ecb-9fb3-b4ee16fbcec3",
                "70e1ec92-e475-47f3-99fe-f30b7853129e"
            ]
        },
        {
            "id": "c47f85d3-049d-4abc-a7df-a443bad49d1d",
            "chromosome": {
                "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    import itertools\n    \n    # Hybrid Desrochers-Laporte and Explicit 3-GSEC Strategy\n    \n    # 1. Desrochers-Laporte (DL) Lifted MTZ Constraints\n    # This component strengthens the MTZ potential constraints by lifting the reverse arc variable x[j,i].\n    # It strictly dominates the standard MTZ constraints by enforcing stricter bounds on u[i] - u[j]\n    # when x[j,i] = 1, effectively eliminating 2-cycles and tightening the global polytope.\n    def dl_lifted_rule(m, i, j):\n        # Apply only for non-depot nodes pair (i, j)\n        if i != j and i != 1 and j != 1:\n            return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    model.dl_lifted_cuts = pyo.Constraint(model.N, model.N, rule=dl_lifted_rule)\n    \n    # 2. Explicit 3-Node Subtour Elimination (GSEC for |S|=3)\n    # While DL handles position potentials, linear relaxations can still admit fractional 3-cycles\n    # (e.g., x_ij = x_jk = x_ki = 2/3) which satisfy potential differences. \n    # We explicitly enforce that for any triplet, the number of internal arcs is <= 2.\n    # This cuts off specific fractional vertices that the lifted MTZ formulation misses.\n    if n > 3:\n        model.triplets = pyo.Set(dimen=3, initialize=list(itertools.combinations(model.N, 3)))\n        def gsec3_rule(m, i, j, k):\n            subset = [i, j, k]\n            # The sum of all arcs between nodes in the subset {i, j, k} must be <= |S| - 1 = 2\n            return sum(m.x[u, v] for u in subset for v in subset if u != v) <= 2\n        model.gsec3_cuts = pyo.Constraint(model.triplets, rule=gsec3_rule)\n\n    return model\n",
                "added_cut": "import itertools\n\n# Hybrid Desrochers-Laporte and Explicit 3-GSEC Strategy\n\n# 1. Desrochers-Laporte (DL) Lifted MTZ Constraints\n# This component strengthens the MTZ potential constraints by lifting the reverse arc variable x[j,i].\n# It strictly dominates the standard MTZ constraints by enforcing stricter bounds on u[i] - u[j]\n# when x[j,i] = 1, effectively eliminating 2-cycles and tightening the global polytope.\ndef dl_lifted_rule(m, i, j):\n    # Apply only for non-depot nodes pair (i, j)\n    if i != j and i != 1 and j != 1:\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\nmodel.dl_lifted_cuts = pyo.Constraint(model.N, model.N, rule=dl_lifted_rule)\n\n# 2. Explicit 3-Node Subtour Elimination (GSEC for |S|=3)\n# While DL handles position potentials, linear relaxations can still admit fractional 3-cycles\n# (e.g., x_ij = x_jk = x_ki = 2/3) which satisfy potential differences. \n# We explicitly enforce that for any triplet, the number of internal arcs is <= 2.\n# This cuts off specific fractional vertices that the lifted MTZ formulation misses.\nif n > 3:\n    model.triplets = pyo.Set(dimen=3, initialize=list(itertools.combinations(model.N, 3)))\n    def gsec3_rule(m, i, j, k):\n        subset = [i, j, k]\n        # The sum of all arcs between nodes in the subset {i, j, k} must be <= |S| - 1 = 2\n        return sum(m.x[u, v] for u in subset for v in subset if u != v) <= 2\n    model.gsec3_cuts = pyo.Constraint(model.triplets, rule=gsec3_rule)",
                "idea": "We combine Desrochers-Laporte (DL) lifting with explicit 3-node Generalized Subtour Elimination Constraints (GSEC) to minimize joint violation. The DL component ($O(n^2)$) significantly tightens the global linear relaxation of the MTZ potentials by lifting the reverse arc $x_{ji}$, strictly dominating standard MTZ cuts. However, continuous relaxations of position-based formulations often fail to exclude small fractional cycles (e.g., triangles with edge values of 2/3). The GSEC component ($O(n^3)$) explicitly removes these local fractional violations by enforcing $\\sum_{u,v \\in S} x_{uv} \\le 2$ for all triplets. This hybrid approach leverages the global strength of DL and the local exactness of GSEC to form a robustly tightened feasible region."
            },
            "fitness": 0.4524271359670814,
            "solver_reports": [
                {
                    "gap": 20.3945,
                    "total_time": 11.58,
                    "explored_nodes": 1,
                    "simplex_iterations": 936,
                    "explored_time": 11.47,
                    "work_units": 10.0
                },
                {
                    "total_time": 8.85,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 8.18,
                    "work_units": 10.0
                },
                {
                    "gap": 89.2808,
                    "total_time": 9.83,
                    "explored_nodes": 1,
                    "simplex_iterations": 892,
                    "explored_time": 9.72,
                    "work_units": 10.0
                },
                {
                    "total_time": 11.56,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 10.56,
                    "work_units": 10.0
                },
                {
                    "gap": 4.246,
                    "total_time": 14.99,
                    "explored_nodes": 1296,
                    "simplex_iterations": 24073,
                    "explored_time": 14.95,
                    "work_units": 10.01
                },
                {
                    "total_time": 7.59,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 6.98,
                    "work_units": 10.0
                },
                {
                    "gap": 0.0,
                    "total_time": 3.76,
                    "postsolve": 0.01,
                    "explored_nodes": 81010,
                    "simplex_iterations": 543103,
                    "explored_time": 3.76,
                    "work_units": 2.43
                },
                {
                    "gap": 13.5735,
                    "total_time": 10.22,
                    "explored_nodes": 1,
                    "simplex_iterations": 1082,
                    "explored_time": 10.12,
                    "work_units": 10.0
                },
                {
                    "total_time": 7.95,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 7.62,
                    "work_units": 10.09
                },
                {
                    "total_time": 7.78,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 7.28,
                    "work_units": 10.2
                }
            ],
            "generator": "Min_Violation",
            "parents_id": [
                "0648bdd2-55a5-4ecb-9fb3-b4ee16fbcec3",
                "fcc96c36-f50d-404b-9c4a-7cc9519f27a2"
            ]
        },
        {
            "id": "c39866b6-ab84-4815-8921-a5dfd523a56b",
            "chromosome": {
                "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # 5. Depot-Position Strengthening\n    # Tightens the bounds on position variables u[i] based on connections to the depot (Node 1).\n    # Standard MTZ bounds u[i] in [2, n] are loose. We link u[i] to the depot arcs x[1,i] and x[i,1].\n    \n    def depot_lb_rule(model, i):\n        # If node i is visited directly after the depot (x[1,i]=1), u[i] >= 2.\n        # If not (x[1,i]=0), it must be at least the 3rd node visited, so u[i] >= 3.\n        if i != 1:\n            return model.u[i] >= 3 - model.x[1, i]\n        return pyo.Constraint.Skip\n    \n    def depot_ub_rule(model, i):\n        # If node i visits the depot directly (x[i,1]=1), it is the last node, u[i] <= n.\n        # If not (x[i,1]=0), it cannot be the last node, so u[i] <= n-1.\n        if i != 1:\n            return model.u[i] <= (n - 1) + model.x[i, 1]\n        return pyo.Constraint.Skip\n    \n    model.depot_pos_lb = pyo.Constraint(model.N, rule=depot_lb_rule)\n    model.depot_pos_ub = pyo.Constraint(model.N, rule=depot_ub_rule)\n\n    return model\n",
                "added_cut": "# 5. Depot-Position Strengthening\n# Tightens the bounds on position variables u[i] based on connections to the depot (Node 1).\n# Standard MTZ bounds u[i] in [2, n] are loose. We link u[i] to the depot arcs x[1,i] and x[i,1].\n\ndef depot_lb_rule(model, i):\n    # If node i is visited directly after the depot (x[1,i]=1), u[i] >= 2.\n    # If not (x[1,i]=0), it must be at least the 3rd node visited, so u[i] >= 3.\n    if i != 1:\n        return model.u[i] >= 3 - model.x[1, i]\n    return pyo.Constraint.Skip\n\ndef depot_ub_rule(model, i):\n    # If node i visits the depot directly (x[i,1]=1), it is the last node, u[i] <= n.\n    # If not (x[i,1]=0), it cannot be the last node, so u[i] <= n-1.\n    if i != 1:\n        return model.u[i] <= (n - 1) + model.x[i, 1]\n    return pyo.Constraint.Skip\n\nmodel.depot_pos_lb = pyo.Constraint(model.N, rule=depot_lb_rule)\nmodel.depot_pos_ub = pyo.Constraint(model.N, rule=depot_ub_rule)",
                "idea": "Introduces 'Depot-Position Strengthening' constraints that conditionally tighten the domain of the position variables $u_i$ based on whether node $i$ is adjacent to the depot. In the standard MTZ relaxation, $u_i$ can float between $[2, n]$ regardless of arc assignment. These cuts enforce that if a node is not the first visited ($x_{1,i}=0$), its position must be $\\ge 3$, and if it is not the last visited ($x_{i,1}=0$), its position must be $\\le n-1$. This creates a tighter coupling between the flow variables and the ordering variables at the start and end of the tour, removing fractional solutions that satisfy arc constraints but violate ordering logic near the depot."
            },
            "fitness": 4.97969605589386,
            "solver_reports": [
                {
                    "gap": 9.7803,
                    "total_time": 12.11,
                    "explored_nodes": 3719,
                    "simplex_iterations": 58016,
                    "explored_time": 12.08,
                    "work_units": 10.0
                },
                {
                    "gap": 46.1022,
                    "total_time": 12.18,
                    "explored_nodes": 1,
                    "simplex_iterations": 6358,
                    "explored_time": 12.15,
                    "work_units": 10.0
                },
                {
                    "gap": 21.3155,
                    "total_time": 12.32,
                    "explored_nodes": 563,
                    "simplex_iterations": 18783,
                    "explored_time": 12.31,
                    "work_units": 11.05
                },
                {
                    "gap": 45.3316,
                    "total_time": 15.8,
                    "explored_nodes": 1,
                    "simplex_iterations": 3380,
                    "explored_time": 15.75,
                    "work_units": 10.0
                },
                {
                    "gap": 4.1116,
                    "total_time": 11.39,
                    "explored_nodes": 2835,
                    "simplex_iterations": 62062,
                    "explored_time": 11.36,
                    "work_units": 10.01
                },
                {
                    "gap": 28.1667,
                    "total_time": 13.29,
                    "explored_nodes": 114,
                    "simplex_iterations": 9461,
                    "explored_time": 13.26,
                    "work_units": 10.11
                },
                {
                    "gap": 4.1637,
                    "total_time": 13.4,
                    "explored_nodes": 291399,
                    "simplex_iterations": 1867312,
                    "explored_time": 13.39,
                    "work_units": 10.04
                },
                {
                    "gap": 7.8072,
                    "total_time": 10.51,
                    "explored_nodes": 4408,
                    "simplex_iterations": 67802,
                    "explored_time": 10.48,
                    "work_units": 10.0
                },
                {
                    "gap": 21.5371,
                    "total_time": 13.05,
                    "explored_nodes": 59,
                    "simplex_iterations": 5897,
                    "explored_time": 13.03,
                    "work_units": 11.14
                },
                {
                    "gap": 5.387,
                    "total_time": 14.31,
                    "explored_nodes": 87,
                    "simplex_iterations": 8137,
                    "explored_time": 14.27,
                    "work_units": 12.18
                }
            ],
            "generator": "Exploratory",
            "parents_id": [
                "0648bdd2-55a5-4ecb-9fb3-b4ee16fbcec3"
            ]
        },
        {
            "id": "04717600-3342-481e-87ca-184a0f6a8348",
            "chromosome": {
                "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # 1. Reverse Desrochers-Laporte (Bi-directional Logic)\n    # Standard MTZ enforces u_j >= u_i + 1 via an upper bound on u_i - u_j.\n    # These cuts enforce the reverse direction (u_j <= u_i + 1) tightly, creating a \n    # \"channel\" for potential values. It effectively eliminates \"lazy\" subtours where \n    # u-values satisfy the gap loosely.\n    def reverse_dl_rule(model, i, j):\n        if i != 1 and j != 1 and i != j:\n            # Enforces: u[j] - u[i] <= 1 (if x[i,j]=1) and <= -1 (if x[j,i]=1)\n            # This is the symmetric application of the strong DL cut.\n            return model.u[j] - model.u[i] + (n - 3) * model.x[i, j] + (n - 1) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    model.reverse_dl_cuts = pyo.Constraint(model.N, model.N, rule=reverse_dl_rule)\n    \n    # 2. Position Mass Conservation (Global Equality)\n    # Forces the sum of position variables to exactly match the sum of a permutation of 2..n.\n    # In relaxations, u-values often \"float\" or compress to minimize Big-M slack costs.\n    # This equality constraint removes one degree of freedom from the continuous u-space.\n    def position_sum_rule(model):\n        # Sum of integers 2 to n is (n*(n+1)/2) - 1 (subtracting u[1]=1)\n        return sum(model.u[i] for i in model.N if i != 1) == (n * (n + 1) / 2) - 1\n    model.position_sum = pyo.Constraint(rule=position_sum_rule)\n    \n    # 3. Strong Depot Anchoring\n    # Strictly fixes u-bounds for nodes adjacent to the depot. This anchors the \n    # \"channel\" created by the Reverse DL cuts to the fixed depot values (1 and n).\n    model.depot_anchor_ub = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] + (n - 2) * m.x[1, i] <= n if i != 1 else pyo.Constraint.Skip)\n    model.depot_anchor_lb = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] - (n - 2) * m.x[i, 1] >= 2 if i != 1 else pyo.Constraint.Skip)\n\n    return model\n",
                "added_cut": "# 1. Reverse Desrochers-Laporte (Bi-directional Logic)\n# Standard MTZ enforces u_j >= u_i + 1 via an upper bound on u_i - u_j.\n# These cuts enforce the reverse direction (u_j <= u_i + 1) tightly, creating a \n# \"channel\" for potential values. It effectively eliminates \"lazy\" subtours where \n# u-values satisfy the gap loosely.\ndef reverse_dl_rule(model, i, j):\n    if i != 1 and j != 1 and i != j:\n        # Enforces: u[j] - u[i] <= 1 (if x[i,j]=1) and <= -1 (if x[j,i]=1)\n        # This is the symmetric application of the strong DL cut.\n        return model.u[j] - model.u[i] + (n - 3) * model.x[i, j] + (n - 1) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\nmodel.reverse_dl_cuts = pyo.Constraint(model.N, model.N, rule=reverse_dl_rule)\n\n# 2. Position Mass Conservation (Global Equality)\n# Forces the sum of position variables to exactly match the sum of a permutation of 2..n.\n# In relaxations, u-values often \"float\" or compress to minimize Big-M slack costs.\n# This equality constraint removes one degree of freedom from the continuous u-space.\ndef position_sum_rule(model):\n    # Sum of integers 2 to n is (n*(n+1)/2) - 1 (subtracting u[1]=1)\n    return sum(model.u[i] for i in model.N if i != 1) == (n * (n + 1) / 2) - 1\nmodel.position_sum = pyo.Constraint(rule=position_sum_rule)\n\n# 3. Strong Depot Anchoring\n# Strictly fixes u-bounds for nodes adjacent to the depot. This anchors the \n# \"channel\" created by the Reverse DL cuts to the fixed depot values (1 and n).\nmodel.depot_anchor_ub = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] + (n - 2) * m.x[1, i] <= n if i != 1 else pyo.Constraint.Skip)\nmodel.depot_anchor_lb = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] - (n - 2) * m.x[i, 1] >= 2 if i != 1 else pyo.Constraint.Skip)",
                "idea": "This offspring introduces 'Bi-directional Potential Bounding' by combining Symmetric (Reverse) Desrochers-Laporte cuts with a global Position Mass Conservation equality. While standard MTZ and Parent cuts primarily focus on the forward condition ($u_j \\ge u_i + 1$), this constraint strictly enforces the upper bound ($u_j \\le u_i + 1$) along active arcs. When combined with the base constraints, this creates a tight 'channel' for the $u$ variables (forcing $u_j - u_i = 1$ exactly on paths). The additional Mass Conservation constraint ($\\\\sum u_i = \\\\text{const}$) eliminates fractional solutions where position potentials are artificially compressed or distributed non-uniformly to satisfy Big-M gaps cheaply."
            },
            "fitness": 5.543730642016653,
            "solver_reports": [
                {
                    "gap": 21.2609,
                    "total_time": 12.23,
                    "explored_nodes": 59,
                    "simplex_iterations": 5420,
                    "explored_time": 12.21,
                    "work_units": 10.97
                },
                {
                    "gap": 7.5094,
                    "total_time": 12.74,
                    "explored_nodes": 1,
                    "simplex_iterations": 2755,
                    "explored_time": 12.65,
                    "work_units": 10.01
                },
                {
                    "gap": 9.2709,
                    "total_time": 12.29,
                    "explored_nodes": 59,
                    "simplex_iterations": 3535,
                    "explored_time": 12.27,
                    "work_units": 11.03
                },
                {
                    "gap": 41.5443,
                    "total_time": 13.3,
                    "explored_nodes": 1,
                    "simplex_iterations": 1068,
                    "explored_time": 13.19,
                    "work_units": 10.0
                },
                {
                    "gap": 5.4676,
                    "total_time": 11.47,
                    "explored_nodes": 2806,
                    "simplex_iterations": 49811,
                    "explored_time": 11.44,
                    "work_units": 10.0
                },
                {
                    "gap": 6.558,
                    "total_time": 11.84,
                    "explored_nodes": 1,
                    "simplex_iterations": 3474,
                    "explored_time": 11.77,
                    "work_units": 10.0
                },
                {
                    "gap": 0.0,
                    "total_time": 4.18,
                    "postsolve": 0.0,
                    "explored_nodes": 46084,
                    "simplex_iterations": 326224,
                    "explored_time": 4.18,
                    "work_units": 2.75
                },
                {
                    "gap": 5.2009,
                    "total_time": 11.36,
                    "explored_nodes": 68,
                    "simplex_iterations": 6497,
                    "explored_time": 11.34,
                    "work_units": 10.04
                },
                {
                    "gap": 21.699,
                    "total_time": 11.38,
                    "explored_nodes": 1,
                    "simplex_iterations": 1835,
                    "explored_time": 11.31,
                    "work_units": 10.0
                },
                {
                    "gap": 24.0544,
                    "total_time": 12.66,
                    "explored_nodes": 1,
                    "simplex_iterations": 2057,
                    "explored_time": 12.58,
                    "work_units": 10.0
                }
            ],
            "generator": "Complement",
            "parents_id": [
                "7053156d-357b-4781-b786-b451a9096f24",
                "3a0514a7-d9b5-4230-8054-2d35bda348ab"
            ]
        },
        {
            "id": "da1fc0a5-1d4c-4c2d-a1d6-6d2ddaaec59b",
            "chromosome": {
                "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Hybrid Strategy: Unified Lifted Bounds + DL Lifting + Depot SECs\n    \n    # 1. Explicit 2-cycle elimination\n    # Retained for sparse, strong subtour elimination in relaxation.\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2_elimination = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n    \n    # 2. Desrochers-Laporte (DL) Lifting for Internal Nodes\n    # Applies the lifted MTZ constraint only between non-depot nodes.\n    # Structure from Parent 1/2, utilizing strong coefficients (n-1), (n-3).\n    def dl_internal_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    model.dl_internal_cuts = pyo.Constraint(model.N, model.N, rule=dl_internal_rule)\n    \n    # 3. Unified Lifted Position Bounds (Novel Hybrid)\n    # Merges Parent 1's 'Depot Fixing' and 'Conditional Tightening' into single, stronger inequalities.\n    # These constraints couple the u-bounds directly with both incoming and outgoing depot arcs,\n    # tightening the relaxation (e.g., raising LB by 0.5 in fractional cases compared to separate cuts).\n    \n    # Unified Lower Bound: u[i] >= 3 - x[1,i] + (n-3)*x[i,1]\n    # Logic: If x[i,1]=1 -> u[i]>=n; If x[1,i]=1 -> u[i]>=2; Else -> u[i]>=3.\n    def unified_lb_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        return model.u[i] >= 3 - model.x[1, i] + (n - 3) * model.x[i, 1]\n    model.unified_lb = pyo.Constraint(model.N, rule=unified_lb_rule)\n    \n    # Unified Upper Bound: u[i] <= (n-1) + x[i,1] - (n-3)*x[1,i]\n    # Logic: If x[1,i]=1 -> u[i]<=2; If x[i,1]=1 -> u[i]<=n; Else -> u[i]<=n-1.\n    def unified_ub_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        return model.u[i] <= (n - 1) + model.x[i, 1] - (n - 3) * model.x[1, i]\n    model.unified_ub = pyo.Constraint(model.N, rule=unified_ub_rule)\n    \n    # 4. Depot-Triangle Subtour Elimination (Structural Addition)\n    # Explicitly eliminates size-3 subtours involving the depot (1->i->j->1).\n    # MTZ/DL constraints with valid u-values (2, n) can technically allow these in relaxation.\n    # This structural cut removes them for n > 3.\n    def depot_sec3_rule(model, i, j):\n        if i != 1 and j != 1 and i != j:\n            if n > 3:\n                return model.x[1, i] + model.x[i, j] + model.x[j, 1] <= 2\n        return pyo.Constraint.Skip\n    model.depot_sec3 = pyo.Constraint(model.N, model.N, rule=depot_sec3_rule)\n\n    return model\n",
                "added_cut": "# Hybrid Strategy: Unified Lifted Bounds + DL Lifting + Depot SECs\n\n# 1. Explicit 2-cycle elimination\n# Retained for sparse, strong subtour elimination in relaxation.\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2_elimination = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n# 2. Desrochers-Laporte (DL) Lifting for Internal Nodes\n# Applies the lifted MTZ constraint only between non-depot nodes.\n# Structure from Parent 1/2, utilizing strong coefficients (n-1), (n-3).\ndef dl_internal_rule(model, i, j):\n    if i != j and i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\nmodel.dl_internal_cuts = pyo.Constraint(model.N, model.N, rule=dl_internal_rule)\n\n# 3. Unified Lifted Position Bounds (Novel Hybrid)\n# Merges Parent 1's 'Depot Fixing' and 'Conditional Tightening' into single, stronger inequalities.\n# These constraints couple the u-bounds directly with both incoming and outgoing depot arcs,\n# tightening the relaxation (e.g., raising LB by 0.5 in fractional cases compared to separate cuts).\n\n# Unified Lower Bound: u[i] >= 3 - x[1,i] + (n-3)*x[i,1]\n# Logic: If x[i,1]=1 -> u[i]>=n; If x[1,i]=1 -> u[i]>=2; Else -> u[i]>=3.\ndef unified_lb_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    return model.u[i] >= 3 - model.x[1, i] + (n - 3) * model.x[i, 1]\nmodel.unified_lb = pyo.Constraint(model.N, rule=unified_lb_rule)\n\n# Unified Upper Bound: u[i] <= (n-1) + x[i,1] - (n-3)*x[1,i]\n# Logic: If x[1,i]=1 -> u[i]<=2; If x[i,1]=1 -> u[i]<=n; Else -> u[i]<=n-1.\ndef unified_ub_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    return model.u[i] <= (n - 1) + model.x[i, 1] - (n - 3) * model.x[1, i]\nmodel.unified_ub = pyo.Constraint(model.N, rule=unified_ub_rule)\n\n# 4. Depot-Triangle Subtour Elimination (Structural Addition)\n# Explicitly eliminates size-3 subtours involving the depot (1->i->j->1).\n# MTZ/DL constraints with valid u-values (2, n) can technically allow these in relaxation.\n# This structural cut removes them for n > 3.\ndef depot_sec3_rule(model, i, j):\n    if i != 1 and j != 1 and i != j:\n        if n > 3:\n            return model.x[1, i] + model.x[i, j] + model.x[j, 1] <= 2\n    return pyo.Constraint.Skip\nmodel.depot_sec3 = pyo.Constraint(model.N, model.N, rule=depot_sec3_rule)",
                "idea": "This hybrid formulation advances the Desrochers-Laporte strategy by introducing **Unified Lifted Bounds** and **Depot-Triangle SECs**. It fuses the 'Depot Fixing' and 'Conditional Tightening' logic of Parent 1 into single, tighter inequalities (e.g., $u_i \\ge 3 - x_{1i} + (n-3)x_{i1}$) that strictly couple variable domains with depot connectivity, reducing the feasible region for fractional solutions more effectively than separate constraints. Additionally, it explicitly cuts size-3 subtours involving the depota specific topology that MTZ-based relaxations (even with DL lifting) often fail to eliminatethereby strengthening the convex hull approximation for $n > 3$."
            },
            "fitness": 1.0764792150488085,
            "solver_reports": [
                {
                    "gap": 25.8069,
                    "total_time": 13.01,
                    "explored_nodes": 87,
                    "simplex_iterations": 5682,
                    "explored_time": 12.98,
                    "work_units": 10.34
                },
                {
                    "gap": 56.3248,
                    "total_time": 12.09,
                    "explored_nodes": 1,
                    "simplex_iterations": 2790,
                    "explored_time": 11.94,
                    "work_units": 10.02
                },
                {
                    "gap": 12.2742,
                    "total_time": 12.87,
                    "explored_nodes": 59,
                    "simplex_iterations": 4796,
                    "explored_time": 12.84,
                    "work_units": 10.65
                },
                {
                    "total_time": 12.59,
                    "explored_nodes": 1,
                    "simplex_iterations": 1812,
                    "explored_time": 12.41,
                    "work_units": 10.0
                },
                {
                    "gap": 6.3037,
                    "total_time": 11.33,
                    "explored_nodes": 3445,
                    "simplex_iterations": 58567,
                    "explored_time": 11.3,
                    "work_units": 10.0
                },
                {
                    "total_time": 10.86,
                    "explored_nodes": 1,
                    "simplex_iterations": 2034,
                    "explored_time": 10.78,
                    "work_units": 10.03
                },
                {
                    "gap": 0.0,
                    "total_time": 2.6,
                    "postsolve": 0.01,
                    "explored_nodes": 22260,
                    "simplex_iterations": 155709,
                    "explored_time": 2.59,
                    "work_units": 1.5
                },
                {
                    "gap": 5.397,
                    "total_time": 13.21,
                    "explored_nodes": 171,
                    "simplex_iterations": 12900,
                    "explored_time": 13.18,
                    "work_units": 10.1
                },
                {
                    "gap": 89.7297,
                    "total_time": 11.43,
                    "explored_nodes": 1,
                    "simplex_iterations": 1692,
                    "explored_time": 11.37,
                    "work_units": 10.0
                },
                {
                    "total_time": 12.19,
                    "explored_nodes": 1,
                    "simplex_iterations": 1802,
                    "explored_time": 12.13,
                    "work_units": 10.0
                }
            ],
            "generator": "Hybrid",
            "parents_id": [
                "3a0514a7-d9b5-4230-8054-2d35bda348ab",
                "70e1ec92-e475-47f3-99fe-f30b7853129e"
            ]
        },
        {
            "id": "b645520c-35b1-4a36-b903-4a5993de6d25",
            "chromosome": {
                "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    import itertools\n    \n    # Hybrid Facet-Defining Logic: Lifted MTZ + Explicit 3-Cycle Elimination\n    # Combines the Desrochers-Laporte (DL) lifting from Parent 2 with the 3-node GSEC from Parent 1.\n    # This joint approach minimizes violations by tightening both the potential variables (u) and arc variables (x).\n    \n    # 1. Desrochers-Laporte (DL) Lifted Constraints\n    # Tightens the MTZ relaxation using lifted coefficients and reverse arcs.\n    # Also enforces strict position values for nodes adjacent to the depot.\n    # Implicitly eliminates 2-cycles (x_ij + x_ji <= 1).\n    def dl_mtz_rule(m, i, j):\n        if i == j: return pyo.Constraint.Skip\n        \n        # Internal nodes (i, j != 1): Lifted subtour elimination\n        # u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n - 2\n        if i != 1 and j != 1:\n            return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n            \n        # Depot outgoing (1 -> j): If x_1j=1, then u_j must be 2\n        # Bound: u_j <= n - (n-2)x_1j\n        elif i == 1:\n            return m.u[j] + (n - 2) * m.x[1, j] <= n\n            \n        # Depot incoming (i -> 1): If x_i1=1, then u_i must be n\n        # Bound: u_i >= 2 + (n-2)x_i1\n        elif j == 1:\n            return m.u[i] - (n - 2) * m.x[i, 1] >= 2\n            \n        return pyo.Constraint.Skip\n    \n    model.lifted_dl_constraints = pyo.Constraint(model.N, model.N, rule=dl_mtz_rule)\n    \n    # 2. Explicit 3-Node Subtour Elimination (GSEC)\n    # Cuts off fractional triangle cycles (e.g., x_ij=0.5, x_jk=0.5, x_ki=0.5) which MTZ admits.\n    # Applied only if n > 3, as a 3-cycle is a valid tour for n=3.\n    if n > 3:\n        model.triplets_set = pyo.Set(dimen=3, initialize=list(itertools.combinations(model.N, 3)))\n        def sec3_rule(m, i, j, k):\n            subset = [i, j, k]\n            # Sum of arcs strictly within the subset must be <= |S| - 1 = 2\n            return sum(m.x[u, v] for u in subset for v in subset if u != v) <= 2\n        model.sec3_gsec = pyo.Constraint(model.triplets_set, rule=sec3_rule)\n\n    return model\n",
                "added_cut": "import itertools\n\n# Hybrid Facet-Defining Logic: Lifted MTZ + Explicit 3-Cycle Elimination\n# Combines the Desrochers-Laporte (DL) lifting from Parent 2 with the 3-node GSEC from Parent 1.\n# This joint approach minimizes violations by tightening both the potential variables (u) and arc variables (x).\n\n# 1. Desrochers-Laporte (DL) Lifted Constraints\n# Tightens the MTZ relaxation using lifted coefficients and reverse arcs.\n# Also enforces strict position values for nodes adjacent to the depot.\n# Implicitly eliminates 2-cycles (x_ij + x_ji <= 1).\ndef dl_mtz_rule(m, i, j):\n    if i == j: return pyo.Constraint.Skip\n    \n    # Internal nodes (i, j != 1): Lifted subtour elimination\n    # u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n - 2\n    if i != 1 and j != 1:\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n        \n    # Depot outgoing (1 -> j): If x_1j=1, then u_j must be 2\n    # Bound: u_j <= n - (n-2)x_1j\n    elif i == 1:\n        return m.u[j] + (n - 2) * m.x[1, j] <= n\n        \n    # Depot incoming (i -> 1): If x_i1=1, then u_i must be n\n    # Bound: u_i >= 2 + (n-2)x_i1\n    elif j == 1:\n        return m.u[i] - (n - 2) * m.x[i, 1] >= 2\n        \n    return pyo.Constraint.Skip\n\nmodel.lifted_dl_constraints = pyo.Constraint(model.N, model.N, rule=dl_mtz_rule)\n\n# 2. Explicit 3-Node Subtour Elimination (GSEC)\n# Cuts off fractional triangle cycles (e.g., x_ij=0.5, x_jk=0.5, x_ki=0.5) which MTZ admits.\n# Applied only if n > 3, as a 3-cycle is a valid tour for n=3.\nif n > 3:\n    model.triplets_set = pyo.Set(dimen=3, initialize=list(itertools.combinations(model.N, 3)))\n    def sec3_rule(m, i, j, k):\n        subset = [i, j, k]\n        # Sum of arcs strictly within the subset must be <= |S| - 1 = 2\n        return sum(m.x[u, v] for u in subset for v in subset if u != v) <= 2\n    model.sec3_gsec = pyo.Constraint(model.triplets_set, rule=sec3_rule)",
                "idea": "Merges the structural strength of Parent 2's Desrochers-Laporte (DL) lifting with Parent 1's explicit 3-cycle elimination. The DL constraints strictly tighten the linear relaxation of the MTZ variables ($u$) and implicitly eliminate 2-cycles, while the 3-node GSEC cuts ($O(n^3)$) define facets that explicitly remove fractional triangle subtours often missed by MTZ logic. This complementary pairing targets both variable classes to minimize joint violations and strengthen the lower bound."
            },
            "fitness": 0.20435128696788454,
            "solver_reports": [
                {
                    "gap": 22.3165,
                    "total_time": 11.23,
                    "explored_nodes": 1,
                    "simplex_iterations": 742,
                    "explored_time": 11.08,
                    "work_units": 10.0
                },
                {
                    "total_time": 7.65,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 7.14,
                    "work_units": 10.01
                },
                {
                    "gap": 88.0044,
                    "total_time": 10.47,
                    "explored_nodes": 1,
                    "simplex_iterations": 969,
                    "explored_time": 10.35,
                    "work_units": 10.0
                },
                {
                    "total_time": 9.81,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 8.79,
                    "work_units": 10.01
                },
                {
                    "gap": 3.2258,
                    "total_time": 14.67,
                    "explored_nodes": 2803,
                    "simplex_iterations": 57156,
                    "explored_time": 14.61,
                    "work_units": 10.0
                },
                {
                    "total_time": 6.13,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 5.46,
                    "work_units": 10.0
                },
                {
                    "gap": 0.0,
                    "total_time": 6.44,
                    "postsolve": 0.01,
                    "explored_nodes": 69880,
                    "simplex_iterations": 477684,
                    "explored_time": 6.43,
                    "work_units": 4.14
                },
                {
                    "gap": 26.4319,
                    "total_time": 9.69,
                    "explored_nodes": 1,
                    "simplex_iterations": 916,
                    "explored_time": 9.58,
                    "work_units": 10.03
                },
                {
                    "total_time": 7.72,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 7.4,
                    "work_units": 10.08
                },
                {
                    "total_time": 6.01,
                    "explored_nodes": 0,
                    "simplex_iterations": 0,
                    "explored_time": 5.55,
                    "work_units": 10.06
                }
            ],
            "generator": "Min_Violation",
            "parents_id": [
                "0648bdd2-55a5-4ecb-9fb3-b4ee16fbcec3",
                "c8ae531f-63a1-46c6-9dcc-b37f8b5f0c91"
            ]
        },
        {
            "id": "03abc4d4-c8b7-45ce-be38-51c14c5d90bd",
            "chromosome": {
                "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # 1. Desrochers-Laporte (DL) Lifting for Internal Nodes\n    # Strengthens the subtour elimination constraints by lifting the reverse arc x[j,i]\n    # with coefficient (n-3). This strictly dominates standard MTZ for internal paths.\n    model.dl_cuts = pyo.Constraint(model.N, model.N, rule=lambda m, i, j:\n        m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n        if i != 1 and j != 1 and i != j else pyo.Constraint.Skip)\n    \n    # 2. Depot-Dependent Conditional Bounds\n    # These constraints tighten the domain of u[i] based on whether node i is connected to the depot.\n    # If connected (x[1,i]=1 or x[i,1]=1), u[i] is fixed to 2 or n.\n    # If not connected, u[i] is restricted to [3, n-1].\n    \n    # Lower Bound Lifting: If x[1,i]=0, u[i] must be >= 3.\n    model.depot_lb = pyo.Constraint(model.N, rule=lambda m, i:\n        m.u[i] >= 3 - m.x[1, i] if i != 1 else pyo.Constraint.Skip)\n    \n    # Upper Bound Lifting: If x[i,1]=0, u[i] must be <= n-1.\n    model.depot_ub = pyo.Constraint(model.N, rule=lambda m, i:\n        m.u[i] <= (n - 1) + m.x[i, 1] if i != 1 else pyo.Constraint.Skip)\n    \n    # Forced Start Position: If x[1,i]=1, forces u[i] <= 2 (implied u[i]=2).\n    model.depot_fix_start = pyo.Constraint(model.N, rule=lambda m, i:\n        m.u[i] + (n - 2) * m.x[1, i] <= n if i != 1 else pyo.Constraint.Skip)\n    \n    # Forced End Position: If x[i,1]=1, forces u[i] >= n (implied u[i]=n).\n    model.depot_fix_end = pyo.Constraint(model.N, rule=lambda m, i:\n        m.u[i] - (n - 2) * m.x[i, 1] >= 2 if i != 1 else pyo.Constraint.Skip)\n    \n    # 3. Global Position Sum Invariant\n    # Enforces that the sum of position variables u[2]..u[n] equals the sum of the sequence 2..n.\n    # This cuts fractional solutions that satisfy difference constraints but drift in value.\n    model.global_pos_sum = pyo.Constraint(rule=lambda m:\n        sum(m.u[i] for i in m.N if i != 1) == (n * (n + 1) // 2) - 1)\n\n    return model\n",
                "added_cut": "# 1. Desrochers-Laporte (DL) Lifting for Internal Nodes\n# Strengthens the subtour elimination constraints by lifting the reverse arc x[j,i]\n# with coefficient (n-3). This strictly dominates standard MTZ for internal paths.\nmodel.dl_cuts = pyo.Constraint(model.N, model.N, rule=lambda m, i, j:\n    m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    if i != 1 and j != 1 and i != j else pyo.Constraint.Skip)\n\n# 2. Depot-Dependent Conditional Bounds\n# These constraints tighten the domain of u[i] based on whether node i is connected to the depot.\n# If connected (x[1,i]=1 or x[i,1]=1), u[i] is fixed to 2 or n.\n# If not connected, u[i] is restricted to [3, n-1].\n\n# Lower Bound Lifting: If x[1,i]=0, u[i] must be >= 3.\nmodel.depot_lb = pyo.Constraint(model.N, rule=lambda m, i:\n    m.u[i] >= 3 - m.x[1, i] if i != 1 else pyo.Constraint.Skip)\n\n# Upper Bound Lifting: If x[i,1]=0, u[i] must be <= n-1.\nmodel.depot_ub = pyo.Constraint(model.N, rule=lambda m, i:\n    m.u[i] <= (n - 1) + m.x[i, 1] if i != 1 else pyo.Constraint.Skip)\n\n# Forced Start Position: If x[1,i]=1, forces u[i] <= 2 (implied u[i]=2).\nmodel.depot_fix_start = pyo.Constraint(model.N, rule=lambda m, i:\n    m.u[i] + (n - 2) * m.x[1, i] <= n if i != 1 else pyo.Constraint.Skip)\n\n# Forced End Position: If x[i,1]=1, forces u[i] >= n (implied u[i]=n).\nmodel.depot_fix_end = pyo.Constraint(model.N, rule=lambda m, i:\n    m.u[i] - (n - 2) * m.x[i, 1] >= 2 if i != 1 else pyo.Constraint.Skip)\n\n# 3. Global Position Sum Invariant\n# Enforces that the sum of position variables u[2]..u[n] equals the sum of the sequence 2..n.\n# This cuts fractional solutions that satisfy difference constraints but drift in value.\nmodel.global_pos_sum = pyo.Constraint(rule=lambda m:\n    sum(m.u[i] for i in m.N if i != 1) == (n * (n + 1) // 2) - 1)",
                "idea": "This hybrid strategy integrates Desrochers-Laporte (DL) lifting with tight conditional bounds and a global position invariant. The DL constraints ($O(n^2)$) strictly dominate standard MTZ by lifting reverse arcs to tighten internal path differences. The conditional bounds ($O(n)$) partition the domain of position variables based on depot adjacency, forcing exact values ($2$ or $n$) for depot neighbors and stricter ranges ($[3, n-1]$) for others. Finally, the global sum constraint eliminates fractional solutions that satisfy local difference constraints but fail to constitute a valid permutation of positions."
            },
            "fitness": 2.1082004620386647,
            "solver_reports": [
                {
                    "gap": 11.088,
                    "total_time": 11.53,
                    "explored_nodes": 170,
                    "simplex_iterations": 5601,
                    "explored_time": 11.51,
                    "work_units": 10.05
                },
                {
                    "total_time": 13.04,
                    "explored_nodes": 1,
                    "simplex_iterations": 2548,
                    "explored_time": 12.96,
                    "work_units": 10.0
                },
                {
                    "gap": 31.3739,
                    "total_time": 12.83,
                    "explored_nodes": 1,
                    "simplex_iterations": 1508,
                    "explored_time": 12.81,
                    "work_units": 10.1
                },
                {
                    "total_time": 12.92,
                    "explored_nodes": 1,
                    "simplex_iterations": 1305,
                    "explored_time": 12.83,
                    "work_units": 10.0
                },
                {
                    "gap": 1.9259,
                    "total_time": 14.32,
                    "explored_nodes": 2909,
                    "simplex_iterations": 80684,
                    "explored_time": 14.31,
                    "work_units": 10.21
                },
                {
                    "gap": 30.5236,
                    "total_time": 11.68,
                    "explored_nodes": 1,
                    "simplex_iterations": 1934,
                    "explored_time": 11.59,
                    "work_units": 10.0
                },
                {
                    "gap": 0.0,
                    "total_time": 2.59,
                    "postsolve": 0.0,
                    "explored_nodes": 30203,
                    "simplex_iterations": 196364,
                    "explored_time": 2.59,
                    "work_units": 1.63
                },
                {
                    "gap": 9.8884,
                    "total_time": 11.34,
                    "explored_nodes": 70,
                    "simplex_iterations": 5642,
                    "explored_time": 11.33,
                    "work_units": 10.04
                },
                {
                    "gap": 20.3335,
                    "total_time": 12.18,
                    "explored_nodes": 1,
                    "simplex_iterations": 1492,
                    "explored_time": 12.1,
                    "work_units": 10.0
                },
                {
                    "gap": 33.0556,
                    "total_time": 13.37,
                    "explored_nodes": 1,
                    "simplex_iterations": 1720,
                    "explored_time": 13.3,
                    "work_units": 10.0
                }
            ],
            "generator": "Intersection",
            "parents_id": [
                "fcc96c36-f50d-404b-9c4a-7cc9519f27a2",
                "70e1ec92-e475-47f3-99fe-f30b7853129e"
            ]
        }
    ],
    "prev_populations": [
        [
            [
                {
                    "id": "c843bb75-d011-4919-8868-ff8a76978995",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Desrochers and Laporte (1991) Lifted MTZ constraints\n    # This constraint strengthens the standard MTZ formulation by lifting it with the reverse arc x[j,i].\n    # It tightens the bound on the potential difference u[i] - u[j].\n    def lifted_mtz_rule(m, i, j):\n        # Apply for all pairs of non-depot nodes\n        if i != j and i != 1 and j != 1:\n            return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    model.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "    # Desrochers and Laporte (1991) Lifted MTZ constraints\n    # This constraint strengthens the standard MTZ formulation by lifting it with the reverse arc x[j,i].\n    # It tightens the bound on the potential difference u[i] - u[j].\n    def lifted_mtz_rule(m, i, j):\n        # Apply for all pairs of non-depot nodes\n        if i != j and i != 1 and j != 1:\n            return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    model.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "The Desrochers and Laporte (1991) lifting constraint strengthens the standard MTZ subtour elimination. By including the reverse arc variable x[j,i] with a coefficient of (n-3), it tightens the feasible region of the linear relaxation. Specifically, when x[j,i] is 1, the constraint effectively becomes u[i] - u[j] <= 1, which matches the logic that visiting j then i increases the position index by exactly 1. When both x[i,j] and x[j,i] are 0, it provides a tighter bound (n-2) compared to the standard MTZ bound (n-1)."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 11.05,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 11.04,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 13.39,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 12.89,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 12.87,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.92,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.82,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 12.63,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 12.6,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 13.79,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 13.72,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 15.42,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 15.42,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 10.94,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 10.93,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 11.26,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 11.23,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 13.41,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 13.34,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "a481e3ef-3779-4707-abf4-ea11ba0b1cee",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Tightened bounds on u[i] based on connections to/from the depot (Node 1)\n    def depot_bound_upper_rule(m, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        # If arc (1, i) is used, u[i] must be 2. Otherwise, u[i] <= n.\n        # Constraint: u[i] <= n - (n - 2) * x[1, i]\n        return m.u[i] + (n - 2) * m.x[1, i] <= n\n    \n    def depot_bound_lower_rule(m, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        # If arc (i, 1) is used, u[i] must be n. Otherwise, u[i] >= 2.\n        # Constraint: u[i] >= 2 + (n - 2) * x[i, 1]\n        return m.u[i] >= 2 + (n - 2) * m.x[i, 1]\n    \n    model.depot_coupling_upper = pyo.Constraint(model.N, rule=depot_bound_upper_rule)\n    model.depot_coupling_lower = pyo.Constraint(model.N, rule=depot_bound_lower_rule)\n\n    return model\n",
                        "added_cut": "# Tightened bounds on u[i] based on connections to/from the depot (Node 1)\ndef depot_bound_upper_rule(m, i):\n    if i == 1:\n        return pyo.Constraint.Skip\n    # If arc (1, i) is used, u[i] must be 2. Otherwise, u[i] <= n.\n    # Constraint: u[i] <= n - (n - 2) * x[1, i]\n    return m.u[i] + (n - 2) * m.x[1, i] <= n\n\ndef depot_bound_lower_rule(m, i):\n    if i == 1:\n        return pyo.Constraint.Skip\n    # If arc (i, 1) is used, u[i] must be n. Otherwise, u[i] >= 2.\n    # Constraint: u[i] >= 2 + (n - 2) * x[i, 1]\n    return m.u[i] >= 2 + (n - 2) * m.x[i, 1]\n\nmodel.depot_coupling_upper = pyo.Constraint(model.N, rule=depot_bound_upper_rule)\nmodel.depot_coupling_lower = pyo.Constraint(model.N, rule=depot_bound_lower_rule)",
                        "idea": "The standard MTZ subtour elimination constraints (applied only between non-depot nodes) do not explicitly link the position variables $u_i$ to the arcs connected to the depot. This allows the LP relaxation to assign high $u_i$ values to nodes connected from the depot (conceptually the 'first' nodes) or low $u_i$ values to nodes connected to the depot (the 'last' nodes). These added constraints enforce that if $x_{1,i}=1$, then $u_i$ must equal 2 (its lower bound), and if $x_{i,1}=1$, then $u_i$ must equal $n$ (its upper bound). For fractional $x$ values in the relaxation, these cuts significantly tighten the bounds on $u_i$, reducing the feasible region."
                    },
                    "fitness": 7.574143807819105,
                    "solver_reports": [
                        {
                            "gap": 9.2893,
                            "total_time": 11.36,
                            "explored_nodes": 4200,
                            "simplex_iterations": 57100,
                            "explored_time": 11.33,
                            "work_units": 10.0
                        },
                        {
                            "gap": 2.3443,
                            "total_time": 13.7,
                            "explored_nodes": 102,
                            "simplex_iterations": 9188,
                            "explored_time": 13.67,
                            "work_units": 10.03
                        },
                        {
                            "gap": 8.8891,
                            "total_time": 11.63,
                            "explored_nodes": 882,
                            "simplex_iterations": 19372,
                            "explored_time": 11.61,
                            "work_units": 10.04
                        },
                        {
                            "gap": 92.2872,
                            "total_time": 14.44,
                            "explored_nodes": 1,
                            "simplex_iterations": 3502,
                            "explored_time": 14.36,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.0747,
                            "total_time": 13.94,
                            "explored_nodes": 3741,
                            "simplex_iterations": 64275,
                            "explored_time": 13.93,
                            "work_units": 10.01
                        },
                        {
                            "gap": 22.1117,
                            "total_time": 15.02,
                            "explored_nodes": 165,
                            "simplex_iterations": 8769,
                            "explored_time": 14.99,
                            "work_units": 11.25
                        },
                        {
                            "gap": 4.7055,
                            "total_time": 14.44,
                            "explored_nodes": 212017,
                            "simplex_iterations": 1572997,
                            "explored_time": 14.42,
                            "work_units": 10.03
                        },
                        {
                            "gap": 3.2445,
                            "total_time": 13.01,
                            "explored_nodes": 2854,
                            "simplex_iterations": 66244,
                            "explored_time": 12.98,
                            "work_units": 10.0
                        },
                        {
                            "gap": 24.8031,
                            "total_time": 12.12,
                            "explored_nodes": 87,
                            "simplex_iterations": 7265,
                            "explored_time": 12.1,
                            "work_units": 10.64
                        },
                        {
                            "gap": 9.7595,
                            "total_time": 15.13,
                            "explored_nodes": 255,
                            "simplex_iterations": 11500,
                            "explored_time": 15.1,
                            "work_units": 11.42
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "432d9042-f2df-467a-baef-e5c47fed0cca",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Constraint: The sum of all position variables u[i] must equal sum(1..n) = n(n+1)/2.\n    # This enforces global consistency of the position assignments, which relative MTZ constraints alone do not.\n    model.sum_u_cut = pyo.Constraint(expr=sum(model.u[i] for i in model.N) == n * (n + 1) / 2)\n\n    return model\n",
                        "added_cut": "# Constraint: The sum of all position variables u[i] must equal sum(1..n) = n(n+1)/2.\n# This enforces global consistency of the position assignments, which relative MTZ constraints alone do not.\nmodel.sum_u_cut = pyo.Constraint(expr=sum(model.u[i] for i in model.N) == n * (n + 1) / 2)",
                        "idea": "In any valid TSP tour, the position variables $u_i$ constitute a permutation of the integers $1, \\dots, n$. Consequently, their sum is invariant and must exactly equal the triangular number $n(n+1)/2$. While the MTZ constraints strictly enforce the relative order ($u_j \\ge u_i + 1$ when $x_{ij}=1$), the linear relaxation often permits 'compressed' distributions of $u_i$ (e.g., values clustered near lower bounds) that satisfy the difference inequalities but violate the global spread required for a permutation. This global sum constraint cuts such fractional solutions by enforcing the correct aggregate magnitude of the position variables."
                    },
                    "fitness": 2.0391779634294465,
                    "solver_reports": [
                        {
                            "gap": 7.0674,
                            "total_time": 11.38,
                            "explored_nodes": 3128,
                            "simplex_iterations": 51377,
                            "explored_time": 11.37,
                            "work_units": 10.04
                        },
                        {
                            "total_time": 12.41,
                            "explored_nodes": 1,
                            "simplex_iterations": 8171,
                            "explored_time": 12.36,
                            "work_units": 10.01
                        },
                        {
                            "gap": 10.626,
                            "total_time": 11.29,
                            "explored_nodes": 171,
                            "simplex_iterations": 16198,
                            "explored_time": 11.27,
                            "work_units": 10.41
                        },
                        {
                            "total_time": 14.61,
                            "explored_nodes": 1,
                            "simplex_iterations": 5159,
                            "explored_time": 14.54,
                            "work_units": 10.01
                        },
                        {
                            "gap": 20.2454,
                            "total_time": 10.64,
                            "explored_nodes": 9071,
                            "simplex_iterations": 100740,
                            "explored_time": 10.62,
                            "work_units": 10.01
                        },
                        {
                            "gap": 19.9632,
                            "total_time": 13.43,
                            "explored_nodes": 59,
                            "simplex_iterations": 6679,
                            "explored_time": 13.4,
                            "work_units": 12.05
                        },
                        {
                            "gap": 3.408,
                            "total_time": 12.99,
                            "explored_nodes": 280725,
                            "simplex_iterations": 1921259,
                            "explored_time": 12.98,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.9012,
                            "total_time": 10.27,
                            "explored_nodes": 169,
                            "simplex_iterations": 15460,
                            "explored_time": 10.25,
                            "work_units": 10.79
                        },
                        {
                            "gap": 7.7986,
                            "total_time": 12.24,
                            "explored_nodes": 59,
                            "simplex_iterations": 7728,
                            "explored_time": 12.21,
                            "work_units": 11.04
                        },
                        {
                            "gap": 35.5358,
                            "total_time": 12.82,
                            "explored_nodes": 59,
                            "simplex_iterations": 8090,
                            "explored_time": 12.79,
                            "work_units": 11.6
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "a4fa98b1-5cb1-4939-a2e2-519a5a4504bd",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Auxiliary variables to linearize the product u[i] * x[i,j]\n    # We define z[i,j] = u[i] * x[i,j] for all relevant arcs (excluding depot start)\n    model.z_indices = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != 1 and j != 1 and i != j])\n    model.z = pyo.Var(model.z_indices, domain=pyo.NonNegativeReals)\n    \n    # McCormick envelopes to enforce z[i,j] = u[i] * x[i,j]\n    # 1. Upper bound: z <= n * x (since u <= n)\n    model.z_env1 = pyo.Constraint(model.z_indices, rule=lambda m, i, j: m.z[i, j] <= n * m.x[i, j])\n    # 2. Upper bound: z <= u\n    model.z_env2 = pyo.Constraint(model.z_indices, rule=lambda m, i, j: m.z[i, j] <= m.u[i])\n    # 3. Lower bound: z >= u - n*(1 - x)\n    model.z_env3 = pyo.Constraint(model.z_indices, rule=lambda m, i, j: m.z[i, j] >= m.u[i] - n * (1 - m.x[i, j]))\n    \n    # Exact Position Consistency Constraint\n    # Enforces u[j] = 1 + sum(u[i] * x[i,j]) for all j != 1.\n    # This means u[j] is exactly 1 greater than the position of its predecessor.\n    model.exact_pos = pyo.Constraint(model.N, rule=lambda m, j: pyo.Constraint.Skip if j == 1 else m.u[j] == 1 + m.x[1, j] + sum(m.z[i, j] for i in m.N if i != 1 and i != j))\n\n    return model\n",
                        "added_cut": "# Auxiliary variables to linearize the product u[i] * x[i,j]\n# We define z[i,j] = u[i] * x[i,j] for all relevant arcs (excluding depot start)\nmodel.z_indices = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != 1 and j != 1 and i != j])\nmodel.z = pyo.Var(model.z_indices, domain=pyo.NonNegativeReals)\n\n# McCormick envelopes to enforce z[i,j] = u[i] * x[i,j]\n# 1. Upper bound: z <= n * x (since u <= n)\nmodel.z_env1 = pyo.Constraint(model.z_indices, rule=lambda m, i, j: m.z[i, j] <= n * m.x[i, j])\n# 2. Upper bound: z <= u\nmodel.z_env2 = pyo.Constraint(model.z_indices, rule=lambda m, i, j: m.z[i, j] <= m.u[i])\n# 3. Lower bound: z >= u - n*(1 - x)\nmodel.z_env3 = pyo.Constraint(model.z_indices, rule=lambda m, i, j: m.z[i, j] >= m.u[i] - n * (1 - m.x[i, j]))\n\n# Exact Position Consistency Constraint\n# Enforces u[j] = 1 + sum(u[i] * x[i,j]) for all j != 1.\n# This means u[j] is exactly 1 greater than the position of its predecessor.\nmodel.exact_pos = pyo.Constraint(model.N, rule=lambda m, j: pyo.Constraint.Skip if j == 1 else m.u[j] == 1 + m.x[1, j] + sum(m.z[i, j] for i in m.N if i != 1 and i != j))",
                        "idea": "The standard MTZ formulation uses difference inequalities ($u_j - u_i + n x_{ij} \\le n-1$) which loosely relax the requirement $u_j = u_i + 1$ when $x_{ij}=1$. This proposal enforces the **Exact Position Consistency** by implementing the recursive definition $u_j = 1 + \\sum_i u_i x_{ij}$ as a strict equality. We introduce auxiliary variables $z_{ij}$ to linearize the bilinear terms $u_i x_{ij}$ using McCormick envelopes. This creates a tight flow-like conservation law for the position variables, significantly reducing the feasible region of the linear relaxation by eliminating fractional solutions where the potentials $u$ do not align with the tour structure."
                    },
                    "fitness": 0.013559802975295675,
                    "solver_reports": [
                        {
                            "gap": 25.6263,
                            "total_time": 14.32,
                            "explored_nodes": 1,
                            "simplex_iterations": 11436,
                            "explored_time": 14.27,
                            "work_units": 10.0
                        },
                        {
                            "gap": 59.1545,
                            "total_time": 9.45,
                            "explored_nodes": 1,
                            "simplex_iterations": 8226,
                            "explored_time": 9.32,
                            "work_units": 10.01
                        },
                        {
                            "gap": 20.4935,
                            "total_time": 15.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 12945,
                            "explored_time": 15.11,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 10.6,
                            "explored_nodes": 1,
                            "simplex_iterations": 6223,
                            "explored_time": 10.45,
                            "work_units": 10.0
                        },
                        {
                            "gap": 36.5191,
                            "total_time": 12.94,
                            "explored_nodes": 1,
                            "simplex_iterations": 17165,
                            "explored_time": 12.93,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 9.09,
                            "explored_nodes": 1,
                            "simplex_iterations": 3448,
                            "explored_time": 9.0,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 2.15,
                            "postsolve": 0.01,
                            "explored_nodes": 532,
                            "simplex_iterations": 19514,
                            "explored_time": 2.15,
                            "work_units": 1.43
                        },
                        {
                            "gap": 42.6698,
                            "total_time": 14.2,
                            "explored_nodes": 1,
                            "simplex_iterations": 11549,
                            "explored_time": 14.16,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 9.1,
                            "explored_nodes": 1,
                            "simplex_iterations": 6858,
                            "explored_time": 9.05,
                            "work_units": 10.0
                        },
                        {
                            "gap": 86.8262,
                            "total_time": 9.58,
                            "explored_nodes": 1,
                            "simplex_iterations": 7744,
                            "explored_time": 9.5,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "95648c30-aca9-4fea-8e2c-fb3bde7624d4",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def intermediate_node_lower_bound(model, i):\n        # Apply only to non-depot nodes\n        if i == 1:\n            return pyo.Constraint.Skip\n        # If node i is the first visited node (x[1,i]=1), u[i] >= 2.\n        # If node i is NOT the first visited node (x[1,i]=0), it must be at least the 3rd node (u[i] >= 3).\n        # This linear constraint enforces u[i] >= 3 - x[1,i].\n        return model.u[i] >= 3 - model.x[1, i]\n    \n    model.intermediate_lb = pyo.Constraint(model.N, rule=intermediate_node_lower_bound)\n\n    return model\n",
                        "added_cut": "def intermediate_node_lower_bound(model, i):\n    # Apply only to non-depot nodes\n    if i == 1:\n        return pyo.Constraint.Skip\n    # If node i is the first visited node (x[1,i]=1), u[i] >= 2.\n    # If node i is NOT the first visited node (x[1,i]=0), it must be at least the 3rd node (u[i] >= 3).\n    # This linear constraint enforces u[i] >= 3 - x[1,i].\n    return model.u[i] >= 3 - model.x[1, i]\n\nmodel.intermediate_lb = pyo.Constraint(model.N, rule=intermediate_node_lower_bound)",
                        "idea": "We propose a lifted lower bound for the position variables of non-depot nodes. In the standard MTZ formulation, the lower bound is uniformly $u_i \\ge 2$. However, logically, any node $i$ that is not the immediate successor of the depot (i.e., $x_{1,i}=0$) must occupy a position of at least 3 in the tour sequence. The constraint $u_i \\ge 3 - x_{1,i}$ tightens the LP relaxation by forcing higher position values for nodes that are not fully committed to being the first visited city, effectively cutting fractional solutions where nodes act as 'partial' start nodes with low position values."
                    },
                    "fitness": 6.545435928894073,
                    "solver_reports": [
                        {
                            "gap": 30.3519,
                            "total_time": 12.9,
                            "explored_nodes": 11816,
                            "simplex_iterations": 127652,
                            "explored_time": 12.89,
                            "work_units": 10.08
                        },
                        {
                            "gap": 4.3855,
                            "total_time": 12.94,
                            "explored_nodes": 1,
                            "simplex_iterations": 6815,
                            "explored_time": 12.89,
                            "work_units": 10.0
                        },
                        {
                            "gap": 8.9458,
                            "total_time": 11.24,
                            "explored_nodes": 3719,
                            "simplex_iterations": 56876,
                            "explored_time": 11.22,
                            "work_units": 10.04
                        },
                        {
                            "gap": 92.5903,
                            "total_time": 14.51,
                            "explored_nodes": 1,
                            "simplex_iterations": 4456,
                            "explored_time": 14.44,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.5398,
                            "total_time": 13.05,
                            "explored_nodes": 3112,
                            "simplex_iterations": 55234,
                            "explored_time": 13.02,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.5735,
                            "total_time": 14.78,
                            "explored_nodes": 59,
                            "simplex_iterations": 6711,
                            "explored_time": 14.76,
                            "work_units": 12.15
                        },
                        {
                            "gap": 4.4917,
                            "total_time": 13.34,
                            "explored_nodes": 246197,
                            "simplex_iterations": 1634873,
                            "explored_time": 13.33,
                            "work_units": 10.01
                        },
                        {
                            "gap": 3.757,
                            "total_time": 10.93,
                            "explored_nodes": 2818,
                            "simplex_iterations": 69070,
                            "explored_time": 10.91,
                            "work_units": 10.0
                        },
                        {
                            "gap": 20.851,
                            "total_time": 11.77,
                            "explored_nodes": 87,
                            "simplex_iterations": 6569,
                            "explored_time": 11.75,
                            "work_units": 10.13
                        },
                        {
                            "gap": 10.6795,
                            "total_time": 13.19,
                            "explored_nodes": 1,
                            "simplex_iterations": 5240,
                            "explored_time": 13.15,
                            "work_units": 10.01
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "0831e691-65fb-49ac-b6ab-97815e9dee19",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Symmetric Lifted Upper Bound for u[i]\n    # If node i is not connected to the depot (x[i,1] == 0), it cannot be the last node (n).\n    # Thus, u[i] <= n - 1. If x[i,1] == 1, u[i] <= n (standard bound).\n    # This constraint tightens the standard u[i] <= n bound using the variable x[i,1].\n    def lifted_upper_bound_rule(model, i):\n        if i != 1:\n            return model.u[i] <= n - 1 + model.x[i, 1]\n        return pyo.Constraint.Skip\n    model.lifted_upper_bound = pyo.Constraint(model.N, rule=lifted_upper_bound_rule)\n\n    return model\n",
                        "added_cut": "    # Symmetric Lifted Upper Bound for u[i]\n    # If node i is not connected to the depot (x[i,1] == 0), it cannot be the last node (n).\n    # Thus, u[i] <= n - 1. If x[i,1] == 1, u[i] <= n (standard bound).\n    # This constraint tightens the standard u[i] <= n bound using the variable x[i,1].\n    def lifted_upper_bound_rule(model, i):\n        if i != 1:\n            return model.u[i] <= n - 1 + model.x[i, 1]\n        return pyo.Constraint.Skip\n    model.lifted_upper_bound = pyo.Constraint(model.N, rule=lifted_upper_bound_rule)",
                        "idea": "We propose a lifted upper bound constraint: $u_i \\le n - 1 + x_{i,1}$ for all non-depot nodes $i$. In the standard MTZ formulation, $u_i$ is bounded by $n$. However, combinatorially, a node $i$ can only attain the maximum position $n$ if it is the immediate predecessor of the depot (i.e., the last visited node, implying $x_{i,1}=1$). If $x_{i,1}=0$, the maximum possible position is $n-1$. This cut tightens the linear relaxation by strictly reducing the feasible domain of $u_i$ for all nodes not fully committed to being the tour's endpoint, eliminating fractional solutions where $u_i \\approx n$ despite $x_{i,1} \\approx 0$."
                    },
                    "fitness": 4.971060702467759,
                    "solver_reports": [
                        {
                            "gap": 8.4761,
                            "total_time": 12.52,
                            "explored_nodes": 4483,
                            "simplex_iterations": 53560,
                            "explored_time": 12.49,
                            "work_units": 10.0
                        },
                        {
                            "gap": 23.7852,
                            "total_time": 13.49,
                            "explored_nodes": 59,
                            "simplex_iterations": 8350,
                            "explored_time": 13.46,
                            "work_units": 10.32
                        },
                        {
                            "gap": 14.5491,
                            "total_time": 11.53,
                            "explored_nodes": 390,
                            "simplex_iterations": 14336,
                            "explored_time": 11.52,
                            "work_units": 10.03
                        },
                        {
                            "gap": 91.8479,
                            "total_time": 15.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 3720,
                            "explored_time": 15.08,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.3309,
                            "total_time": 11.67,
                            "explored_nodes": 4194,
                            "simplex_iterations": 47289,
                            "explored_time": 11.65,
                            "work_units": 10.0
                        },
                        {
                            "gap": 11.3507,
                            "total_time": 14.42,
                            "explored_nodes": 59,
                            "simplex_iterations": 4444,
                            "explored_time": 14.39,
                            "work_units": 12.04
                        },
                        {
                            "gap": 3.9783,
                            "total_time": 13.7,
                            "explored_nodes": 219550,
                            "simplex_iterations": 1415223,
                            "explored_time": 13.69,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.618,
                            "total_time": 11.77,
                            "explored_nodes": 3838,
                            "simplex_iterations": 65132,
                            "explored_time": 11.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 18.0985,
                            "total_time": 12.31,
                            "explored_nodes": 59,
                            "simplex_iterations": 5327,
                            "explored_time": 12.29,
                            "work_units": 11.03
                        },
                        {
                            "gap": 15.9231,
                            "total_time": 13.31,
                            "explored_nodes": 22,
                            "simplex_iterations": 5070,
                            "explored_time": 13.28,
                            "work_units": 10.03
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "78daf586-bb2d-436a-9d77-d2d00a44e502",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit Subtour Elimination Constraints (SECs) for all subsets of size 3.\n    # These constraints enforce that for any set of 3 nodes, at most 2 arcs can be active within the set.\n    def sec3_rule(model, i, j, k):\n        # Apply only to unique combinations of 3 distinct nodes\n        if i < j and j < k:\n            subset = [i, j, k]\n            # Sum of arcs entirely within the subset must be <= |S| - 1 = 2\n            return sum(model.x[u, v] for u in subset for v in subset if u != v) <= 2\n        return pyo.Constraint.Skip\n    \n    model.sec3 = pyo.Constraint(model.N, model.N, model.N, rule=sec3_rule)\n\n    return model\n",
                        "added_cut": "# Explicit Subtour Elimination Constraints (SECs) for all subsets of size 3.\n# These constraints enforce that for any set of 3 nodes, at most 2 arcs can be active within the set.\ndef sec3_rule(model, i, j, k):\n    # Apply only to unique combinations of 3 distinct nodes\n    if i < j and j < k:\n        subset = [i, j, k]\n        # Sum of arcs entirely within the subset must be <= |S| - 1 = 2\n        return sum(model.x[u, v] for u in subset for v in subset if u != v) <= 2\n    return pyo.Constraint.Skip\n\nmodel.sec3 = pyo.Constraint(model.N, model.N, model.N, rule=sec3_rule)",
                        "idea": "We introduce explicit Subtour Elimination Constraints (SECs) for all node triplets. The standard MTZ potential constraints ($u_i - u_j + n x_{ij} \\le n-1$) are effective for preventing integer subtours but provide a weak linear relaxation for small cycles. By explicitly enforcing $\\sum_{(u,v) \\in S} x_{uv} \\le 2$ for all subsets $|S|=3$, we strictly bound the density of arcs within any triad of cities. This cut eliminates fractional solutions that satisfy the potential difference logic but violate the structural connectivity requirements of a valid tour, significantly tightening the feasible region."
                    },
                    "fitness": 2.1821449846377585,
                    "solver_reports": [
                        {
                            "gap": 38.7022,
                            "total_time": 11.05,
                            "explored_nodes": 1,
                            "simplex_iterations": 969,
                            "explored_time": 10.96,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 6.93,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 6.47,
                            "work_units": 10.01
                        },
                        {
                            "gap": 40.3692,
                            "total_time": 10.55,
                            "explored_nodes": 1,
                            "simplex_iterations": 888,
                            "explored_time": 10.45,
                            "work_units": 10.02
                        },
                        {
                            "total_time": 8.61,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 7.89,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.5455,
                            "total_time": 15.57,
                            "explored_nodes": 1,
                            "simplex_iterations": 8026,
                            "explored_time": 15.5,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 6.07,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 5.68,
                            "work_units": 10.01
                        },
                        {
                            "gap": 0.0,
                            "total_time": 5.12,
                            "postsolve": 0.01,
                            "explored_nodes": 74657,
                            "simplex_iterations": 601061,
                            "explored_time": 5.12,
                            "work_units": 3.22
                        },
                        {
                            "gap": 5.7159,
                            "total_time": 10.83,
                            "explored_nodes": 1,
                            "simplex_iterations": 1598,
                            "explored_time": 10.72,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 8.3,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 8.1,
                            "work_units": 10.03
                        },
                        {
                            "total_time": 6.83,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 6.54,
                            "work_units": 10.01
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                }
            ],
            10.353038952236112
        ],
        [
            [
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "53b73298-ef1e-489d-8b12-b6a801153286",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Combined and Strengthened Lifted Bounds for u[i]\n    # These constraints integrate Parent 1's intermediate node tightening with Parent 2's depot-connection fixing.\n    # They enforce tight bounds on u[i] based on whether node i is the first visited, last visited, or an intermediate node.\n    \n    def enhanced_upper_bound_rule(m, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        # Tightens u[i] <= n - 1 for intermediate nodes (Parent 1 idea),\n        # while forcing u[i] <= 2 if i is the first node (Parent 2 idea).\n        # If x[1,i]=1 (first), RHS = n - 1 - (n - 3) = 2.\n        # If x[i,1]=1 (last),  RHS = n - 1 + 1 = n.\n        # If neither,          RHS = n - 1.\n        return m.u[i] <= n - 1 + m.x[i, 1] - (n - 3) * m.x[1, i]\n    \n    def enhanced_lower_bound_rule(m, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        # Tightens u[i] >= 3 for intermediate nodes (Symmetric to Parent 1),\n        # while forcing u[i] >= n if i is the last node (Parent 2 idea).\n        # If x[1,i]=1 (first), RHS = 3 - 1 = 2.\n        # If x[i,1]=1 (last),  RHS = 3 + (n - 3) = n.\n        # If neither,          RHS = 3.\n        return m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1]\n    \n    model.enhanced_depot_upper = pyo.Constraint(model.N, rule=enhanced_upper_bound_rule)\n    model.enhanced_depot_lower = pyo.Constraint(model.N, rule=enhanced_lower_bound_rule)\n\n    return model\n",
                        "added_cut": "# Combined and Strengthened Lifted Bounds for u[i]\n# These constraints integrate Parent 1's intermediate node tightening with Parent 2's depot-connection fixing.\n# They enforce tight bounds on u[i] based on whether node i is the first visited, last visited, or an intermediate node.\n\ndef enhanced_upper_bound_rule(m, i):\n    if i == 1:\n        return pyo.Constraint.Skip\n    # Tightens u[i] <= n - 1 for intermediate nodes (Parent 1 idea),\n    # while forcing u[i] <= 2 if i is the first node (Parent 2 idea).\n    # If x[1,i]=1 (first), RHS = n - 1 - (n - 3) = 2.\n    # If x[i,1]=1 (last),  RHS = n - 1 + 1 = n.\n    # If neither,          RHS = n - 1.\n    return m.u[i] <= n - 1 + m.x[i, 1] - (n - 3) * m.x[1, i]\n\ndef enhanced_lower_bound_rule(m, i):\n    if i == 1:\n        return pyo.Constraint.Skip\n    # Tightens u[i] >= 3 for intermediate nodes (Symmetric to Parent 1),\n    # while forcing u[i] >= n if i is the last node (Parent 2 idea).\n    # If x[1,i]=1 (first), RHS = 3 - 1 = 2.\n    # If x[i,1]=1 (last),  RHS = 3 + (n - 3) = n.\n    # If neither,          RHS = 3.\n    return m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1]\n\nmodel.enhanced_depot_upper = pyo.Constraint(model.N, rule=enhanced_upper_bound_rule)\nmodel.enhanced_depot_lower = pyo.Constraint(model.N, rule=enhanced_lower_bound_rule)",
                        "idea": "We combine Parent 1's logic (tightening bounds for nodes *not* connected to the depot) with Parent 2's logic (fixing bounds for nodes *connected* to the depot) into a single pair of strong lifted cuts. Specifically, for any non-depot node $i$: 1) The upper bound is tightened to $n-1$ if $i$ is intermediate, forced to $2$ if $i$ is first ($x_{1,i}=1$), and remains $n$ if $i$ is last ($x_{i,1}=1$). 2) The lower bound is raised to $3$ if $i$ is intermediate, forced to $n$ if $i$ is last, and remains $2$ if $i$ is first. This creates a tighter convex hull approximation for the MTZ subtour variables $u_i$ by exploiting the mutually exclusive roles (first, last, or intermediate) a node plays in the tour."
                    },
                    "fitness": 1.7028451877265267,
                    "solver_reports": [
                        {
                            "gap": 7.9012,
                            "total_time": 12.55,
                            "explored_nodes": 3520,
                            "simplex_iterations": 60486,
                            "explored_time": 12.53,
                            "work_units": 10.0
                        },
                        {
                            "gap": 55.9895,
                            "total_time": 11.5,
                            "explored_nodes": 1,
                            "simplex_iterations": 6973,
                            "explored_time": 11.45,
                            "work_units": 10.0
                        },
                        {
                            "gap": 22.0816,
                            "total_time": 11.01,
                            "explored_nodes": 1994,
                            "simplex_iterations": 37402,
                            "explored_time": 11.0,
                            "work_units": 10.04
                        },
                        {
                            "gap": 91.9378,
                            "total_time": 13.85,
                            "explored_nodes": 1,
                            "simplex_iterations": 3945,
                            "explored_time": 13.79,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.9062,
                            "total_time": 13.82,
                            "explored_nodes": 8804,
                            "simplex_iterations": 92126,
                            "explored_time": 13.79,
                            "work_units": 10.0
                        },
                        {
                            "gap": 37.375,
                            "total_time": 12.59,
                            "explored_nodes": 59,
                            "simplex_iterations": 5763,
                            "explored_time": 12.57,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.8481,
                            "total_time": 14.12,
                            "explored_nodes": 168310,
                            "simplex_iterations": 1101069,
                            "explored_time": 14.11,
                            "work_units": 10.05
                        },
                        {
                            "gap": 8.9884,
                            "total_time": 11.48,
                            "explored_nodes": 4131,
                            "simplex_iterations": 60158,
                            "explored_time": 11.45,
                            "work_units": 10.0
                        },
                        {
                            "gap": 42.3823,
                            "total_time": 13.44,
                            "explored_nodes": 171,
                            "simplex_iterations": 8366,
                            "explored_time": 13.41,
                            "work_units": 12.11
                        },
                        {
                            "gap": 32.2994,
                            "total_time": 13.29,
                            "explored_nodes": 14,
                            "simplex_iterations": 5778,
                            "explored_time": 13.22,
                            "work_units": 10.07
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "0831e691-65fb-49ac-b6ab-97815e9dee19",
                        "a481e3ef-3779-4707-abf4-ea11ba0b1cee"
                    ]
                },
                {
                    "id": "8cf8bad0-a59c-4cfa-b456-1007a94c7466",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def lifted_upper_bound_rule(model, i):\n        if i != 1:\n            # Lifted Constraint: u[i] <= (n - 1) + x[i, 1] - (n - 3) * x[1, i]\n            # This tightens the bound by considering the 'start' of the tour.\n            # If x[1, i] == 1 (i is first), u[i] is forced to 2.\n            return model.u[i] <= n - 1 + model.x[i, 1] - (n - 3) * model.x[1, i]\n        return pyo.Constraint.Skip\n    \n    model.lifted_upper_bound = pyo.Constraint(model.N, rule=lifted_upper_bound_rule)\n\n    return model\n",
                        "added_cut": "def lifted_upper_bound_rule(model, i):\n    if i != 1:\n        # Lifted Constraint: u[i] <= (n - 1) + x[i, 1] - (n - 3) * x[1, i]\n        # This tightens the bound by considering the 'start' of the tour.\n        # If x[1, i] == 1 (i is first), u[i] is forced to 2.\n        return model.u[i] <= n - 1 + model.x[i, 1] - (n - 3) * model.x[1, i]\n    return pyo.Constraint.Skip\n\nmodel.lifted_upper_bound = pyo.Constraint(model.N, rule=lifted_upper_bound_rule)",
                        "idea": "We perform sequential lifting on the proposed cut by introducing the variable $x_{1,i}$ (arc from depot to node $i$). The original constraint $u_i \\le n - 1 + x_{i,1}$ correctly identifies that $u_i$ can only reach $n$ if $x_{i,1}=1$. However, it is loose at the other extreme: if node $i$ is visited immediately after the depot ($x_{1,i}=1$), $u_i$ must be exactly 2. The original cut allows $u_i$ to be as high as $n-1$ in this case. By adding the lifting term $-(n-3)x_{1,i}$, we force the upper bound to $2$ when $x_{1,i}=1$ (since $n-1 - (n-3) = 2$), significantly tightening the feasible region for fractional solutions where nodes are partially 'first' in the tour."
                    },
                    "fitness": 5.145932720911251,
                    "solver_reports": [
                        {
                            "gap": 12.3178,
                            "total_time": 12.0,
                            "explored_nodes": 7000,
                            "simplex_iterations": 90210,
                            "explored_time": 11.98,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4673,
                            "total_time": 13.91,
                            "explored_nodes": 1,
                            "simplex_iterations": 5418,
                            "explored_time": 13.86,
                            "work_units": 10.0
                        },
                        {
                            "gap": 25.0844,
                            "total_time": 12.75,
                            "explored_nodes": 1030,
                            "simplex_iterations": 20832,
                            "explored_time": 12.74,
                            "work_units": 10.01
                        },
                        {
                            "gap": 91.6,
                            "total_time": 16.2,
                            "explored_nodes": 1,
                            "simplex_iterations": 3949,
                            "explored_time": 16.14,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1176,
                            "total_time": 11.6,
                            "explored_nodes": 2862,
                            "simplex_iterations": 48704,
                            "explored_time": 11.58,
                            "work_units": 10.0
                        },
                        {
                            "gap": 23.5778,
                            "total_time": 14.37,
                            "explored_nodes": 7,
                            "simplex_iterations": 3964,
                            "explored_time": 14.34,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.4061,
                            "total_time": 13.62,
                            "explored_nodes": 283213,
                            "simplex_iterations": 1824260,
                            "explored_time": 13.62,
                            "work_units": 10.03
                        },
                        {
                            "gap": 5.3503,
                            "total_time": 12.56,
                            "explored_nodes": 3005,
                            "simplex_iterations": 45393,
                            "explored_time": 12.53,
                            "work_units": 10.01
                        },
                        {
                            "gap": 29.8746,
                            "total_time": 13.06,
                            "explored_nodes": 115,
                            "simplex_iterations": 9200,
                            "explored_time": 13.04,
                            "work_units": 10.91
                        },
                        {
                            "gap": 6.2216,
                            "total_time": 13.84,
                            "explored_nodes": 115,
                            "simplex_iterations": 7047,
                            "explored_time": 13.81,
                            "work_units": 11.8
                        }
                    ],
                    "generator": "Lifted",
                    "parents_id": [
                        "0831e691-65fb-49ac-b6ab-97815e9dee19"
                    ]
                },
                {
                    "id": "4926d36f-8c47-4acd-85c0-17d66c8c68fb",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Desrochers & Laporte (1991) Lifted MTZ Subtour Elimination Constraints\n    # These constraints strengthen the relationship between position variables u[i] and u[j]\n    # for non-depot nodes by incorporating both the forward arc (i,j) and reverse arc (j,i).\n    # This tightens the LP relaxation significantly compared to the standard MTZ constraints.\n    \n    def lifted_mtz_rule(model, i, j):\n        # Apply only to distinct non-depot nodes (nodes 2..n)\n        if i != j and i != 1 and j != 1:\n            # Standard MTZ: u[i] - u[j] + n * x[i, j] <= n - 1\n            # Lifted MTZ:   u[i] - u[j] + (n - 1) * x[i, j] + (n - 3) * x[j, i] <= n - 2\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    \n    model.lifted_mtz_subtour = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Desrochers & Laporte (1991) Lifted MTZ Subtour Elimination Constraints\n# These constraints strengthen the relationship between position variables u[i] and u[j]\n# for non-depot nodes by incorporating both the forward arc (i,j) and reverse arc (j,i).\n# This tightens the LP relaxation significantly compared to the standard MTZ constraints.\n\ndef lifted_mtz_rule(model, i, j):\n    # Apply only to distinct non-depot nodes (nodes 2..n)\n    if i != j and i != 1 and j != 1:\n        # Standard MTZ: u[i] - u[j] + n * x[i, j] <= n - 1\n        # Lifted MTZ:   u[i] - u[j] + (n - 1) * x[i, j] + (n - 3) * x[j, i] <= n - 2\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\n\nmodel.lifted_mtz_subtour = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "While both parents tighten the LP relaxation by anchoring the absolute positions ($u_i$) of nodes directly connected to the depot (fixing the start and end of the tour), they neglect the weak relative ordering constraints between intermediate nodes. This offspring introduces the Lifted MTZ formulation (Desrochers & Laporte), which explicitly links $u_i$ and $u_j$ using both arc directions ($x_{i,j}$ and $x_{j,i}$). This is complementary because it tightens the 'middle' of the tour (constraining $u_i - u_j$ to $\\le 1$ if the reverse arc is used) where the parents and standard MTZ are loosest."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 12.54,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 12.52,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.68,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 13.6,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 12.55,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 12.52,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.72,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.63,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 12.51,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 12.49,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 12.68,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 12.61,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 14.9,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 14.9,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 10.47,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 10.45,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 12.36,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 12.33,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 12.9,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 12.84,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "0831e691-65fb-49ac-b6ab-97815e9dee19",
                        "a481e3ef-3779-4707-abf4-ea11ba0b1cee"
                    ]
                },
                {
                    "id": "1763cbb0-6224-4a77-a927-fd10b27cb9c2",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Combined Strengthened Cuts: Desrochers-Laporte Lifted MTZ + Depot Coupling\n    \n    # 1. Lifted MTZ Constraints (incorporating Parent 2's anti-cycle logic)\n    # Implements the Desrochers & Laporte (1991) strengthening: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2.\n    # This dominates standard MTZ and implicitly enforces x_ij + x_ji <= 1 (eliminating 2-cycles).\n    def lifted_mtz_rule(m, i, j):\n        if i != j and i != 1 and j != 1:\n            return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    model.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n    \n    # 2. Depot Coupling Constraints (incorporating Parent 1's logic)\n    # Tights the bounds on u[i] based on connections to the depot (Node 1).\n    \n    # If arc (1, i) is used (node i is first), u[i] must be 2. Constraint: u[i] <= n - (n-2)x_{1,i}\n    def depot_coupling_upper_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        return m.u[i] + (n - 2) * m.x[1, i] <= n\n    model.depot_coupling_upper = pyo.Constraint(model.N, rule=depot_coupling_upper_rule)\n    \n    # If arc (i, 1) is used (node i is last), u[i] must be n. Constraint: u[i] >= 2 + (n-2)x_{i,1}\n    def depot_coupling_lower_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        return m.u[i] >= 2 + (n - 2) * m.x[i, 1]\n    model.depot_coupling_lower = pyo.Constraint(model.N, rule=depot_coupling_lower_rule)\n\n    return model\n",
                        "added_cut": "# Combined Strengthened Cuts: Desrochers-Laporte Lifted MTZ + Depot Coupling\n\n# 1. Lifted MTZ Constraints (incorporating Parent 2's anti-cycle logic)\n# Implements the Desrochers & Laporte (1991) strengthening: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2.\n# This dominates standard MTZ and implicitly enforces x_ij + x_ji <= 1 (eliminating 2-cycles).\ndef lifted_mtz_rule(m, i, j):\n    if i != j and i != 1 and j != 1:\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\nmodel.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n# 2. Depot Coupling Constraints (incorporating Parent 1's logic)\n# Tights the bounds on u[i] based on connections to the depot (Node 1).\n\n# If arc (1, i) is used (node i is first), u[i] must be 2. Constraint: u[i] <= n - (n-2)x_{1,i}\ndef depot_coupling_upper_rule(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    return m.u[i] + (n - 2) * m.x[1, i] <= n\nmodel.depot_coupling_upper = pyo.Constraint(model.N, rule=depot_coupling_upper_rule)\n\n# If arc (i, 1) is used (node i is last), u[i] must be n. Constraint: u[i] >= 2 + (n-2)x_{i,1}\ndef depot_coupling_lower_rule(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    return m.u[i] >= 2 + (n - 2) * m.x[i, 1]\nmodel.depot_coupling_lower = pyo.Constraint(model.N, rule=depot_coupling_lower_rule)",
                        "idea": "We combine the core strengths of both parents by implementing the **Desrochers-Laporte (1991)** strengthening of the MTZ formulation. The 'Lifted MTZ' constraints ($u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} \\le n-2$) effectively merge the subtour elimination logic with Parent 2's insight, as they implicitly enforce $x_{ij} + x_{ji} \\le 1$ (preventing 2-cycles) while providing tighter bounds than standard MTZ. Simultaneously, we integrate Parent 1's 'Depot Coupling' constraints to strictly bind the potentials $u_i$ at the start ($u_i=2$) and end ($u_i=n$) of the tour based on depot adjacency. This creates a unified, tighter polytope for both the sequence variables and the arc selection."
                    },
                    "fitness": 3.240988471087519,
                    "solver_reports": [
                        {
                            "gap": 18.1822,
                            "total_time": 11.6,
                            "explored_nodes": 1078,
                            "simplex_iterations": 24519,
                            "explored_time": 11.58,
                            "work_units": 10.02
                        },
                        {
                            "total_time": 13.94,
                            "explored_nodes": 1,
                            "simplex_iterations": 2557,
                            "explored_time": 13.84,
                            "work_units": 10.0
                        },
                        {
                            "gap": 8.312,
                            "total_time": 11.99,
                            "explored_nodes": 1069,
                            "simplex_iterations": 22658,
                            "explored_time": 11.97,
                            "work_units": 10.1
                        },
                        {
                            "total_time": 12.16,
                            "explored_nodes": 1,
                            "simplex_iterations": 1714,
                            "explored_time": 12.07,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7778,
                            "total_time": 12.28,
                            "explored_nodes": 12300,
                            "simplex_iterations": 280691,
                            "explored_time": 12.27,
                            "work_units": 10.02
                        },
                        {
                            "gap": 86.3305,
                            "total_time": 11.85,
                            "explored_nodes": 1,
                            "simplex_iterations": 1804,
                            "explored_time": 11.78,
                            "work_units": 10.01
                        },
                        {
                            "gap": 0.0,
                            "total_time": 1.01,
                            "postsolve": 0.0,
                            "explored_nodes": 10701,
                            "simplex_iterations": 65788,
                            "explored_time": 1.01,
                            "work_units": 0.66
                        },
                        {
                            "gap": 7.2004,
                            "total_time": 10.23,
                            "explored_nodes": 932,
                            "simplex_iterations": 22020,
                            "explored_time": 10.22,
                            "work_units": 10.04
                        },
                        {
                            "gap": 18.816,
                            "total_time": 11.04,
                            "explored_nodes": 3,
                            "simplex_iterations": 1252,
                            "explored_time": 11.01,
                            "work_units": 10.02
                        },
                        {
                            "gap": 24.4524,
                            "total_time": 12.73,
                            "explored_nodes": 7,
                            "simplex_iterations": 1685,
                            "explored_time": 12.69,
                            "work_units": 10.07
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "a481e3ef-3779-4707-abf4-ea11ba0b1cee",
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "240238d0-ab9e-4be1-ad87-e0f5e539bc7d",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Desrochers & Laporte (1991) Lifted MTZ Constraint\n    # This constraint mathematically combines the goals of both parents:\n    # 1. It prevents 2-cycles (Parent 1) by including the reverse arc term (n-3)*x[j,i].\n    # 2. It tightens the linear relaxation of u (Parent 2) by reducing the RHS to n-2.\n    # Formula: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n - 2\n    \n    def dl_lifted_mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            # n is captured from the create_model scope\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    \n    model.dl_lifted_mtz = pyo.Constraint(model.N, model.N, rule=dl_lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Desrochers & Laporte (1991) Lifted MTZ Constraint\n# This constraint mathematically combines the goals of both parents:\n# 1. It prevents 2-cycles (Parent 1) by including the reverse arc term (n-3)*x[j,i].\n# 2. It tightens the linear relaxation of u (Parent 2) by reducing the RHS to n-2.\n# Formula: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n - 2\n\ndef dl_lifted_mtz_rule(model, i, j):\n    if i != j and i != 1 and j != 1:\n        # n is captured from the create_model scope\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\n\nmodel.dl_lifted_mtz = pyo.Constraint(model.N, model.N, rule=dl_lifted_mtz_rule)",
                        "idea": "We implement the Desrochers & Laporte lifting of the MTZ constraints. This formulation strictly dominates the standard MTZ constraints by incorporating the logic of 2-cycle elimination (Parent 1) directly into the subtour constraints via the term `(n-3)x[j,i]`. Simultaneously, it tightens the bounds on the position variables `u` (Parent 2) by reducing the right-hand side from `n-1` to `n-2`. This creates a unified, stronger cut that eliminates fractional 2-cycles and reduces the feasible polytope volume."
                    },
                    "fitness": 5.749458180182717,
                    "solver_reports": [
                        {
                            "gap": 11.7846,
                            "total_time": 12.33,
                            "explored_nodes": 543,
                            "simplex_iterations": 11251,
                            "explored_time": 12.31,
                            "work_units": 10.09
                        },
                        {
                            "gap": 14.9279,
                            "total_time": 14.62,
                            "explored_nodes": 1,
                            "simplex_iterations": 2078,
                            "explored_time": 14.54,
                            "work_units": 10.01
                        },
                        {
                            "gap": 15.1493,
                            "total_time": 11.45,
                            "explored_nodes": 87,
                            "simplex_iterations": 5248,
                            "explored_time": 11.43,
                            "work_units": 10.07
                        },
                        {
                            "total_time": 11.21,
                            "explored_nodes": 1,
                            "simplex_iterations": 2040,
                            "explored_time": 11.13,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.4378,
                            "total_time": 12.83,
                            "explored_nodes": 3526,
                            "simplex_iterations": 55582,
                            "explored_time": 12.8,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.5036,
                            "total_time": 12.06,
                            "explored_nodes": 1,
                            "simplex_iterations": 1759,
                            "explored_time": 12.0,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.9213,
                            "total_time": 12.9,
                            "explored_nodes": 384194,
                            "simplex_iterations": 2350050,
                            "explored_time": 12.9,
                            "work_units": 10.02
                        },
                        {
                            "gap": 2.6982,
                            "total_time": 14.17,
                            "explored_nodes": 2998,
                            "simplex_iterations": 53069,
                            "explored_time": 14.14,
                            "work_units": 10.01
                        },
                        {
                            "gap": 24.2041,
                            "total_time": 12.06,
                            "explored_nodes": 15,
                            "simplex_iterations": 2460,
                            "explored_time": 12.03,
                            "work_units": 10.12
                        },
                        {
                            "gap": 10.4753,
                            "total_time": 12.92,
                            "explored_nodes": 1,
                            "simplex_iterations": 1944,
                            "explored_time": 12.86,
                            "work_units": 10.1
                        }
                    ],
                    "generator": "Min_Violation",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "0831e691-65fb-49ac-b6ab-97815e9dee19"
                    ]
                },
                {
                    "id": "a3c882e2-1d24-4448-833a-d525ef400855",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Lifting-based mutation: Desrochers & Laporte (1991) constraints\n    # These lift the 2-cycle logic (x_ji) into the MTZ potential constraints (u).\n    def dl_lifted_sec_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            # Standard MTZ: u_i - u_j + n*x_ij <= n-1\n            # Lifted MTZ incorporates x_ji: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n            # This binds the reverse arc x_ji to the potential difference.\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    model.dl_lifted_sec = pyo.Constraint(model.N, model.N, rule=dl_lifted_sec_rule)\n\n    return model\n",
                        "added_cut": "# Lifting-based mutation: Desrochers & Laporte (1991) constraints\n# These lift the 2-cycle logic (x_ji) into the MTZ potential constraints (u).\ndef dl_lifted_sec_rule(model, i, j):\n    if i != j and i != 1 and j != 1:\n        # Standard MTZ: u_i - u_j + n*x_ij <= n-1\n        # Lifted MTZ incorporates x_ji: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n        # This binds the reverse arc x_ji to the potential difference.\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\nmodel.dl_lifted_sec = pyo.Constraint(model.N, model.N, rule=dl_lifted_sec_rule)",
                        "idea": "We perform a coefficient lifting of the provided 2-cycle cut ($x_{i,j} + x_{j,i} \\le 1$) into the existing MTZ subtour elimination constraints involving variables $u$. The standard MTZ constraint ignores the reverse arc $x_{j,i}$. By utilizing the logic that $x_{j,i}=1 \\implies u_i \\ge u_j + 1$, we can lift the inequality to include the term $(n-3)x_{j,i}$ and tighten the RHS to $n-2$. This **Desrochers-Laporte** inequality strictly dominates the original MTZ constraint and implicitly enforces 2-cycle elimination with a significantly tighter linear relaxation."
                    },
                    "fitness": 5.749458180182717,
                    "solver_reports": [
                        {
                            "gap": 11.7846,
                            "total_time": 12.25,
                            "explored_nodes": 543,
                            "simplex_iterations": 11251,
                            "explored_time": 12.23,
                            "work_units": 10.09
                        },
                        {
                            "gap": 14.9279,
                            "total_time": 14.7,
                            "explored_nodes": 1,
                            "simplex_iterations": 2078,
                            "explored_time": 14.6,
                            "work_units": 10.01
                        },
                        {
                            "gap": 15.1493,
                            "total_time": 11.19,
                            "explored_nodes": 87,
                            "simplex_iterations": 5248,
                            "explored_time": 11.17,
                            "work_units": 10.07
                        },
                        {
                            "total_time": 11.36,
                            "explored_nodes": 1,
                            "simplex_iterations": 2040,
                            "explored_time": 11.26,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.4378,
                            "total_time": 12.64,
                            "explored_nodes": 3526,
                            "simplex_iterations": 55582,
                            "explored_time": 12.63,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.5036,
                            "total_time": 12.91,
                            "explored_nodes": 1,
                            "simplex_iterations": 1759,
                            "explored_time": 12.83,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.9213,
                            "total_time": 14.09,
                            "explored_nodes": 384194,
                            "simplex_iterations": 2350050,
                            "explored_time": 14.08,
                            "work_units": 10.02
                        },
                        {
                            "gap": 2.6982,
                            "total_time": 14.23,
                            "explored_nodes": 2998,
                            "simplex_iterations": 53069,
                            "explored_time": 14.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 24.2041,
                            "total_time": 11.54,
                            "explored_nodes": 15,
                            "simplex_iterations": 2460,
                            "explored_time": 11.48,
                            "work_units": 10.12
                        },
                        {
                            "gap": 10.4753,
                            "total_time": 12.91,
                            "explored_nodes": 1,
                            "simplex_iterations": 1944,
                            "explored_time": 12.84,
                            "work_units": 10.1
                        }
                    ],
                    "generator": "Lifted",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "8c80e4d3-b1d7-4e10-8ef4-e7a6cc741829",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def depot_connectivity_upper_bound(model, i):\n        # This constraint applies to all non-depot nodes (node 1 is depot)\n        if i == 1:\n            return pyo.Constraint.Skip\n        \n        # Retrieve n from the model set\n        n = len(model.N)\n        \n        # We impose a conditional Upper Bound on u[i] based on its relationship to the depot.\n        # Logic:\n        # 1. If node i immediately follows the depot (x[1,i]=1), it must be at position 2.\n        #    The constraint implies u[i] <= 2. Combined with MTZ's u[i] >= 2, this fixes u[i]=2.\n        # 2. If node i immediately precedes the depot (x[i,1]=1), it is the last node, so u[i] <= n.\n        # 3. If node i is neither first nor last relative to the depot, it cannot be position n, so u[i] <= n-1.\n        \n        # Formula derivation:\n        # Base upper bound is (n - 1).\n        # - If x[1,i]=1, we subtract (n - 3) to reduce the bound to 2: (n-1) - (n-3) = 2.\n        # - If x[i,1]=1, we add 1 to increase the bound to n: (n-1) + 1 = n.\n        # - Terms are mutually exclusive in a valid tour for n > 2.\n        \n        return model.u[i] <= (n - 1) - (n - 3) * model.x[1, i] + model.x[i, 1]\n    \n    model.depot_connectivity_ub = pyo.Constraint(model.N, rule=depot_connectivity_upper_bound)\n\n    return model\n",
                        "added_cut": "def depot_connectivity_upper_bound(model, i):\n    # This constraint applies to all non-depot nodes (node 1 is depot)\n    if i == 1:\n        return pyo.Constraint.Skip\n    \n    # Retrieve n from the model set\n    n = len(model.N)\n    \n    # We impose a conditional Upper Bound on u[i] based on its relationship to the depot.\n    # Logic:\n    # 1. If node i immediately follows the depot (x[1,i]=1), it must be at position 2.\n    #    The constraint implies u[i] <= 2. Combined with MTZ's u[i] >= 2, this fixes u[i]=2.\n    # 2. If node i immediately precedes the depot (x[i,1]=1), it is the last node, so u[i] <= n.\n    # 3. If node i is neither first nor last relative to the depot, it cannot be position n, so u[i] <= n-1.\n    \n    # Formula derivation:\n    # Base upper bound is (n - 1).\n    # - If x[1,i]=1, we subtract (n - 3) to reduce the bound to 2: (n-1) - (n-3) = 2.\n    # - If x[i,1]=1, we add 1 to increase the bound to n: (n-1) + 1 = n.\n    # - Terms are mutually exclusive in a valid tour for n > 2.\n    \n    return model.u[i] <= (n - 1) - (n - 3) * model.x[1, i] + model.x[i, 1]\n\nmodel.depot_connectivity_ub = pyo.Constraint(model.N, rule=depot_connectivity_upper_bound)",
                        "idea": "We propose a 'Depot-Dependent Upper Bound' that acts as the symmetric complement to Parent 2. While Parent 2 tightens the Lower Bound ($u_i \\ge 3$ for non-start nodes), this cut tightens the Upper Bound. It strictly limits the position of the first node to 2 ($u_i \\le 2$ when $x_{1,i}=1$) and restricts all intermediate nodes to $n-1$, allowing only the node connected back to the depot ($x_{i,1}=1$) to reach position $n$. This 'sandwiches' the position variables for every node between tight conditional bounds derived from their depot connectivity, eliminating fractional solutions where $u$ variables drift to the middle or fail to align with their arc assignments."
                    },
                    "fitness": 5.689431877827994,
                    "solver_reports": [
                        {
                            "gap": 17.0032,
                            "total_time": 11.18,
                            "explored_nodes": 5127,
                            "simplex_iterations": 54070,
                            "explored_time": 11.16,
                            "work_units": 10.01
                        },
                        {
                            "gap": 39.7431,
                            "total_time": 14.32,
                            "explored_nodes": 1,
                            "simplex_iterations": 6217,
                            "explored_time": 14.26,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.2337,
                            "total_time": 11.75,
                            "explored_nodes": 1497,
                            "simplex_iterations": 28709,
                            "explored_time": 11.74,
                            "work_units": 10.03
                        },
                        {
                            "gap": 86.2211,
                            "total_time": 15.99,
                            "explored_nodes": 1,
                            "simplex_iterations": 2211,
                            "explored_time": 15.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.8175,
                            "total_time": 12.53,
                            "explored_nodes": 2810,
                            "simplex_iterations": 55966,
                            "explored_time": 12.5,
                            "work_units": 10.0
                        },
                        {
                            "gap": 75.7373,
                            "total_time": 13.82,
                            "explored_nodes": 115,
                            "simplex_iterations": 7835,
                            "explored_time": 13.79,
                            "work_units": 10.81
                        },
                        {
                            "gap": 4.0924,
                            "total_time": 13.43,
                            "explored_nodes": 319374,
                            "simplex_iterations": 2049099,
                            "explored_time": 13.42,
                            "work_units": 10.03
                        },
                        {
                            "gap": 1.4133,
                            "total_time": 12.13,
                            "explored_nodes": 3384,
                            "simplex_iterations": 56363,
                            "explored_time": 12.1,
                            "work_units": 10.0
                        },
                        {
                            "gap": 9.1149,
                            "total_time": 10.71,
                            "explored_nodes": 59,
                            "simplex_iterations": 5190,
                            "explored_time": 10.68,
                            "work_units": 10.35
                        },
                        {
                            "gap": 8.7277,
                            "total_time": 13.26,
                            "explored_nodes": 1,
                            "simplex_iterations": 3135,
                            "explored_time": 13.21,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "432d9042-f2df-467a-baef-e5c47fed0cca",
                        "95648c30-aca9-4fea-8e2c-fb3bde7624d4"
                    ]
                }
            ],
            10.353038952236112
        ],
        [
            [
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "0b70b4ba-fee4-425b-826a-735d726ac500",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Desrochers and Laporte (1991) Lifted MTZ Subtour Elimination\n    # This constraint fuses Parent 1's 2-cycle elimination logic with Parent 2's variable bounding approach.\n    # It replaces the standard MTZ inequality with a lifted version that includes the reverse arc variable x[j,i].\n    # This explicitly tightens the relaxation by preventing fractional 2-cycles (x[i,j] = x[j,i] = 0.5).\n    \n    def dl_lifted_rule(model, i, j):\n        # Apply only for non-depot nodes i, j\n        if i != j and i != 1 and j != 1:\n            # The Desrochers-Laporte inequality: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n            # Summing this for (i,j) and (j,i) yields exactly x_ij + x_ji <= 1 (Parent 1's cut).\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    \n    model.dl_lifted_sec = pyo.Constraint(model.N, model.N, rule=dl_lifted_rule)\n\n    return model\n",
                        "added_cut": "# Desrochers and Laporte (1991) Lifted MTZ Subtour Elimination\n# This constraint fuses Parent 1's 2-cycle elimination logic with Parent 2's variable bounding approach.\n# It replaces the standard MTZ inequality with a lifted version that includes the reverse arc variable x[j,i].\n# This explicitly tightens the relaxation by preventing fractional 2-cycles (x[i,j] = x[j,i] = 0.5).\n\ndef dl_lifted_rule(model, i, j):\n    # Apply only for non-depot nodes i, j\n    if i != j and i != 1 and j != 1:\n        # The Desrochers-Laporte inequality: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n        # Summing this for (i,j) and (j,i) yields exactly x_ij + x_ji <= 1 (Parent 1's cut).\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\n\nmodel.dl_lifted_sec = pyo.Constraint(model.N, model.N, rule=dl_lifted_rule)",
                        "idea": "We implement the Desrochers-Laporte lifted subtour constraints. This method strengthens the standard MTZ formulation by introducing a coefficient for the reverse arc $x_{j,i}$ into the potential difference constraint. Specifically, the term $(n-3)x_{j,i}$ is added, which effectively couples the ordering variables $u$ with the 2-cycle elimination logic. Mathematically, the pair of constraints for $(i,j)$ and $(j,i)$ implies $x_{i,j} + x_{j,i} \\le 1$, directly inheriting the high-fitness strength of Parent 1 while utilizing the lifting structure of Parent 2."
                    },
                    "fitness": 5.749458180182717,
                    "solver_reports": [
                        {
                            "gap": 11.7846,
                            "total_time": 11.48,
                            "explored_nodes": 543,
                            "simplex_iterations": 11251,
                            "explored_time": 11.46,
                            "work_units": 10.09
                        },
                        {
                            "gap": 14.9279,
                            "total_time": 14.65,
                            "explored_nodes": 1,
                            "simplex_iterations": 2078,
                            "explored_time": 14.55,
                            "work_units": 10.01
                        },
                        {
                            "gap": 15.1493,
                            "total_time": 12.5,
                            "explored_nodes": 87,
                            "simplex_iterations": 5248,
                            "explored_time": 12.48,
                            "work_units": 10.07
                        },
                        {
                            "total_time": 11.29,
                            "explored_nodes": 1,
                            "simplex_iterations": 2040,
                            "explored_time": 11.2,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.4378,
                            "total_time": 12.59,
                            "explored_nodes": 3526,
                            "simplex_iterations": 55582,
                            "explored_time": 12.57,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.5036,
                            "total_time": 12.39,
                            "explored_nodes": 1,
                            "simplex_iterations": 1759,
                            "explored_time": 12.32,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.9213,
                            "total_time": 13.55,
                            "explored_nodes": 384194,
                            "simplex_iterations": 2350050,
                            "explored_time": 13.53,
                            "work_units": 10.02
                        },
                        {
                            "gap": 2.6982,
                            "total_time": 13.29,
                            "explored_nodes": 2998,
                            "simplex_iterations": 53069,
                            "explored_time": 13.26,
                            "work_units": 10.01
                        },
                        {
                            "gap": 24.2041,
                            "total_time": 12.03,
                            "explored_nodes": 15,
                            "simplex_iterations": 2460,
                            "explored_time": 12.0,
                            "work_units": 10.12
                        },
                        {
                            "gap": 10.4753,
                            "total_time": 12.11,
                            "explored_nodes": 1,
                            "simplex_iterations": 1944,
                            "explored_time": 12.03,
                            "work_units": 10.1
                        }
                    ],
                    "generator": "Min_Violation",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "53b73298-ef1e-489d-8b12-b6a801153286"
                    ]
                },
                {
                    "id": "b2e68adb-4393-4640-8a87-2e866548fad3",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def depot_symmetric_lower_bound(model, i):\n        # This constraint applies to all non-depot nodes\n        if i == 1:\n            return pyo.Constraint.Skip\n        \n        n = len(model.N)\n        \n        # Symmetric Lower Bound Logic:\n        # 1. Intermediate nodes (not connected to depot) must be at least at position 3.\n        # 2. The first node (x[1,i]=1) is allowed to be at position 2 (term -1).\n        # 3. The last node (x[i,1]=1) is forced to be at position n (term +(n-3)).\n        # Expression: u[i] >= 3 - x[1,i] + (n-3)*x[i,1]\n        \n        return model.u[i] >= 3 - model.x[1, i] + (n - 3) * model.x[i, 1]\n    \n    model.depot_symmetric_lb = pyo.Constraint(model.N, rule=depot_symmetric_lower_bound)\n\n    return model\n",
                        "added_cut": "def depot_symmetric_lower_bound(model, i):\n    # This constraint applies to all non-depot nodes\n    if i == 1:\n        return pyo.Constraint.Skip\n    \n    n = len(model.N)\n    \n    # Symmetric Lower Bound Logic:\n    # 1. Intermediate nodes (not connected to depot) must be at least at position 3.\n    # 2. The first node (x[1,i]=1) is allowed to be at position 2 (term -1).\n    # 3. The last node (x[i,1]=1) is forced to be at position n (term +(n-3)).\n    # Expression: u[i] >= 3 - x[1,i] + (n-3)*x[i,1]\n    \n    return model.u[i] >= 3 - model.x[1, i] + (n - 3) * model.x[i, 1]\n\nmodel.depot_symmetric_lb = pyo.Constraint(model.N, rule=depot_symmetric_lower_bound)",
                        "idea": "We introduce a 'Symmetric Depot-Connectivity Lower Bound' to complement the Upper Bound constraints of the parents. While the parents restrict $u_i$ from above, this cut tightens the feasible region from below by enforcing $u_i \\ge 3$ for all intermediate nodes, effectively eliminating fractional solutions where nodes 'drift' to position 2 without being connected to the depot. It strictly forces $u_i \\ge n$ for the tour-end node ($x_{i,1}=1$) and reduces to the standard $u_i \\ge 2$ only for the tour-start node ($x_{1,i}=1$), creating a tight 'sandwich' on the position variables."
                    },
                    "fitness": 5.800442728840833,
                    "solver_reports": [
                        {
                            "gap": 9.0077,
                            "total_time": 10.97,
                            "explored_nodes": 4998,
                            "simplex_iterations": 60185,
                            "explored_time": 10.94,
                            "work_units": 10.03
                        },
                        {
                            "gap": 43.2737,
                            "total_time": 12.05,
                            "explored_nodes": 1,
                            "simplex_iterations": 6564,
                            "explored_time": 11.98,
                            "work_units": 10.0
                        },
                        {
                            "gap": 20.234,
                            "total_time": 11.01,
                            "explored_nodes": 3261,
                            "simplex_iterations": 50326,
                            "explored_time": 11.0,
                            "work_units": 10.04
                        },
                        {
                            "gap": 92.1123,
                            "total_time": 13.99,
                            "explored_nodes": 1,
                            "simplex_iterations": 4268,
                            "explored_time": 13.93,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.4655,
                            "total_time": 12.53,
                            "explored_nodes": 2845,
                            "simplex_iterations": 46010,
                            "explored_time": 12.5,
                            "work_units": 10.01
                        },
                        {
                            "gap": 63.3051,
                            "total_time": 12.53,
                            "explored_nodes": 37,
                            "simplex_iterations": 5531,
                            "explored_time": 12.51,
                            "work_units": 10.02
                        },
                        {
                            "gap": 0.0,
                            "total_time": 8.8,
                            "postsolve": 0.0,
                            "explored_nodes": 138454,
                            "simplex_iterations": 1050615,
                            "explored_time": 8.79,
                            "work_units": 6.34
                        },
                        {
                            "gap": 3.2766,
                            "total_time": 12.25,
                            "explored_nodes": 2770,
                            "simplex_iterations": 60150,
                            "explored_time": 12.24,
                            "work_units": 10.01
                        },
                        {
                            "gap": 8.0126,
                            "total_time": 13.95,
                            "explored_nodes": 171,
                            "simplex_iterations": 10755,
                            "explored_time": 13.91,
                            "work_units": 12.55
                        },
                        {
                            "gap": 7.9614,
                            "total_time": 15.01,
                            "explored_nodes": 59,
                            "simplex_iterations": 6151,
                            "explored_time": 14.98,
                            "work_units": 12.06
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "8c80e4d3-b1d7-4e10-8ef4-e7a6cc741829",
                        "8cf8bad0-a59c-4cfa-b456-1007a94c7466"
                    ]
                },
                {
                    "id": "1f6894fe-8a10-4113-9244-581d5cee5e89",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def lifted_desrochers_laporte_mtz(model, i, j):\n        # This constraint applies to pairs of non-depot nodes (i != 1, j != 1, i != j)\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        \n        n = len(model.N)\n        \n        # Hybrid Logic explanation:\n        # Parent 1 focuses on tightening the bounds of 'u' variables.\n        # Parent 2 focuses on eliminating 2-cycles (x_ij + x_ji <= 1).\n        # This constraint combines them by 'lifting' the standard MTZ constraint.\n        # Standard MTZ: u_i - u_j + (n-1)*x_ij <= n-2\n        # We add the term (n-3)*x_ji from Desrochers & Laporte (1991).\n        # If x_ji = 1 (reverse arc used), the RHS allows u_i - u_j to be at most 1, \n        # which is consistent with u_i = u_j + 1.\n        # Summing this inequality for (i,j) and (j,i) algebraically implies x_ij + x_ji <= 1.\n        \n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n    model.lifted_dl_mtz = pyo.Constraint(model.N, model.N, rule=lifted_desrochers_laporte_mtz)\n\n    return model\n",
                        "added_cut": "def lifted_desrochers_laporte_mtz(model, i, j):\n    # This constraint applies to pairs of non-depot nodes (i != 1, j != 1, i != j)\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    \n    n = len(model.N)\n    \n    # Hybrid Logic explanation:\n    # Parent 1 focuses on tightening the bounds of 'u' variables.\n    # Parent 2 focuses on eliminating 2-cycles (x_ij + x_ji <= 1).\n    # This constraint combines them by 'lifting' the standard MTZ constraint.\n    # Standard MTZ: u_i - u_j + (n-1)*x_ij <= n-2\n    # We add the term (n-3)*x_ji from Desrochers & Laporte (1991).\n    # If x_ji = 1 (reverse arc used), the RHS allows u_i - u_j to be at most 1, \n    # which is consistent with u_i = u_j + 1.\n    # Summing this inequality for (i,j) and (j,i) algebraically implies x_ij + x_ji <= 1.\n    \n    return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\nmodel.lifted_dl_mtz = pyo.Constraint(model.N, model.N, rule=lifted_desrochers_laporte_mtz)",
                        "idea": "We implement the Desrochers and Laporte 'Lifted' MTZ constraint. This is a structural hybrid that fuses Parent 1's focus on position variables ($u$) with Parent 2's detection of the reverse arc ($x_{j,i}$) as a source of weakness. By adding the term $(n-3)x_{j,i}$ to the standard MTZ inequality, we create a stronger valid inequality that strictly tightens the linear relaxation. It acts as a super-constraint that simultaneously enforces sequential ordering and explicitly eliminates 2-cycle subtours (algebraically implying Parent 2), thus effectively combining the strengths of both parents."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 11.83,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 11.81,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.64,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 13.57,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 13.14,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 13.12,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.86,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.76,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 12.77,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 12.75,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 12.39,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 12.31,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 15.03,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 15.03,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 11.01,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 10.99,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 11.82,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 11.79,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 13.17,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 13.1,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "8c80e4d3-b1d7-4e10-8ef4-e7a6cc741829",
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "842e0215-3951-44d2-986b-2afb6ed5d1ff",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def desrochers_laporte_cut(model, i, j):\n        # Apply only to distinct non-depot nodes\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        \n        n = len(model.N)\n        \n        # Desrochers & Laporte (1991) Lifted MTZ Constraint\n        # This tightens the interaction between any two non-depot nodes i and j.\n        # Compared to standard MTZ (u_i - u_j + n*x_ij <= n-1), this cut:\n        # 1. Reduces the Big-M coefficient on x_ij to (n-1).\n        # 2. Lifts the constraint with the reverse arc x_ji using coefficient (n-3).\n        # 3. Tightens the RHS to (n-2), which is the exact max difference (n) - (2).\n        \n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n    model.dl_lifted_cuts = pyo.Constraint(model.N, model.N, rule=desrochers_laporte_cut)\n\n    return model\n",
                        "added_cut": "def desrochers_laporte_cut(model, i, j):\n    # Apply only to distinct non-depot nodes\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    \n    n = len(model.N)\n    \n    # Desrochers & Laporte (1991) Lifted MTZ Constraint\n    # This tightens the interaction between any two non-depot nodes i and j.\n    # Compared to standard MTZ (u_i - u_j + n*x_ij <= n-1), this cut:\n    # 1. Reduces the Big-M coefficient on x_ij to (n-1).\n    # 2. Lifts the constraint with the reverse arc x_ji using coefficient (n-3).\n    # 3. Tightens the RHS to (n-2), which is the exact max difference (n) - (2).\n    \n    return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\nmodel.dl_lifted_cuts = pyo.Constraint(model.N, model.N, rule=desrochers_laporte_cut)",
                        "idea": "We propose the Desrochers-Laporte lifted subtour elimination constraints. While the user's cut tightens bounds based on depot connectivity, this cut strengthens the sequential ordering logic between all pairs of non-depot nodes. By incorporating the reverse arc variable $x_{ji}$ and tightening coefficients (reducing the 'Big-M' term and the RHS), this constraint strictly dominates the standard MTZ formulation provided in the base model, significantly reducing the feasible region of the linear relaxation."
                    },
                    "fitness": 5.749458180182717,
                    "solver_reports": [
                        {
                            "gap": 11.7846,
                            "total_time": 12.53,
                            "explored_nodes": 543,
                            "simplex_iterations": 11251,
                            "explored_time": 12.51,
                            "work_units": 10.09
                        },
                        {
                            "gap": 14.9279,
                            "total_time": 14.59,
                            "explored_nodes": 1,
                            "simplex_iterations": 2078,
                            "explored_time": 14.5,
                            "work_units": 10.01
                        },
                        {
                            "gap": 15.1493,
                            "total_time": 12.76,
                            "explored_nodes": 87,
                            "simplex_iterations": 5248,
                            "explored_time": 12.74,
                            "work_units": 10.07
                        },
                        {
                            "total_time": 11.21,
                            "explored_nodes": 1,
                            "simplex_iterations": 2040,
                            "explored_time": 11.11,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.4378,
                            "total_time": 12.8,
                            "explored_nodes": 3526,
                            "simplex_iterations": 55582,
                            "explored_time": 12.78,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.5036,
                            "total_time": 12.61,
                            "explored_nodes": 1,
                            "simplex_iterations": 1759,
                            "explored_time": 12.54,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.9213,
                            "total_time": 14.03,
                            "explored_nodes": 384194,
                            "simplex_iterations": 2350050,
                            "explored_time": 14.02,
                            "work_units": 10.02
                        },
                        {
                            "gap": 2.6982,
                            "total_time": 14.22,
                            "explored_nodes": 2998,
                            "simplex_iterations": 53069,
                            "explored_time": 14.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 24.2041,
                            "total_time": 11.61,
                            "explored_nodes": 15,
                            "simplex_iterations": 2460,
                            "explored_time": 11.58,
                            "work_units": 10.12
                        },
                        {
                            "gap": 10.4753,
                            "total_time": 12.64,
                            "explored_nodes": 1,
                            "simplex_iterations": 1944,
                            "explored_time": 12.57,
                            "work_units": 10.1
                        }
                    ],
                    "generator": "Exploratory",
                    "parents_id": [
                        "8c80e4d3-b1d7-4e10-8ef4-e7a6cc741829"
                    ]
                },
                {
                    "id": "b44f8a7f-07d6-4482-baaa-5797654dc5e7",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Depot-Lifted Positional Bounds\n    # This hybrid constraint tightens the formulation by applying the \"lifting\" concept from Parent 1\n    # (using variable coefficients to strengthen bounds) to the specific \"arc logic\" of Parent 2\n    # (targeting connections to the depot to enforce structural integrity).\n    \n    # Standard MTZ allows u[i] in [2, n] regardless of connections. \n    # These constraints strictly enforce that u[i] can only be 2 if x[1,i]=1, and n if x[i,1]=1.\n    \n    # Lifted Lower Bound: u[i] >= 3 - x[1,i]\n    #   If x[1,i] = 1 (connected from depot), u[i] >= 2.\n    #   If x[1,i] = 0 (not connected from depot), u[i] >= 3.\n    def lifted_lower_bound_rule(model, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        # Use 'n' from the outer scope as defined in create_model\n        return model.u[i] >= 3 - model.x[1, i]\n    \n    model.lifted_u_lower = pyo.Constraint(model.N, rule=lifted_lower_bound_rule)\n    \n    # Lifted Upper Bound: u[i] <= n - 1 + x[i,1]\n    #   If x[i,1] = 1 (connected to depot), u[i] <= n.\n    #   If x[i,1] = 0 (not connected to depot), u[i] <= n - 1.\n    def lifted_upper_bound_rule(model, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        return model.u[i] <= n - 1 + model.x[i, 1]\n    \n    model.lifted_u_upper = pyo.Constraint(model.N, rule=lifted_upper_bound_rule)\n\n    return model\n",
                        "added_cut": "# Depot-Lifted Positional Bounds\n# This hybrid constraint tightens the formulation by applying the \"lifting\" concept from Parent 1\n# (using variable coefficients to strengthen bounds) to the specific \"arc logic\" of Parent 2\n# (targeting connections to the depot to enforce structural integrity).\n\n# Standard MTZ allows u[i] in [2, n] regardless of connections. \n# These constraints strictly enforce that u[i] can only be 2 if x[1,i]=1, and n if x[i,1]=1.\n\n# Lifted Lower Bound: u[i] >= 3 - x[1,i]\n#   If x[1,i] = 1 (connected from depot), u[i] >= 2.\n#   If x[1,i] = 0 (not connected from depot), u[i] >= 3.\ndef lifted_lower_bound_rule(model, i):\n    if i == 1:\n        return pyo.Constraint.Skip\n    # Use 'n' from the outer scope as defined in create_model\n    return model.u[i] >= 3 - model.x[1, i]\n\nmodel.lifted_u_lower = pyo.Constraint(model.N, rule=lifted_lower_bound_rule)\n\n# Lifted Upper Bound: u[i] <= n - 1 + x[i,1]\n#   If x[i,1] = 1 (connected to depot), u[i] <= n.\n#   If x[i,1] = 0 (not connected to depot), u[i] <= n - 1.\ndef lifted_upper_bound_rule(model, i):\n    if i == 1:\n        return pyo.Constraint.Skip\n    return model.u[i] <= n - 1 + model.x[i, 1]\n\nmodel.lifted_u_upper = pyo.Constraint(model.N, rule=lifted_upper_bound_rule)",
                        "idea": "We introduce **Depot-Lifted Positional Bounds**, a hybrid cut that synthesizes the *lifting technique* of Parent 1 with the *explicit arc-logic* of Parent 2. While Parent 1 lifts the subtour constraints between nodes $i$ and $j$, this offspring applies lifting to the *domain bounds* of $u_i$ itself. By incorporating the binary variables $x_{1,i}$ and $x_{i,1}$, we strictly enforce that intermediate nodes (not directly connected to the depot) must dwell in the tighter range $[3, n-1]$, rather than $[2, n]$. This eliminates invalid fractional solutions where $u_i$ 'floats' near the boundaries without the necessary depot connection, effectively tightening the convex hull of the $(u, x)$ polytope."
                    },
                    "fitness": 2.9325682941231435,
                    "solver_reports": [
                        {
                            "gap": 13.9062,
                            "total_time": 12.73,
                            "explored_nodes": 6800,
                            "simplex_iterations": 76215,
                            "explored_time": 12.69,
                            "work_units": 10.0
                        },
                        {
                            "gap": 17.094,
                            "total_time": 13.52,
                            "explored_nodes": 1,
                            "simplex_iterations": 6535,
                            "explored_time": 13.47,
                            "work_units": 10.26
                        },
                        {
                            "gap": 17.9404,
                            "total_time": 11.08,
                            "explored_nodes": 4310,
                            "simplex_iterations": 54341,
                            "explored_time": 11.06,
                            "work_units": 10.03
                        },
                        {
                            "gap": 49.5778,
                            "total_time": 14.91,
                            "explored_nodes": 1,
                            "simplex_iterations": 2619,
                            "explored_time": 14.84,
                            "work_units": 10.17
                        },
                        {
                            "gap": 3.1065,
                            "total_time": 11.61,
                            "explored_nodes": 2810,
                            "simplex_iterations": 59009,
                            "explored_time": 11.6,
                            "work_units": 10.0
                        },
                        {
                            "gap": 47.4994,
                            "total_time": 12.94,
                            "explored_nodes": 141,
                            "simplex_iterations": 11319,
                            "explored_time": 12.91,
                            "work_units": 10.06
                        },
                        {
                            "gap": 4.1922,
                            "total_time": 14.24,
                            "explored_nodes": 243543,
                            "simplex_iterations": 1642630,
                            "explored_time": 14.23,
                            "work_units": 10.04
                        },
                        {
                            "gap": 2.0703,
                            "total_time": 13.09,
                            "explored_nodes": 2769,
                            "simplex_iterations": 66422,
                            "explored_time": 13.06,
                            "work_units": 10.0
                        },
                        {
                            "gap": 32.7091,
                            "total_time": 14.6,
                            "explored_nodes": 171,
                            "simplex_iterations": 11265,
                            "explored_time": 14.57,
                            "work_units": 13.57
                        },
                        {
                            "gap": 37.1448,
                            "total_time": 13.45,
                            "explored_nodes": 3,
                            "simplex_iterations": 3795,
                            "explored_time": 13.35,
                            "work_units": 10.05
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "240238d0-ab9e-4be1-ad87-e0f5e539bc7d",
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "5d4ffc18-fb12-45fa-b726-486076db022b",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Hybrid Lifted MTZ Constraint\n    # Combines Desrochers-Laporte logic (Parent 2) for internal nodes with\n    # strengthened potential bounds for depot connections to strictly enforce 2-cycle elimination (Parent 1 goal).\n    def hybrid_lifted_sec_rule(model, i, j):\n        if i == j:\n            return pyo.Constraint.Skip\n        \n        # Case 1: Internal Arcs (i, j != 1)\n        # Apply Desrochers & Laporte lifting: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n        # This strictly strengthens MTZ and implicitly cuts internal 2-cycles.\n        if i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        \n        # Case 2: Depot Outgoing Arcs (1 -> j)\n        # Tighten u_j bound: if x_1j=1, forces u_j=2. (Standard bounds only say u_j >= 2)\n        # Logic: u_j <= n - (n-2)*x_1j\n        elif i == 1:\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n            \n        # Case 3: Depot Incoming Arcs (i -> 1)\n        # Tighten u_i bound: if x_i1=1, forces u_i=n. (Standard bounds only say u_i <= n)\n        # Logic: u_i >= 2 + (n-2)*x_i1\n        elif j == 1:\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n    \n        return pyo.Constraint.Skip\n    \n    model.hybrid_lifted_sec = pyo.Constraint(model.N, model.N, rule=hybrid_lifted_sec_rule)\n\n    return model\n",
                        "added_cut": "# Hybrid Lifted MTZ Constraint\n# Combines Desrochers-Laporte logic (Parent 2) for internal nodes with\n# strengthened potential bounds for depot connections to strictly enforce 2-cycle elimination (Parent 1 goal).\ndef hybrid_lifted_sec_rule(model, i, j):\n    if i == j:\n        return pyo.Constraint.Skip\n    \n    # Case 1: Internal Arcs (i, j != 1)\n    # Apply Desrochers & Laporte lifting: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n    # This strictly strengthens MTZ and implicitly cuts internal 2-cycles.\n    if i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n    # Case 2: Depot Outgoing Arcs (1 -> j)\n    # Tighten u_j bound: if x_1j=1, forces u_j=2. (Standard bounds only say u_j >= 2)\n    # Logic: u_j <= n - (n-2)*x_1j\n    elif i == 1:\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n        \n    # Case 3: Depot Incoming Arcs (i -> 1)\n    # Tighten u_i bound: if x_i1=1, forces u_i=n. (Standard bounds only say u_i <= n)\n    # Logic: u_i >= 2 + (n-2)*x_i1\n    elif j == 1:\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n\n    return pyo.Constraint.Skip\n\nmodel.hybrid_lifted_sec = pyo.Constraint(model.N, model.N, rule=hybrid_lifted_sec_rule)",
                        "idea": "This hybrid constraint creates a 'Complete Lifted MTZ' system. It adopts the **Desrochers-Laporte (DL) lifting structure** from Parent 2 to tighten the subtour relaxation for internal nodes, but addresses P2's coverage gap by incorporating **new depot-tightening constraints**. These new cuts extend the lifting logic to the start/end of the tour, explicitly forcing $u_j=2$ when $1 \\to j$ and $u_i=n$ when $i \\to 1$. This combination globally strengthens the linear relaxation and implicitly enforces the **2-cycle elimination** goal of Parent 1 across the entire graph (both internal and depot-connected cycles) without requiring dense $O(n^3)$ cuts."
                    },
                    "fitness": 1.2598160141331316,
                    "solver_reports": [
                        {
                            "gap": 13.2745,
                            "total_time": 10.94,
                            "explored_nodes": 810,
                            "simplex_iterations": 18790,
                            "explored_time": 10.93,
                            "work_units": 10.03
                        },
                        {
                            "gap": 11.322,
                            "total_time": 14.07,
                            "explored_nodes": 1,
                            "simplex_iterations": 2266,
                            "explored_time": 13.97,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.2456,
                            "total_time": 11.48,
                            "explored_nodes": 456,
                            "simplex_iterations": 17496,
                            "explored_time": 11.47,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 12.65,
                            "explored_nodes": 1,
                            "simplex_iterations": 1615,
                            "explored_time": 12.53,
                            "work_units": 10.02
                        },
                        {
                            "gap": 1.037,
                            "total_time": 12.63,
                            "explored_nodes": 37689,
                            "simplex_iterations": 936834,
                            "explored_time": 12.62,
                            "work_units": 10.06
                        },
                        {
                            "total_time": 13.9,
                            "explored_nodes": 1,
                            "simplex_iterations": 1508,
                            "explored_time": 13.84,
                            "work_units": 10.09
                        },
                        {
                            "gap": 0.0,
                            "total_time": 3.19,
                            "postsolve": 0.01,
                            "explored_nodes": 60465,
                            "simplex_iterations": 375914,
                            "explored_time": 3.18,
                            "work_units": 1.86
                        },
                        {
                            "gap": 1.2806,
                            "total_time": 12.16,
                            "explored_nodes": 13735,
                            "simplex_iterations": 329922,
                            "explored_time": 12.14,
                            "work_units": 10.02
                        },
                        {
                            "gap": 7.5664,
                            "total_time": 13.29,
                            "explored_nodes": 1,
                            "simplex_iterations": 2768,
                            "explored_time": 13.25,
                            "work_units": 10.12
                        },
                        {
                            "gap": 88.2147,
                            "total_time": 13.09,
                            "explored_nodes": 1,
                            "simplex_iterations": 2294,
                            "explored_time": 13.0,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "a3c882e2-1d24-4448-833a-d525ef400855"
                    ]
                },
                {
                    "id": "61d82b83-4362-42a9-9c81-c577a0f64f9b",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Depot-Aware Lifted MTZ Constraint\n    # This constraint strengthens subtour elimination by exploiting the tighter position difference limits\n    # for \"intermediate\" nodes (those not directly connected to the depot). It tightens the base RHS\n    # from n-2 (Parent 1) to n-4, effectively squeezing the relaxation for internal paths, while\n    # dynamically adding slack terms for nodes connected to the depot (Parent 2 logic).\n    \n    def depot_aware_mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            n = len(model.N)\n            # Standard MTZ allows u[i]-u[j] <= n-2 (for i=last, j=first).\n            # For intermediate nodes, u[i]-u[j] <= n-4.\n            # We enforce the tighter bound n-4 globally, adding +2 slack if i is last (x[i,1]=1)\n            # and +2 slack if j is first (x[1,j]=1).\n            # Coefficients for x[i,j] and x[j,i] are adjusted to match the tighter RHS.\n            return model.u[i] - model.u[j] + (n - 3) * model.x[i, j] + (n - 5) * model.x[j, i] <= \\\n                   n - 4 + 2 * model.x[i, 1] + 2 * model.x[1, j]\n        return pyo.Constraint.Skip\n    \n    model.depot_aware_mtz = pyo.Constraint(model.N, model.N, rule=depot_aware_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Depot-Aware Lifted MTZ Constraint\n# This constraint strengthens subtour elimination by exploiting the tighter position difference limits\n# for \"intermediate\" nodes (those not directly connected to the depot). It tightens the base RHS\n# from n-2 (Parent 1) to n-4, effectively squeezing the relaxation for internal paths, while\n# dynamically adding slack terms for nodes connected to the depot (Parent 2 logic).\n\ndef depot_aware_mtz_rule(model, i, j):\n    if i != j and i != 1 and j != 1:\n        n = len(model.N)\n        # Standard MTZ allows u[i]-u[j] <= n-2 (for i=last, j=first).\n        # For intermediate nodes, u[i]-u[j] <= n-4.\n        # We enforce the tighter bound n-4 globally, adding +2 slack if i is last (x[i,1]=1)\n        # and +2 slack if j is first (x[1,j]=1).\n        # Coefficients for x[i,j] and x[j,i] are adjusted to match the tighter RHS.\n        return model.u[i] - model.u[j] + (n - 3) * model.x[i, j] + (n - 5) * model.x[j, i] <= \\\n               n - 4 + 2 * model.x[i, 1] + 2 * model.x[1, j]\n    return pyo.Constraint.Skip\n\nmodel.depot_aware_mtz = pyo.Constraint(model.N, model.N, rule=depot_aware_mtz_rule)",
                        "idea": "We construct a 'Depot-Aware' cut that fuses Parent 1's lifted difference logic with Parent 2's depot-connection bounds. Recognizing that the maximum position difference $u_i - u_j$ for two 'intermediate' nodes is strictly smaller ($n-4$) than for end-point nodes ($n-2$), we tighten the RHS and big-M coefficients to enforce this stricter bound on the bulk of the tour. To maintain validity, we re-inject slack dynamically via $2x_{i,1}$ and $2x_{1,j}$ only when nodes are actually connected to the depot. This results in a cut that is strictly tighter than Parent 1 for all disconnected intermediate pairs."
                    },
                    "fitness": 2.2329940041272773,
                    "solver_reports": [
                        {
                            "gap": 30.0979,
                            "total_time": 11.71,
                            "explored_nodes": 1,
                            "simplex_iterations": 1418,
                            "explored_time": 11.68,
                            "work_units": 10.06
                        },
                        {
                            "gap": 17.795,
                            "total_time": 12.34,
                            "explored_nodes": 1,
                            "simplex_iterations": 2149,
                            "explored_time": 12.22,
                            "work_units": 10.01
                        },
                        {
                            "gap": 29.579,
                            "total_time": 11.31,
                            "explored_nodes": 3,
                            "simplex_iterations": 1370,
                            "explored_time": 11.3,
                            "work_units": 10.05
                        },
                        {
                            "total_time": 11.9,
                            "explored_nodes": 1,
                            "simplex_iterations": 1849,
                            "explored_time": 11.79,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.0402,
                            "total_time": 11.87,
                            "explored_nodes": 711,
                            "simplex_iterations": 19979,
                            "explored_time": 11.86,
                            "work_units": 12.57
                        },
                        {
                            "gap": 28.3757,
                            "total_time": 12.9,
                            "explored_nodes": 1,
                            "simplex_iterations": 2100,
                            "explored_time": 12.81,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.9907,
                            "total_time": 12.98,
                            "explored_nodes": 159202,
                            "simplex_iterations": 1024302,
                            "explored_time": 12.98,
                            "work_units": 10.04
                        },
                        {
                            "gap": 9.6912,
                            "total_time": 10.6,
                            "explored_nodes": 115,
                            "simplex_iterations": 6190,
                            "explored_time": 10.58,
                            "work_units": 10.09
                        },
                        {
                            "gap": 32.0111,
                            "total_time": 12.18,
                            "explored_nodes": 1,
                            "simplex_iterations": 1775,
                            "explored_time": 12.11,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.71,
                            "explored_nodes": 1,
                            "simplex_iterations": 1920,
                            "explored_time": 13.63,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "240238d0-ab9e-4be1-ad87-e0f5e539bc7d",
                        "53b73298-ef1e-489d-8b12-b6a801153286"
                    ]
                }
            ],
            10.353038952236112
        ],
        [
            [
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "1be239de-c7de-4824-9891-f4ef84f0c6bf",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Reverse-Arc Lifted MTZ Constraints (Desrochers & Laporte)\n    # This exploratory cut strengthens the subtour elimination logic by 'lifting' the standard MTZ constraint\n    # with the reverse arc variable x[j,i]. Unlike the input cut which focuses on depot-node bounds,\n    # this formulation tightens the relative ordering between non-depot nodes i and j.\n    \n    def reverse_arc_lifted_mtz_rule(model, i, j):\n        # Apply to all pairs of non-depot nodes\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        \n        # The strengthened inequality:\n        # u[i] - u[j] + (n-1)*x[i,j] + (n-3)*x[j,i] <= n-2\n        # This dominates the standard MTZ constraint: u[i] - u[j] + n*x[i,j] <= n-1\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n    model.reverse_arc_lifted_mtz = pyo.Constraint(model.N, model.N, rule=reverse_arc_lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Reverse-Arc Lifted MTZ Constraints (Desrochers & Laporte)\n# This exploratory cut strengthens the subtour elimination logic by 'lifting' the standard MTZ constraint\n# with the reverse arc variable x[j,i]. Unlike the input cut which focuses on depot-node bounds,\n# this formulation tightens the relative ordering between non-depot nodes i and j.\n\ndef reverse_arc_lifted_mtz_rule(model, i, j):\n    # Apply to all pairs of non-depot nodes\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    \n    # The strengthened inequality:\n    # u[i] - u[j] + (n-1)*x[i,j] + (n-3)*x[j,i] <= n-2\n    # This dominates the standard MTZ constraint: u[i] - u[j] + n*x[i,j] <= n-1\n    return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\nmodel.reverse_arc_lifted_mtz = pyo.Constraint(model.N, model.N, rule=reverse_arc_lifted_mtz_rule)",
                        "idea": "We introduce **Reverse-Arc Lifted MTZ Constraints**, a structural mutation that shifts focus from absolute position bounds (as seen in the parent) to relative ordering logic between non-depot nodes. Derived from Desrochers and Laporte (1991), this cut incorporates the reverse arc variable $x_{j,i}$ into the subtour elimination constraint between $i$ and $j$. By lowering the Big-M coefficient from $n$ to $n-1$ and tightening the RHS to $n-2$, this inequality strictly dominates the standard MTZ constraints, pruning fractional solutions where arc variables are ambiguous while validly enforcing the tour sequence."
                    },
                    "fitness": 4.554829604258969,
                    "solver_reports": [
                        {
                            "gap": 11.8089,
                            "total_time": 11.54,
                            "explored_nodes": 495,
                            "simplex_iterations": 10786,
                            "explored_time": 11.52,
                            "work_units": 10.04
                        },
                        {
                            "gap": 11.4825,
                            "total_time": 13.58,
                            "explored_nodes": 1,
                            "simplex_iterations": 2294,
                            "explored_time": 13.5,
                            "work_units": 10.0
                        },
                        {
                            "gap": 12.5166,
                            "total_time": 12.13,
                            "explored_nodes": 201,
                            "simplex_iterations": 8460,
                            "explored_time": 12.11,
                            "work_units": 10.05
                        },
                        {
                            "total_time": 12.06,
                            "explored_nodes": 1,
                            "simplex_iterations": 2125,
                            "explored_time": 11.96,
                            "work_units": 10.01
                        },
                        {
                            "gap": 3.9764,
                            "total_time": 12.56,
                            "explored_nodes": 3851,
                            "simplex_iterations": 48903,
                            "explored_time": 12.53,
                            "work_units": 10.0
                        },
                        {
                            "gap": 33.1642,
                            "total_time": 13.57,
                            "explored_nodes": 1,
                            "simplex_iterations": 1731,
                            "explored_time": 13.49,
                            "work_units": 10.01
                        },
                        {
                            "gap": 3.0372,
                            "total_time": 13.63,
                            "explored_nodes": 683982,
                            "simplex_iterations": 3870269,
                            "explored_time": 13.62,
                            "work_units": 10.01
                        },
                        {
                            "gap": 2.0959,
                            "total_time": 13.9,
                            "explored_nodes": 2784,
                            "simplex_iterations": 58202,
                            "explored_time": 13.87,
                            "work_units": 10.0
                        },
                        {
                            "gap": 27.8274,
                            "total_time": 11.7,
                            "explored_nodes": 59,
                            "simplex_iterations": 3310,
                            "explored_time": 11.66,
                            "work_units": 10.47
                        },
                        {
                            "gap": 22.5364,
                            "total_time": 13.59,
                            "explored_nodes": 1,
                            "simplex_iterations": 1633,
                            "explored_time": 13.53,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Exploratory",
                    "parents_id": [
                        "b44f8a7f-07d6-4482-baaa-5797654dc5e7"
                    ]
                },
                {
                    "id": "dcd90ff2-bb0a-414a-bd36-ef2c65251b64",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def depot_anchored_lifted_cut(model, i, j):\n        # Apply only to distinct non-depot nodes\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        \n        n = len(model.N)\n        \n        # Depot-Anchored Lifted MTZ Constraint\n        # This constraint refines the Desrochers-Laporte cut (Parent 1) by utilizing the tighter\n        # 'intermediate node' bounds derived from the Depot Connectivity logic (Parent 2).\n        #\n        # Logic:\n        # 1. Intermediate nodes (not start/end of tour) have positions u in [3, n-1].\n        #    This implies a tighter max difference u[i] - u[j] <= n - 4.\n        # 2. We use this tighter RHS (n-4) as the baseline.\n        # 3. We reduce the lifting coefficients on x[i,j] and x[j,i] by 2 compared to DL cuts:\n        #    coeff x[i,j]: (n-1) -> (n-3)\n        #    coeff x[j,i]: (n-3) -> (n-5)\n        # 4. We subtract slack terms x[i,1] and x[1,j] to relax the constraint back to the\n        #    valid range for nodes directly connected to the depot.\n        \n        return model.u[i] - model.u[j] + (n - 3) * model.x[i, j] + (n - 5) * model.x[j, i] - model.x[i, 1] - model.x[1, j] <= n - 4\n    \n    model.depot_anchored_mtz = pyo.Constraint(model.N, model.N, rule=depot_anchored_lifted_cut)\n\n    return model\n",
                        "added_cut": "def depot_anchored_lifted_cut(model, i, j):\n    # Apply only to distinct non-depot nodes\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    \n    n = len(model.N)\n    \n    # Depot-Anchored Lifted MTZ Constraint\n    # This constraint refines the Desrochers-Laporte cut (Parent 1) by utilizing the tighter\n    # 'intermediate node' bounds derived from the Depot Connectivity logic (Parent 2).\n    #\n    # Logic:\n    # 1. Intermediate nodes (not start/end of tour) have positions u in [3, n-1].\n    #    This implies a tighter max difference u[i] - u[j] <= n - 4.\n    # 2. We use this tighter RHS (n-4) as the baseline.\n    # 3. We reduce the lifting coefficients on x[i,j] and x[j,i] by 2 compared to DL cuts:\n    #    coeff x[i,j]: (n-1) -> (n-3)\n    #    coeff x[j,i]: (n-3) -> (n-5)\n    # 4. We subtract slack terms x[i,1] and x[1,j] to relax the constraint back to the\n    #    valid range for nodes directly connected to the depot.\n    \n    return model.u[i] - model.u[j] + (n - 3) * model.x[i, j] + (n - 5) * model.x[j, i] - model.x[i, 1] - model.x[1, j] <= n - 4\n\nmodel.depot_anchored_mtz = pyo.Constraint(model.N, model.N, rule=depot_anchored_lifted_cut)",
                        "idea": "We propose the 'Depot-Anchored Lifted MTZ' constraint. By combining the lifted coefficients of Parent 1 with the depot-connectivity logic of Parent 2, we observe that for 'intermediate' nodes (not connected to the depot), the relative position difference is bounded by $n-4$ rather than $n-2$. We enforce this tighter bound as the baseline, reducing the large Big-M coefficients on $x_{i,j}$ and $x_{j,i}$ by 2 units each, and introduce slack variables $-x_{i,1}$ and $-x_{1,j}$ to validly relax the constraint only for the tour's start and end nodes. This results in a strictly tighter formulation for the majority of the matrix."
                    },
                    "fitness": 0.9031322657546172,
                    "solver_reports": [
                        {
                            "gap": 33.591,
                            "total_time": 11.03,
                            "explored_nodes": 470,
                            "simplex_iterations": 10708,
                            "explored_time": 11.01,
                            "work_units": 10.05
                        },
                        {
                            "gap": 25.5389,
                            "total_time": 11.62,
                            "explored_nodes": 1,
                            "simplex_iterations": 2382,
                            "explored_time": 11.51,
                            "work_units": 10.01
                        },
                        {
                            "gap": 15.0465,
                            "total_time": 11.66,
                            "explored_nodes": 143,
                            "simplex_iterations": 5397,
                            "explored_time": 11.64,
                            "work_units": 11.95
                        },
                        {
                            "total_time": 11.67,
                            "explored_nodes": 1,
                            "simplex_iterations": 1987,
                            "explored_time": 11.57,
                            "work_units": 10.0
                        },
                        {
                            "gap": 9.4499,
                            "total_time": 10.46,
                            "explored_nodes": 1205,
                            "simplex_iterations": 23464,
                            "explored_time": 10.45,
                            "work_units": 10.03
                        },
                        {
                            "gap": 29.0264,
                            "total_time": 10.88,
                            "explored_nodes": 1,
                            "simplex_iterations": 1908,
                            "explored_time": 10.8,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.9194,
                            "total_time": 12.65,
                            "explored_nodes": 182537,
                            "simplex_iterations": 1133508,
                            "explored_time": 12.64,
                            "work_units": 10.01
                        },
                        {
                            "gap": 10.4909,
                            "total_time": 11.02,
                            "explored_nodes": 143,
                            "simplex_iterations": 7860,
                            "explored_time": 11.0,
                            "work_units": 10.01
                        },
                        {
                            "gap": 30.3628,
                            "total_time": 12.71,
                            "explored_nodes": 1,
                            "simplex_iterations": 1286,
                            "explored_time": 12.66,
                            "work_units": 10.0
                        },
                        {
                            "gap": 51.4389,
                            "total_time": 12.2,
                            "explored_nodes": 1,
                            "simplex_iterations": 1517,
                            "explored_time": 12.14,
                            "work_units": 10.07
                        }
                    ],
                    "generator": "Min_Violation",
                    "parents_id": [
                        "842e0215-3951-44d2-986b-2afb6ed5d1ff",
                        "b2e68adb-4393-4640-8a87-2e866548fad3"
                    ]
                },
                {
                    "id": "79bc7cf1-c33a-45e5-8f99-11fe323858a3",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # 1. Desrochers & Laporte (1991) Lifted MTZ Cuts\n    # Strengthens sequential ordering between non-depot nodes\n    def dl_cut_rule(m, i, j):\n        # Apply only to distinct non-depot nodes\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        n = len(m.N)\n        # u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    \n    model.dl_lifted_cuts = pyo.Constraint(model.N, model.N, rule=dl_cut_rule)\n    \n    # 2. Depot-Position Lifting Constraints\n    # Explicitly links position variables u[i] to depot connections\n    def depot_start_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        n = len(m.N)\n        # If 1->i, then u[i] must be 2. (u[i] <= n - (n-2)*1 = 2)\n        return m.u[i] + (n - 2) * m.x[1, i] <= n\n    \n    model.depot_start_cuts = pyo.Constraint(model.N, rule=depot_start_rule)\n    \n    def depot_end_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        n = len(m.N)\n        # If i->1, then u[i] must be n. (u[i] >= 2 + (n-2)*1 = n)\n        return m.u[i] - (n - 2) * m.x[i, 1] >= 2\n    \n    model.depot_end_cuts = pyo.Constraint(model.N, rule=depot_end_rule)\n\n    return model\n",
                        "added_cut": "# 1. Desrochers & Laporte (1991) Lifted MTZ Cuts\n# Strengthens sequential ordering between non-depot nodes\ndef dl_cut_rule(m, i, j):\n    # Apply only to distinct non-depot nodes\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    n = len(m.N)\n    # u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n    return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n\nmodel.dl_lifted_cuts = pyo.Constraint(model.N, model.N, rule=dl_cut_rule)\n\n# 2. Depot-Position Lifting Constraints\n# Explicitly links position variables u[i] to depot connections\ndef depot_start_rule(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    n = len(m.N)\n    # If 1->i, then u[i] must be 2. (u[i] <= n - (n-2)*1 = 2)\n    return m.u[i] + (n - 2) * m.x[1, i] <= n\n\nmodel.depot_start_cuts = pyo.Constraint(model.N, rule=depot_start_rule)\n\ndef depot_end_rule(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    n = len(m.N)\n    # If i->1, then u[i] must be n. (u[i] >= 2 + (n-2)*1 = n)\n    return m.u[i] - (n - 2) * m.x[i, 1] >= 2\n\nmodel.depot_end_cuts = pyo.Constraint(model.N, rule=depot_end_rule)",
                        "idea": "We mutate the individual by supplementing the Desrochers-Laporte (DL) cuts with **Depot-Position Lifting constraints**. While the DL cuts tighten the relative ordering between non-depot nodes, they rely on loose general bounds ($u \\in [2, n]$). The new constraints strictly anchor the position variables to the depot: forcing $u_i=2$ if node $i$ follows the depot ($x_{1,i}=1$) and $u_i=n$ if it precedes the depot ($x_{i,1}=1$). This creates a stronger combined formulation where exact position values propagate through the DL constraints, significantly tightening the linear relaxation."
                    },
                    "fitness": 8.36156699066786,
                    "solver_reports": [
                        {
                            "gap": 15.3233,
                            "total_time": 12.0,
                            "explored_nodes": 772,
                            "simplex_iterations": 22493,
                            "explored_time": 11.98,
                            "work_units": 10.27
                        },
                        {
                            "gap": 8.7487,
                            "total_time": 14.71,
                            "explored_nodes": 1,
                            "simplex_iterations": 2038,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 8.5312,
                            "total_time": 10.28,
                            "explored_nodes": 1110,
                            "simplex_iterations": 28097,
                            "explored_time": 10.25,
                            "work_units": 10.02
                        },
                        {
                            "total_time": 12.84,
                            "explored_nodes": 1,
                            "simplex_iterations": 1611,
                            "explored_time": 12.7,
                            "work_units": 10.01
                        },
                        {
                            "gap": 2.3704,
                            "total_time": 13.79,
                            "explored_nodes": 3390,
                            "simplex_iterations": 71570,
                            "explored_time": 13.78,
                            "work_units": 10.02
                        },
                        {
                            "gap": 10.4932,
                            "total_time": 13.34,
                            "explored_nodes": 1,
                            "simplex_iterations": 1615,
                            "explored_time": 13.27,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 1.25,
                            "postsolve": 0.0,
                            "explored_nodes": 10661,
                            "simplex_iterations": 75528,
                            "explored_time": 1.24,
                            "work_units": 0.69
                        },
                        {
                            "gap": 8.7137,
                            "total_time": 12.71,
                            "explored_nodes": 59,
                            "simplex_iterations": 6141,
                            "explored_time": 12.7,
                            "work_units": 10.1
                        },
                        {
                            "gap": 17.4047,
                            "total_time": 10.56,
                            "explored_nodes": 15,
                            "simplex_iterations": 2317,
                            "explored_time": 10.53,
                            "work_units": 10.11
                        },
                        {
                            "total_time": 13.11,
                            "explored_nodes": 1,
                            "simplex_iterations": 2088,
                            "explored_time": 13.05,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "General",
                    "parents_id": [
                        "842e0215-3951-44d2-986b-2afb6ed5d1ff"
                    ]
                },
                {
                    "id": "e2108170-8861-4776-9b67-fe9a8d46a4f7",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def depot_symmetric_upper_bound(model, i):\n        # This constraint applies to all non-depot nodes to tighten their upper bounds\n        if i == 1:\n            return pyo.Constraint.Skip\n        \n        n = len(model.N)\n        \n        # Symmetric Upper Bound Logic:\n        # Completes the 'sandwich' on u[i] started by Parent 1's lower bound.\n        # 1. Intermediate nodes (not connected to depot) can be at most position n-1.\n        # 2. The first node (x[1,i]=1) must be at position <= 2 (Standard MTZ allows n).\n        # 3. The last node (x[i,1]=1) is allowed to be at position n.\n        # Formula: u[i] <= (n-1) - (n-3)*x[1,i] + x[i,1]\n        \n        return model.u[i] <= (n - 1) - (n - 3) * model.x[1, i] + model.x[i, 1]\n    \n    model.depot_symmetric_ub = pyo.Constraint(model.N, rule=depot_symmetric_upper_bound)\n\n    return model\n",
                        "added_cut": "def depot_symmetric_upper_bound(model, i):\n    # This constraint applies to all non-depot nodes to tighten their upper bounds\n    if i == 1:\n        return pyo.Constraint.Skip\n    \n    n = len(model.N)\n    \n    # Symmetric Upper Bound Logic:\n    # Completes the 'sandwich' on u[i] started by Parent 1's lower bound.\n    # 1. Intermediate nodes (not connected to depot) can be at most position n-1.\n    # 2. The first node (x[1,i]=1) must be at position <= 2 (Standard MTZ allows n).\n    # 3. The last node (x[i,1]=1) is allowed to be at position n.\n    # Formula: u[i] <= (n-1) - (n-3)*x[1,i] + x[i,1]\n    \n    return model.u[i] <= (n - 1) - (n - 3) * model.x[1, i] + model.x[i, 1]\n\nmodel.depot_symmetric_ub = pyo.Constraint(model.N, rule=depot_symmetric_upper_bound)",
                        "idea": "We introduce a 'Symmetric Depot-Connectivity Upper Bound' to act as the logical dual to Parent 1. While Parent 1 tightens the feasible region from below ($u_i \\ge 3$ for intermediates), this cut aggressively tightens it from above. Standard MTZ loosely bounds $u_i \\le n$ for all nodes. However, structurally, only the tour-end node ($x_{i,1}=1$) reaches position $n$, and the tour-start node ($x_{1,i}=1$) is fixed at 2. This constraint enforces $u_i \\le n-1$ for all intermediate nodes and $u_i \\le 2$ for the start node. When combined with Parent 1, this creates a tight bounding box ($3 \\le u_i \\le n-1$ for intermediates), eliminating large regions of fractional search space that Parent 2's subtour lifting does not address."
                    },
                    "fitness": 5.689431877827994,
                    "solver_reports": [
                        {
                            "gap": 17.0032,
                            "total_time": 11.54,
                            "explored_nodes": 5127,
                            "simplex_iterations": 54070,
                            "explored_time": 11.53,
                            "work_units": 10.01
                        },
                        {
                            "gap": 39.7431,
                            "total_time": 12.83,
                            "explored_nodes": 1,
                            "simplex_iterations": 6217,
                            "explored_time": 12.76,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.2337,
                            "total_time": 11.82,
                            "explored_nodes": 1497,
                            "simplex_iterations": 28709,
                            "explored_time": 11.8,
                            "work_units": 10.03
                        },
                        {
                            "gap": 86.2211,
                            "total_time": 14.4,
                            "explored_nodes": 1,
                            "simplex_iterations": 2211,
                            "explored_time": 14.33,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.8175,
                            "total_time": 12.02,
                            "explored_nodes": 2810,
                            "simplex_iterations": 55966,
                            "explored_time": 12.0,
                            "work_units": 10.0
                        },
                        {
                            "gap": 75.7373,
                            "total_time": 12.98,
                            "explored_nodes": 115,
                            "simplex_iterations": 7835,
                            "explored_time": 12.95,
                            "work_units": 10.81
                        },
                        {
                            "gap": 4.0924,
                            "total_time": 13.07,
                            "explored_nodes": 319374,
                            "simplex_iterations": 2049099,
                            "explored_time": 13.07,
                            "work_units": 10.03
                        },
                        {
                            "gap": 1.4133,
                            "total_time": 12.04,
                            "explored_nodes": 3384,
                            "simplex_iterations": 56363,
                            "explored_time": 12.02,
                            "work_units": 10.0
                        },
                        {
                            "gap": 9.1149,
                            "total_time": 10.67,
                            "explored_nodes": 59,
                            "simplex_iterations": 5190,
                            "explored_time": 10.65,
                            "work_units": 10.35
                        },
                        {
                            "gap": 8.7277,
                            "total_time": 12.88,
                            "explored_nodes": 1,
                            "simplex_iterations": 3135,
                            "explored_time": 12.84,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "b2e68adb-4393-4640-8a87-2e866548fad3",
                        "0b70b4ba-fee4-425b-826a-735d726ac500"
                    ]
                },
                {
                    "id": "c3b07586-17b2-4915-a140-798a00ece40a",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Combined Cut: Desrochers-Laporte Lifted MTZ + Depot-Connectivity Bounds\n    # This integrated constraint set strengthens the formulation in two ways:\n    # 1. Tighter Subtour Elimination: The DL constraints use reverse arcs to penalize fractional 2-cycles.\n    # 2. Tighter Variable Bounds: The Depot-Connectivity bounds restrict u[i] based on depot adjacency.\n    \n    # 1. Desrochers-Laporte (DL) Lifted Subtour Inequality (Parent 1)\n    def dl_lifted_rule(m, i, j):\n        # Applies to all pairs of non-depot nodes\n        if i != j and i != 1 and j != 1:\n            # Strengthening of MTZ: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n            return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    model.dl_lifted_sec = pyo.Constraint(model.N, model.N, rule=dl_lifted_rule)\n    \n    # 2. Symmetric Depot-Connectivity Lower Bound (Parent 2)\n    def depot_symmetric_lb_rule(m, i):\n        # Applies to all non-depot nodes\n        if i != 1:\n            # Enforces u[i] >= 3 if not connected to start, and u[i] >= n if connected to end.\n            # Expression: u[i] >= 3 - x[1,i] + (n-3)*x[i,1]\n            return m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1]\n        return pyo.Constraint.Skip\n    model.depot_symmetric_lb = pyo.Constraint(model.N, rule=depot_symmetric_lb_rule)\n\n    return model\n",
                        "added_cut": "# Combined Cut: Desrochers-Laporte Lifted MTZ + Depot-Connectivity Bounds\n# This integrated constraint set strengthens the formulation in two ways:\n# 1. Tighter Subtour Elimination: The DL constraints use reverse arcs to penalize fractional 2-cycles.\n# 2. Tighter Variable Bounds: The Depot-Connectivity bounds restrict u[i] based on depot adjacency.\n\n# 1. Desrochers-Laporte (DL) Lifted Subtour Inequality (Parent 1)\ndef dl_lifted_rule(m, i, j):\n    # Applies to all pairs of non-depot nodes\n    if i != j and i != 1 and j != 1:\n        # Strengthening of MTZ: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\nmodel.dl_lifted_sec = pyo.Constraint(model.N, model.N, rule=dl_lifted_rule)\n\n# 2. Symmetric Depot-Connectivity Lower Bound (Parent 2)\ndef depot_symmetric_lb_rule(m, i):\n    # Applies to all non-depot nodes\n    if i != 1:\n        # Enforces u[i] >= 3 if not connected to start, and u[i] >= n if connected to end.\n        # Expression: u[i] >= 3 - x[1,i] + (n-3)*x[i,1]\n        return m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1]\n    return pyo.Constraint.Skip\nmodel.depot_symmetric_lb = pyo.Constraint(model.N, rule=depot_symmetric_lb_rule)",
                        "idea": "We fuse the Desrochers-Laporte (DL) lifting with Symmetric Depot-Connectivity Lower Bounds. The DL constraints tighten the subtour relaxation by including the reverse arc term $(n-3)x_{j,i}$, which effectively prohibits fractional 2-cycles and strengthens the big-M coefficient. Simultaneously, the symmetric lower bounds restrict the positional variables $u_i$ by enforcing $u_i \\ge 3$ for intermediate nodes and $u_i = n$ for the tour-end node. This creates a 'sandwich' effect on the feasible polytope, restricting both the arc variables (via lifting) and the continuous position variables (via tighter bounds)."
                    },
                    "fitness": 2.272033540742042,
                    "solver_reports": [
                        {
                            "gap": 15.1536,
                            "total_time": 11.64,
                            "explored_nodes": 108,
                            "simplex_iterations": 6095,
                            "explored_time": 11.62,
                            "work_units": 10.04
                        },
                        {
                            "gap": 7.3927,
                            "total_time": 13.82,
                            "explored_nodes": 1,
                            "simplex_iterations": 2368,
                            "explored_time": 13.72,
                            "work_units": 10.0
                        },
                        {
                            "gap": 22.121,
                            "total_time": 11.13,
                            "explored_nodes": 1140,
                            "simplex_iterations": 24869,
                            "explored_time": 11.1,
                            "work_units": 10.19
                        },
                        {
                            "total_time": 12.51,
                            "explored_nodes": 1,
                            "simplex_iterations": 2176,
                            "explored_time": 12.37,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 11.83,
                            "explored_nodes": 4992,
                            "simplex_iterations": 54599,
                            "explored_time": 11.81,
                            "work_units": 10.01
                        },
                        {
                            "gap": 17.2086,
                            "total_time": 12.03,
                            "explored_nodes": 1,
                            "simplex_iterations": 1919,
                            "explored_time": 11.94,
                            "work_units": 10.01
                        },
                        {
                            "gap": 0.0,
                            "total_time": 7.08,
                            "postsolve": 0.01,
                            "explored_nodes": 124883,
                            "simplex_iterations": 949030,
                            "explored_time": 7.07,
                            "work_units": 4.48
                        },
                        {
                            "gap": 9.6477,
                            "total_time": 10.12,
                            "explored_nodes": 602,
                            "simplex_iterations": 13047,
                            "explored_time": 10.1,
                            "work_units": 10.04
                        },
                        {
                            "gap": 60.1099,
                            "total_time": 11.71,
                            "explored_nodes": 1,
                            "simplex_iterations": 1614,
                            "explored_time": 11.61,
                            "work_units": 10.0
                        },
                        {
                            "gap": 18.0477,
                            "total_time": 13.22,
                            "explored_nodes": 1,
                            "simplex_iterations": 1779,
                            "explored_time": 13.16,
                            "work_units": 10.02
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "0b70b4ba-fee4-425b-826a-735d726ac500",
                        "b2e68adb-4393-4640-8a87-2e866548fad3"
                    ]
                },
                {
                    "id": "4351a2f7-68f5-48e9-850c-c1be6beacb5a",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def complete_lifted_mtz_rule(model, i, j):\n        # Skip self-loops to prevent invalid indexing or redundant constraints\n        if i == j:\n            return pyo.Constraint.Skip\n        \n        n = len(model.N)\n        \n        # Case 1: Internal Arcs (Parent 2 Logic)\n        # Applies Desrochers-Laporte lifting for non-depot pairs.\n        # Tightens the standard MTZ by reducing the Big-M coeff to (n-1) \n        # and lifting with the reverse arc coeff (n-3).\n        if i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        \n        # Case 2: Depot Outgoing Arcs (1 -> j) (Parent 1 Logic)\n        # Explicitly tightens the upper bound of u[j].\n        # If x[1,j]=1, force u[j] <= 2. Since u[j] >= 2, this fixes u[j]=2.\n        # Logic: u[j] <= n - (n-2) * x[1,j]\n        elif i == 1:\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n    \n        # Case 3: Depot Incoming Arcs (i -> 1) (Parent 1 Logic)\n        # Explicitly tightens the lower bound of u[i].\n        # If x[i,1]=1, force u[i] >= n. Since u[i] <= n, this fixes u[i]=n.\n        # Logic: u[i] >= 2 + (n-2) * x[i,1]\n        elif j == 1:\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n    \n        return pyo.Constraint.Skip\n    \n    model.complete_lifted_mtz = pyo.Constraint(model.N, model.N, rule=complete_lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "def complete_lifted_mtz_rule(model, i, j):\n    # Skip self-loops to prevent invalid indexing or redundant constraints\n    if i == j:\n        return pyo.Constraint.Skip\n    \n    n = len(model.N)\n    \n    # Case 1: Internal Arcs (Parent 2 Logic)\n    # Applies Desrochers-Laporte lifting for non-depot pairs.\n    # Tightens the standard MTZ by reducing the Big-M coeff to (n-1) \n    # and lifting with the reverse arc coeff (n-3).\n    if i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n    # Case 2: Depot Outgoing Arcs (1 -> j) (Parent 1 Logic)\n    # Explicitly tightens the upper bound of u[j].\n    # If x[1,j]=1, force u[j] <= 2. Since u[j] >= 2, this fixes u[j]=2.\n    # Logic: u[j] <= n - (n-2) * x[1,j]\n    elif i == 1:\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n\n    # Case 3: Depot Incoming Arcs (i -> 1) (Parent 1 Logic)\n    # Explicitly tightens the lower bound of u[i].\n    # If x[i,1]=1, force u[i] >= n. Since u[i] <= n, this fixes u[i]=n.\n    # Logic: u[i] >= 2 + (n-2) * x[i,1]\n    elif j == 1:\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n\n    return pyo.Constraint.Skip\n\nmodel.complete_lifted_mtz = pyo.Constraint(model.N, model.N, rule=complete_lifted_mtz_rule)",
                        "idea": "This hybrid constraint implements a **Complete Lifted MTZ** system by fusing the structural strength of Parent 2 with the boundary precision of Parent 1. For internal nodes, it utilizes the **Desrochers-Laporte lifting** (coefficients $n-1$ and $n-3$) from Parent 2, which strictly dominates standard MTZ. Ideally complementing this, it incorporates Parent 1's **depot-tightening logic** for arcs connected to node 1, explicitly forcing $u_j=2$ and $u_i=n$ when connected to the depot. This combination eliminates fractional 'floating' tour values at the start/end of the sequence, tightening the convex hull approximation across the entire graph."
                    },
                    "fitness": 1.2598160141331316,
                    "solver_reports": [
                        {
                            "gap": 13.2745,
                            "total_time": 11.15,
                            "explored_nodes": 810,
                            "simplex_iterations": 18790,
                            "explored_time": 11.13,
                            "work_units": 10.03
                        },
                        {
                            "gap": 11.322,
                            "total_time": 14.17,
                            "explored_nodes": 1,
                            "simplex_iterations": 2266,
                            "explored_time": 14.04,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.2456,
                            "total_time": 11.06,
                            "explored_nodes": 456,
                            "simplex_iterations": 17496,
                            "explored_time": 11.04,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 12.87,
                            "explored_nodes": 1,
                            "simplex_iterations": 1615,
                            "explored_time": 12.77,
                            "work_units": 10.02
                        },
                        {
                            "gap": 1.037,
                            "total_time": 12.63,
                            "explored_nodes": 37689,
                            "simplex_iterations": 936834,
                            "explored_time": 12.62,
                            "work_units": 10.06
                        },
                        {
                            "total_time": 12.49,
                            "explored_nodes": 1,
                            "simplex_iterations": 1508,
                            "explored_time": 12.42,
                            "work_units": 10.09
                        },
                        {
                            "gap": 0.0,
                            "total_time": 3.36,
                            "postsolve": 0.01,
                            "explored_nodes": 60465,
                            "simplex_iterations": 375914,
                            "explored_time": 3.35,
                            "work_units": 1.86
                        },
                        {
                            "gap": 1.2806,
                            "total_time": 12.39,
                            "explored_nodes": 13735,
                            "simplex_iterations": 329922,
                            "explored_time": 12.37,
                            "work_units": 10.02
                        },
                        {
                            "gap": 7.5664,
                            "total_time": 13.64,
                            "explored_nodes": 1,
                            "simplex_iterations": 2768,
                            "explored_time": 13.61,
                            "work_units": 10.12
                        },
                        {
                            "gap": 88.2147,
                            "total_time": 12.94,
                            "explored_nodes": 1,
                            "simplex_iterations": 2294,
                            "explored_time": 12.87,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "5d4ffc18-fb12-45fa-b726-486076db022b",
                        "842e0215-3951-44d2-986b-2afb6ed5d1ff"
                    ]
                },
                {
                    "id": "0b446721-1401-4f67-aff8-77e2d1e0c6a0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Depot-Enhanced Lifted MTZ Formulation\n    # This hybrid combines the strong arc-based lifting of Desrochers-Laporte (Parent 2)\n    # with the absolute positional bound tightening of Parent 1.\n    \n    # Part 1: Depot-Lifted Positional Bounds (from Parent 1)\n    # These constraints tighten the domain of u[i] based on depot connectivity.\n    # If node i is not connected from depot (x[1,i]=0), it cannot be step 2, so u[i] >= 3.\n    # If node i is not connected to depot (x[i,1]=0), it cannot be step n, so u[i] <= n-1.\n    model.lifted_u_lb = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 3 - m.x[1, i] if i != 1 else pyo.Constraint.Skip)\n    model.lifted_u_ub = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n - 1 + m.x[i, 1] if i != 1 else pyo.Constraint.Skip)\n    \n    # Part 2: Desrochers-Laporte Lifted Cuts (from Parent 2)\n    # This applies the strongest valid lifting to the MTZ subtour elimination constraints\n    # by utilizing the reverse arc x[j,i] and tightening coefficients.\n    # Combined with Part 1, this eliminates fractional solutions where u variables 'float'\n    # in the standard [2, n] range without appropriate arc support.\n    def desrochers_laporte_rule(model, i, j):\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        # The DL inequality: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n    model.dl_cuts = pyo.Constraint(model.N, model.N, rule=desrochers_laporte_rule)\n\n    return model\n",
                        "added_cut": "# Depot-Enhanced Lifted MTZ Formulation\n# This hybrid combines the strong arc-based lifting of Desrochers-Laporte (Parent 2)\n# with the absolute positional bound tightening of Parent 1.\n\n# Part 1: Depot-Lifted Positional Bounds (from Parent 1)\n# These constraints tighten the domain of u[i] based on depot connectivity.\n# If node i is not connected from depot (x[1,i]=0), it cannot be step 2, so u[i] >= 3.\n# If node i is not connected to depot (x[i,1]=0), it cannot be step n, so u[i] <= n-1.\nmodel.lifted_u_lb = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 3 - m.x[1, i] if i != 1 else pyo.Constraint.Skip)\nmodel.lifted_u_ub = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n - 1 + m.x[i, 1] if i != 1 else pyo.Constraint.Skip)\n\n# Part 2: Desrochers-Laporte Lifted Cuts (from Parent 2)\n# This applies the strongest valid lifting to the MTZ subtour elimination constraints\n# by utilizing the reverse arc x[j,i] and tightening coefficients.\n# Combined with Part 1, this eliminates fractional solutions where u variables 'float'\n# in the standard [2, n] range without appropriate arc support.\ndef desrochers_laporte_rule(model, i, j):\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    # The DL inequality: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n    return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\nmodel.dl_cuts = pyo.Constraint(model.N, model.N, rule=desrochers_laporte_rule)",
                        "idea": "We propose the **Depot-Enhanced Lifted MTZ** formulation, a hybrid that fuses the strengths of both parents to strictly dominate the standard model. We retain the **Desrochers-Laporte** cuts from Parent 2, which provide the tightest known lifting for active subtours ($O(n^2)$), and augment them with the **Depot-Lifted Bounds** from Parent 1 ($O(n)$). This combination is synergistic: while DL cuts tighten the *relative* differences ($u_i - u_j$) for active arcs, the lifted bounds constrict the *absolute* domains of $u_i$ for the inactive majority (restricting 'floating' nodes to $[3, n-1]$). This results in a formulation that is tighter across the entire decision space."
                    },
                    "fitness": 4.4015641349182575,
                    "solver_reports": [
                        {
                            "gap": 8.8726,
                            "total_time": 12.29,
                            "explored_nodes": 205,
                            "simplex_iterations": 6165,
                            "explored_time": 12.27,
                            "work_units": 10.04
                        },
                        {
                            "gap": 13.1429,
                            "total_time": 14.33,
                            "explored_nodes": 1,
                            "simplex_iterations": 2125,
                            "explored_time": 14.21,
                            "work_units": 10.0
                        },
                        {
                            "gap": 12.882,
                            "total_time": 10.89,
                            "explored_nodes": 59,
                            "simplex_iterations": 3181,
                            "explored_time": 10.87,
                            "work_units": 10.17
                        },
                        {
                            "total_time": 15.11,
                            "explored_nodes": 1,
                            "simplex_iterations": 2234,
                            "explored_time": 14.99,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.2461,
                            "total_time": 10.31,
                            "explored_nodes": 7626,
                            "simplex_iterations": 78167,
                            "explored_time": 10.28,
                            "work_units": 10.04
                        },
                        {
                            "gap": 16.7735,
                            "total_time": 13.27,
                            "explored_nodes": 1,
                            "simplex_iterations": 1775,
                            "explored_time": 13.2,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.948,
                            "total_time": 13.3,
                            "explored_nodes": 185585,
                            "simplex_iterations": 1202096,
                            "explored_time": 13.3,
                            "work_units": 10.02
                        },
                        {
                            "gap": 5.5722,
                            "total_time": 10.46,
                            "explored_nodes": 1642,
                            "simplex_iterations": 26802,
                            "explored_time": 10.44,
                            "work_units": 10.01
                        },
                        {
                            "gap": 19.8486,
                            "total_time": 11.49,
                            "explored_nodes": 31,
                            "simplex_iterations": 4146,
                            "explored_time": 11.45,
                            "work_units": 10.08
                        },
                        {
                            "gap": 16.8689,
                            "total_time": 13.73,
                            "explored_nodes": 1,
                            "simplex_iterations": 1759,
                            "explored_time": 13.63,
                            "work_units": 10.11
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "b44f8a7f-07d6-4482-baaa-5797654dc5e7",
                        "842e0215-3951-44d2-986b-2afb6ed5d1ff"
                    ]
                }
            ],
            10.353038952236112
        ],
        [
            [
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "913a02db-5ac8-4b6d-bc79-038fe25b976c",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Combined Strengthened Cuts: DL Lifting + Tightened Depot Bounds\n    \n    # 1. Desrochers & Laporte (1991) Lifted MTZ Constraints\n    # Strengthens the subtour elimination inequality by incorporating the reverse arc x[j,i].\n    # This tightens the relative ordering logic between non-depot nodes.\n    def dl_cut_rule(m, i, j):\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        # u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    model.dl_lifted_cuts = pyo.Constraint(model.N, model.N, rule=dl_cut_rule)\n    \n    # 2. Tightened Depot-Position Lower Bounds\n    # Strictly dominates Parent 2's depot cuts by enforcing u[i] >= 3 for nodes NOT connected to the depot.\n    # Formula: u[i] >= 3 + (n-3)*x[i,1] - x[1,i]\n    def depot_tight_lb_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        # Cases:\n        # x[1,i]=1 (Start node) -> RHS = 2. Matches u[i]=2.\n        # x[i,1]=1 (End node)   -> RHS = n. Matches u[i]=n.\n        # Neither               -> RHS = 3. Stronger than basic u[i] >= 2.\n        return m.u[i] >= 3 + (n - 3) * m.x[i, 1] - m.x[1, i]\n    model.depot_tight_lb = pyo.Constraint(model.N, rule=depot_tight_lb_rule)\n    \n    # 3. Tightened Depot-Position Upper Bounds\n    # Strictly dominates Parent 2's depot cuts by enforcing u[i] <= n-1 for nodes NOT connected to the depot.\n    # Formula: u[i] <= n - 1 - (n-3)*x[1,i] + x[i,1]\n    def depot_tight_ub_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        # Cases:\n        # x[1,i]=1 (Start node) -> RHS = 2. Matches u[i]=2.\n        # x[i,1]=1 (End node)   -> RHS = n. Matches u[i]=n.\n        # Neither               -> RHS = n-1. Stronger than basic u[i] <= n.\n        return m.u[i] <= n - 1 - (n - 3) * m.x[1, i] + m.x[i, 1]\n    model.depot_tight_ub = pyo.Constraint(model.N, rule=depot_tight_ub_rule)\n\n    return model\n",
                        "added_cut": "# Combined Strengthened Cuts: DL Lifting + Tightened Depot Bounds\n\n# 1. Desrochers & Laporte (1991) Lifted MTZ Constraints\n# Strengthens the subtour elimination inequality by incorporating the reverse arc x[j,i].\n# This tightens the relative ordering logic between non-depot nodes.\ndef dl_cut_rule(m, i, j):\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    # u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\n    return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\nmodel.dl_lifted_cuts = pyo.Constraint(model.N, model.N, rule=dl_cut_rule)\n\n# 2. Tightened Depot-Position Lower Bounds\n# Strictly dominates Parent 2's depot cuts by enforcing u[i] >= 3 for nodes NOT connected to the depot.\n# Formula: u[i] >= 3 + (n-3)*x[i,1] - x[1,i]\ndef depot_tight_lb_rule(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    # Cases:\n    # x[1,i]=1 (Start node) -> RHS = 2. Matches u[i]=2.\n    # x[i,1]=1 (End node)   -> RHS = n. Matches u[i]=n.\n    # Neither               -> RHS = 3. Stronger than basic u[i] >= 2.\n    return m.u[i] >= 3 + (n - 3) * m.x[i, 1] - m.x[1, i]\nmodel.depot_tight_lb = pyo.Constraint(model.N, rule=depot_tight_lb_rule)\n\n# 3. Tightened Depot-Position Upper Bounds\n# Strictly dominates Parent 2's depot cuts by enforcing u[i] <= n-1 for nodes NOT connected to the depot.\n# Formula: u[i] <= n - 1 - (n-3)*x[1,i] + x[i,1]\ndef depot_tight_ub_rule(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    # Cases:\n    # x[1,i]=1 (Start node) -> RHS = 2. Matches u[i]=2.\n    # x[i,1]=1 (End node)   -> RHS = n. Matches u[i]=n.\n    # Neither               -> RHS = n-1. Stronger than basic u[i] <= n.\n    return m.u[i] <= n - 1 - (n - 3) * m.x[1, i] + m.x[i, 1]\nmodel.depot_tight_ub = pyo.Constraint(model.N, rule=depot_tight_ub_rule)",
                        "idea": "We integrate the structural Desrochers-Laporte (DL) lifted cuts from Parent 1 with **Tightened Depot-Position Bounds**, a strict improvement over Parent 2. While Parent 2 simply linked position variables to depot arcs (forcing $u_i=2$ if $1 \\to i$), this formulation tightens the bounds for *intermediate* nodes (those not connected to the depot) to $u_i \\in [3, n-1]$. Specifically, the new inequalities $u_i \\ge 3 + (n-3)x_{i,1} - x_{1,i}$ and $u_i \\le n - 1 - (n-3)x_{1,i} + x_{i,1}$ strictly dominate the standard bounds, effectively reducing the search space for the position variables and enhancing the effectiveness of the DL subtour elimination constraints."
                    },
                    "fitness": 1.107031472183953,
                    "solver_reports": [
                        {
                            "gap": 13.4132,
                            "total_time": 11.65,
                            "explored_nodes": 199,
                            "simplex_iterations": 8758,
                            "explored_time": 11.63,
                            "work_units": 10.61
                        },
                        {
                            "gap": 6.1487,
                            "total_time": 13.98,
                            "explored_nodes": 1,
                            "simplex_iterations": 1709,
                            "explored_time": 13.89,
                            "work_units": 10.0
                        },
                        {
                            "gap": 9.3985,
                            "total_time": 11.77,
                            "explored_nodes": 901,
                            "simplex_iterations": 21903,
                            "explored_time": 11.75,
                            "work_units": 10.04
                        },
                        {
                            "total_time": 14.0,
                            "explored_nodes": 1,
                            "simplex_iterations": 1733,
                            "explored_time": 13.89,
                            "work_units": 10.01
                        },
                        {
                            "gap": 6.196,
                            "total_time": 11.63,
                            "explored_nodes": 3090,
                            "simplex_iterations": 46523,
                            "explored_time": 11.62,
                            "work_units": 10.0
                        },
                        {
                            "gap": 90.5182,
                            "total_time": 13.53,
                            "explored_nodes": 1,
                            "simplex_iterations": 1398,
                            "explored_time": 13.45,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 3.94,
                            "postsolve": 0.01,
                            "explored_nodes": 58767,
                            "simplex_iterations": 428653,
                            "explored_time": 3.93,
                            "work_units": 2.29
                        },
                        {
                            "gap": 1.741,
                            "total_time": 13.36,
                            "explored_nodes": 2781,
                            "simplex_iterations": 65961,
                            "explored_time": 13.33,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.0497,
                            "total_time": 13.01,
                            "explored_nodes": 1,
                            "simplex_iterations": 2018,
                            "explored_time": 12.96,
                            "work_units": 10.0
                        },
                        {
                            "gap": 87.3874,
                            "total_time": 13.14,
                            "explored_nodes": 1,
                            "simplex_iterations": 1620,
                            "explored_time": 13.05,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "1be239de-c7de-4824-9891-f4ef84f0c6bf",
                        "79bc7cf1-c33a-45e5-8f99-11fe323858a3"
                    ]
                },
                {
                    "id": "02dbc955-1fc7-47d0-a42a-7bf0f22756b4",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Depot-Locked DL-MTZ Formulation\n    # This hybrid strategy minimizes joint violation by fusing the robust Desrochers-Laporte (DL) \n    # subtour cuts (from Parent 2) with 'Super-Lifted' positional bounds that dominate Parent 1.\n    \n    # 1. Super-Lifted Positional Bounds\n    # These constraints tighten the decision space by effectively 'locking' u[i] to its exact \n    # value (2 or n) if connected to the depot, and enforcing a tighter inner range [3, n-1] otherwise.\n    # This strictly dominates the bounds from Parent 1.\n    \n    # LB: u[i] >= 3 - x[1,i] + (n-3)x[i,1]\n    # Logic: If start node (x[1,i]=1) -> u[i] >= 2. If end node (x[i,1]=1) -> u[i] >= n. Else -> u[i] >= 3.\n    model.super_u_lb = pyo.Constraint(model.N, rule=lambda m, i: \n        m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1] if i != 1 else pyo.Constraint.Skip)\n    \n    # UB: u[i] <= n - 1 + x[i,1] - (n-3)x[1,i]\n    # Logic: If start node (x[1,i]=1) -> u[i] <= 2. If end node (x[i,1]=1) -> u[i] <= n. Else -> u[i] <= n-1.\n    model.super_u_ub = pyo.Constraint(model.N, rule=lambda m, i: \n        m.u[i] <= n - 1 + m.x[i, 1] - (n - 3) * m.x[1, i] if i != 1 else pyo.Constraint.Skip)\n    \n    # 2. Desrochers-Laporte (DL) Lifted Cuts (from Parent 2)\n    # Strengthens relative ordering by lifting MTZ with reverse arcs.\n    # Equation: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\n    def dl_cuts_rule(m, i, j):\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    \n    model.dl_cuts = pyo.Constraint(model.N, model.N, rule=dl_cuts_rule)\n\n    return model\n",
                        "added_cut": "# Depot-Locked DL-MTZ Formulation\n# This hybrid strategy minimizes joint violation by fusing the robust Desrochers-Laporte (DL) \n# subtour cuts (from Parent 2) with 'Super-Lifted' positional bounds that dominate Parent 1.\n\n# 1. Super-Lifted Positional Bounds\n# These constraints tighten the decision space by effectively 'locking' u[i] to its exact \n# value (2 or n) if connected to the depot, and enforcing a tighter inner range [3, n-1] otherwise.\n# This strictly dominates the bounds from Parent 1.\n\n# LB: u[i] >= 3 - x[1,i] + (n-3)x[i,1]\n# Logic: If start node (x[1,i]=1) -> u[i] >= 2. If end node (x[i,1]=1) -> u[i] >= n. Else -> u[i] >= 3.\nmodel.super_u_lb = pyo.Constraint(model.N, rule=lambda m, i: \n    m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1] if i != 1 else pyo.Constraint.Skip)\n\n# UB: u[i] <= n - 1 + x[i,1] - (n-3)x[1,i]\n# Logic: If start node (x[1,i]=1) -> u[i] <= 2. If end node (x[i,1]=1) -> u[i] <= n. Else -> u[i] <= n-1.\nmodel.super_u_ub = pyo.Constraint(model.N, rule=lambda m, i: \n    m.u[i] <= n - 1 + m.x[i, 1] - (n - 3) * m.x[1, i] if i != 1 else pyo.Constraint.Skip)\n\n# 2. Desrochers-Laporte (DL) Lifted Cuts (from Parent 2)\n# Strengthens relative ordering by lifting MTZ with reverse arcs.\n# Equation: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\ndef dl_cuts_rule(m, i, j):\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n\nmodel.dl_cuts = pyo.Constraint(model.N, model.N, rule=dl_cuts_rule)",
                        "idea": "We propose the **Depot-Locked DL-MTZ** formulation, a robust hybrid that minimizes joint violation by enforcing constraints on both absolute node positions and relative arc orderings. We retain the **Desrochers-Laporte** cuts (Parent 2) for their $O(n^2)$ lifting strength on active subtours. We augment this with **Super-Lifted Positional Bounds**, which strictly dominate Parent 1's bounds by incorporating depot-connection logic directly into the bound inequalities. These new bounds force $u_i$ to exactly $2$ or $n$ when connected to the depot, and restrict 'floating' nodes to $[3, n-1]$, significantly tightening the LP relaxation rooted in the depot."
                    },
                    "fitness": 1.738637781252625,
                    "solver_reports": [
                        {
                            "gap": 13.6479,
                            "total_time": 12.14,
                            "explored_nodes": 232,
                            "simplex_iterations": 8222,
                            "explored_time": 12.12,
                            "work_units": 10.07
                        },
                        {
                            "gap": 6.2517,
                            "total_time": 13.45,
                            "explored_nodes": 1,
                            "simplex_iterations": 1855,
                            "explored_time": 13.34,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.557,
                            "total_time": 12.25,
                            "explored_nodes": 143,
                            "simplex_iterations": 3897,
                            "explored_time": 12.23,
                            "work_units": 10.05
                        },
                        {
                            "total_time": 13.63,
                            "explored_nodes": 1,
                            "simplex_iterations": 1522,
                            "explored_time": 13.51,
                            "work_units": 10.01
                        },
                        {
                            "gap": 8.227,
                            "total_time": 10.99,
                            "explored_nodes": 4357,
                            "simplex_iterations": 53771,
                            "explored_time": 10.97,
                            "work_units": 10.0
                        },
                        {
                            "gap": 90.956,
                            "total_time": 12.76,
                            "explored_nodes": 1,
                            "simplex_iterations": 1478,
                            "explored_time": 12.69,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 1.19,
                            "postsolve": 0.01,
                            "explored_nodes": 12371,
                            "simplex_iterations": 77544,
                            "explored_time": 1.19,
                            "work_units": 0.77
                        },
                        {
                            "gap": 8.7954,
                            "total_time": 10.41,
                            "explored_nodes": 1089,
                            "simplex_iterations": 23126,
                            "explored_time": 10.39,
                            "work_units": 10.24
                        },
                        {
                            "gap": 27.3297,
                            "total_time": 11.88,
                            "explored_nodes": 1,
                            "simplex_iterations": 1067,
                            "explored_time": 11.81,
                            "work_units": 10.13
                        },
                        {
                            "gap": 38.9995,
                            "total_time": 13.81,
                            "explored_nodes": 1,
                            "simplex_iterations": 1263,
                            "explored_time": 13.73,
                            "work_units": 10.01
                        }
                    ],
                    "generator": "Min_Violation",
                    "parents_id": [
                        "0b446721-1401-4f67-aff8-77e2d1e0c6a0",
                        "1be239de-c7de-4824-9891-f4ef84f0c6bf"
                    ]
                },
                {
                    "id": "a5b5e126-005b-48ea-8d3f-65cad8f7b2ac",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Global Permutation-Sum & Exact Anchor Cuts\n    # This offspring introduces global structural knowledge of the position variables 'u'.\n    # Unlike parents that focus on relative differences (arc-based lifting), this formulation \n    # constrains the absolute sum of positions and strictly anchors the start/end nodes of the tour.\n    \n    # 1. Global Position Sum:\n    # In any valid tour, the variables u[2]...u[n] must form a permutation of 2...n.\n    # Their sum is fixed at (n*(n+1)/2) - 1. This constraint invalidates relaxed solutions\n    # where u-values are artificially compressed towards lower bounds to satisfy difference constraints.\n    def global_pos_sum_rule(model):\n        target_sum = (n * (n + 1)) / 2 - 1\n        return sum(model.u[i] for i in model.N if i != 1) == target_sum\n    model.global_pos_sum = pyo.Constraint(rule=global_pos_sum_rule)\n    \n    # 2. Exact Start Anchor:\n    # If node i is visited immediately after the depot (x[1,i]=1), then u[i] must be exactly 2.\n    # Parent 1 only enforces u[i] >= 2 in this case; this cut enforces the upper bound u[i] <= 2.\n    # Formula: u[i] <= n - (n-2)*x[1,i]. \n    # Check: If x[1,i]=1 -> u[i]<=2. If x[1,i]=0 -> u[i]<=n.\n    model.anchor_start_ub = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n - (n - 2) * m.x[1, i] if i != 1 else pyo.Constraint.Skip)\n    \n    # 3. Exact End Anchor:\n    # If node i visits the depot (x[i,1]=1), then u[i] must be exactly n.\n    # Parent 1 only enforces u[i] <= n in this case; this cut enforces the lower bound u[i] >= n.\n    # Formula: u[i] >= 2 + (n-2)*x[i,1].\n    # Check: If x[i,1]=1 -> u[i]>=n. If x[i,1]=0 -> u[i]>=2.\n    model.anchor_end_lb = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 + (n - 2) * m.x[i, 1] if i != 1 else pyo.Constraint.Skip)\n\n    return model\n",
                        "added_cut": "# Global Permutation-Sum & Exact Anchor Cuts\n# This offspring introduces global structural knowledge of the position variables 'u'.\n# Unlike parents that focus on relative differences (arc-based lifting), this formulation \n# constrains the absolute sum of positions and strictly anchors the start/end nodes of the tour.\n\n# 1. Global Position Sum:\n# In any valid tour, the variables u[2]...u[n] must form a permutation of 2...n.\n# Their sum is fixed at (n*(n+1)/2) - 1. This constraint invalidates relaxed solutions\n# where u-values are artificially compressed towards lower bounds to satisfy difference constraints.\ndef global_pos_sum_rule(model):\n    target_sum = (n * (n + 1)) / 2 - 1\n    return sum(model.u[i] for i in model.N if i != 1) == target_sum\nmodel.global_pos_sum = pyo.Constraint(rule=global_pos_sum_rule)\n\n# 2. Exact Start Anchor:\n# If node i is visited immediately after the depot (x[1,i]=1), then u[i] must be exactly 2.\n# Parent 1 only enforces u[i] >= 2 in this case; this cut enforces the upper bound u[i] <= 2.\n# Formula: u[i] <= n - (n-2)*x[1,i]. \n# Check: If x[1,i]=1 -> u[i]<=2. If x[1,i]=0 -> u[i]<=n.\nmodel.anchor_start_ub = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n - (n - 2) * m.x[1, i] if i != 1 else pyo.Constraint.Skip)\n\n# 3. Exact End Anchor:\n# If node i visits the depot (x[i,1]=1), then u[i] must be exactly n.\n# Parent 1 only enforces u[i] <= n in this case; this cut enforces the lower bound u[i] >= n.\n# Formula: u[i] >= 2 + (n-2)*x[i,1].\n# Check: If x[i,1]=1 -> u[i]>=n. If x[i,1]=0 -> u[i]>=2.\nmodel.anchor_end_lb = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 + (n - 2) * m.x[i, 1] if i != 1 else pyo.Constraint.Skip)",
                        "idea": "We propose **Global Permutation-Sum & Exact Anchor Cuts**. While the parents improve the LP relaxation by tightening *relative* differences ($u_i - u_j$) via arc-lifting, this offspring constrains the *absolute* distribution of potentials. First, we enforce the **Global Position Sum** ($\\sum u_i = n(n+1)/2 - 1$), which eliminates fractional solutions where $u$ values are artificially compressed (a common weakness in MTZ relaxations). Second, we introduce **Exact Anchors** that force $u_i=2$ or $u_i=n$ for nodes connected to the depot. This perfectly complements Parent 1, which tightened bounds for *inactive* nodes ($u_i \\in [3, n-1]$) but left active nodes loose; this formulation locks the active nodes to the boundaries."
                    },
                    "fitness": 1.7248478542462473,
                    "solver_reports": [
                        {
                            "gap": 19.4173,
                            "total_time": 11.01,
                            "explored_nodes": 2309,
                            "simplex_iterations": 48401,
                            "explored_time": 11.0,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.2985,
                            "total_time": 13.08,
                            "explored_nodes": 1,
                            "simplex_iterations": 10084,
                            "explored_time": 13.02,
                            "work_units": 10.0
                        },
                        {
                            "gap": 23.8834,
                            "total_time": 11.23,
                            "explored_nodes": 1007,
                            "simplex_iterations": 29796,
                            "explored_time": 11.21,
                            "work_units": 10.33
                        },
                        {
                            "total_time": 14.61,
                            "explored_nodes": 1,
                            "simplex_iterations": 5392,
                            "explored_time": 14.56,
                            "work_units": 10.0
                        },
                        {
                            "gap": 5.3314,
                            "total_time": 12.26,
                            "explored_nodes": 3374,
                            "simplex_iterations": 50766,
                            "explored_time": 12.24,
                            "work_units": 10.0
                        },
                        {
                            "gap": 30.104,
                            "total_time": 12.77,
                            "explored_nodes": 1,
                            "simplex_iterations": 4700,
                            "explored_time": 12.72,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 7.49,
                            "postsolve": 0.01,
                            "explored_nodes": 101704,
                            "simplex_iterations": 919476,
                            "explored_time": 7.48,
                            "work_units": 5.62
                        },
                        {
                            "gap": 9.1284,
                            "total_time": 9.09,
                            "explored_nodes": 5214,
                            "simplex_iterations": 63898,
                            "explored_time": 9.08,
                            "work_units": 10.02
                        },
                        {
                            "gap": 46.2333,
                            "total_time": 12.5,
                            "explored_nodes": 143,
                            "simplex_iterations": 12674,
                            "explored_time": 12.48,
                            "work_units": 10.84
                        },
                        {
                            "gap": 31.5241,
                            "total_time": 11.21,
                            "explored_nodes": 31,
                            "simplex_iterations": 9209,
                            "explored_time": 11.18,
                            "work_units": 10.03
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "0b446721-1401-4f67-aff8-77e2d1e0c6a0",
                        "1be239de-c7de-4824-9891-f4ef84f0c6bf"
                    ]
                },
                {
                    "id": "1103b2ce-4374-44f8-8f93-24b6706b6264",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 3-Cycle Subtour Elimination Constraints\n    # This offspring extends the logic of Parent 1 (which removes 2-cycles) to 3-cycles,\n    # addressing a specific weakness where MTZ and Parent 2's DL cuts allow fractional triangular subtours.\n    \n    def sec3_generator(model):\n        model.sec3_constraints = pyo.ConstraintList()\n        import itertools\n        # MTZ formulation implicitly prevents subtours containing the depot (node 1).\n        # We explicitly eliminate subtours of size 3 among non-depot nodes.\n        non_depot_nodes = [i for i in model.N if i != 1]\n        \n        for i, j, k in itertools.combinations(non_depot_nodes, 3):\n            # For every triplet, forbid the two possible directed cycles\n            # Cycle 1: i -> j -> k -> i\n            model.sec3_constraints.add(model.x[i, j] + model.x[j, k] + model.x[k, i] <= 2)\n            # Cycle 2: i -> k -> j -> i\n            model.sec3_constraints.add(model.x[i, k] + model.x[k, j] + model.x[j, i] <= 2)\n    \n    model.build_sec3 = pyo.BuildAction(rule=sec3_generator)\n\n    return model\n",
                        "added_cut": "# Explicit 3-Cycle Subtour Elimination Constraints\n# This offspring extends the logic of Parent 1 (which removes 2-cycles) to 3-cycles,\n# addressing a specific weakness where MTZ and Parent 2's DL cuts allow fractional triangular subtours.\n\ndef sec3_generator(model):\n    model.sec3_constraints = pyo.ConstraintList()\n    import itertools\n    # MTZ formulation implicitly prevents subtours containing the depot (node 1).\n    # We explicitly eliminate subtours of size 3 among non-depot nodes.\n    non_depot_nodes = [i for i in model.N if i != 1]\n    \n    for i, j, k in itertools.combinations(non_depot_nodes, 3):\n        # For every triplet, forbid the two possible directed cycles\n        # Cycle 1: i -> j -> k -> i\n        model.sec3_constraints.add(model.x[i, j] + model.x[j, k] + model.x[k, i] <= 2)\n        # Cycle 2: i -> k -> j -> i\n        model.sec3_constraints.add(model.x[i, k] + model.x[k, j] + model.x[j, i] <= 2)\n\nmodel.build_sec3 = pyo.BuildAction(rule=sec3_generator)",
                        "idea": "We introduce **Explicit 3-Cycle Elimination Constraints** to target the next tier of subtour structures. While Parent 1 efficiently removes 2-cycles and Parent 2 tightens the continuous $u$-variable bounds (via DL cuts), neither strictly prevents fractional 3-cycle subtours (e.g., $x_{ij}=x_{jk}=x_{ki}=2/3$) which often satisfy MTZ constraints for $n \\ge 4$. By explicitly forbidding these triangular loops among non-depot nodes, this cut complements the arc-based logic of Parent 1 and the potential-based logic of Parent 2, significantly tightening the linear relaxation against small, fractional subtours."
                    },
                    "fitness": 0.2819930762950805,
                    "solver_reports": [
                        {
                            "gap": 38.7924,
                            "total_time": 15.14,
                            "explored_nodes": 1,
                            "simplex_iterations": 1306,
                            "explored_time": 14.96,
                            "work_units": 10.03
                        },
                        {
                            "total_time": 8.61,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 7.95,
                            "work_units": 10.01
                        },
                        {
                            "gap": 44.0798,
                            "total_time": 15.75,
                            "explored_nodes": 1,
                            "simplex_iterations": 1500,
                            "explored_time": 15.59,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 11.87,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 10.73,
                            "work_units": 10.01
                        },
                        {
                            "gap": 7.0504,
                            "total_time": 14.25,
                            "explored_nodes": 1,
                            "simplex_iterations": 2371,
                            "explored_time": 14.17,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 10.91,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 10.21,
                            "work_units": 10.15
                        },
                        {
                            "gap": 0.0,
                            "total_time": 7.74,
                            "postsolve": 0.01,
                            "explored_nodes": 105293,
                            "simplex_iterations": 685561,
                            "explored_time": 7.73,
                            "work_units": 5.7
                        },
                        {
                            "gap": 6.8442,
                            "total_time": 15.27,
                            "explored_nodes": 1,
                            "simplex_iterations": 1258,
                            "explored_time": 15.0,
                            "work_units": 10.03
                        },
                        {
                            "gap": 100.0,
                            "total_time": 14.1,
                            "explored_nodes": 1,
                            "simplex_iterations": 0,
                            "explored_time": 13.67,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.3,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 12.67,
                            "work_units": 10.04
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "0b446721-1401-4f67-aff8-77e2d1e0c6a0"
                    ]
                },
                {
                    "id": "31bf341f-f61d-456f-804f-fef98ecc609c",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Dynamic Node Potential Bounds\n    # These constraints strictly tighten the bounds of u[i] for all non-depot nodes based on their connectivity to the depot.\n    # They enforce that 'internal' nodes (not directly connected to the depot) must have u[i] in [3, n-1].\n    \n    def dynamic_u_lb_rule(model, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        n = len(model.N)\n        # Lower Bound Logic: u[i] >= 3 - x[1,i] + (n-3)*x[i,1]\n        # If x[1,i]=1 (first node), u[i] >= 2.\n        # If x[i,1]=1 (last node), u[i] >= n.\n        # If neither (internal), u[i] >= 3.\n        return model.u[i] + model.x[1, i] - (n - 3) * model.x[i, 1] >= 3\n    \n    model.dynamic_u_lb = pyo.Constraint(model.N, rule=dynamic_u_lb_rule)\n    \n    def dynamic_u_ub_rule(model, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        n = len(model.N)\n        # Upper Bound Logic: u[i] <= n - 1 + x[i,1] - (n-3)*x[1,i]\n        # If x[1,i]=1 (first node), u[i] <= 2.\n        # If x[i,1]=1 (last node), u[i] <= n.\n        # If neither (internal), u[i] <= n - 1.\n        return model.u[i] + (n - 3) * model.x[1, i] - model.x[i, 1] <= n - 1\n    \n    model.dynamic_u_ub = pyo.Constraint(model.N, rule=dynamic_u_ub_rule)\n\n    return model\n",
                        "added_cut": "# Dynamic Node Potential Bounds\n# These constraints strictly tighten the bounds of u[i] for all non-depot nodes based on their connectivity to the depot.\n# They enforce that 'internal' nodes (not directly connected to the depot) must have u[i] in [3, n-1].\n\ndef dynamic_u_lb_rule(model, i):\n    if i == 1:\n        return pyo.Constraint.Skip\n    n = len(model.N)\n    # Lower Bound Logic: u[i] >= 3 - x[1,i] + (n-3)*x[i,1]\n    # If x[1,i]=1 (first node), u[i] >= 2.\n    # If x[i,1]=1 (last node), u[i] >= n.\n    # If neither (internal), u[i] >= 3.\n    return model.u[i] + model.x[1, i] - (n - 3) * model.x[i, 1] >= 3\n\nmodel.dynamic_u_lb = pyo.Constraint(model.N, rule=dynamic_u_lb_rule)\n\ndef dynamic_u_ub_rule(model, i):\n    if i == 1:\n        return pyo.Constraint.Skip\n    n = len(model.N)\n    # Upper Bound Logic: u[i] <= n - 1 + x[i,1] - (n-3)*x[1,i]\n    # If x[1,i]=1 (first node), u[i] <= 2.\n    # If x[i,1]=1 (last node), u[i] <= n.\n    # If neither (internal), u[i] <= n - 1.\n    return model.u[i] + (n - 3) * model.x[1, i] - model.x[i, 1] <= n - 1\n\nmodel.dynamic_u_ub = pyo.Constraint(model.N, rule=dynamic_u_ub_rule)",
                        "idea": "The offspring introduces **Dynamic Node Potential Bounds**, a constraint set that tightens the continuous relaxation of the position variables $u_i$ by dynamically adjusting their bounds based on depot connectivity. While Parent 1 focuses on binary cycle elimination and Parent 2 lifts arc differences ($u_i - u_j$), this cut operates on the **absolute domains** of $u_i$. It strictly dominates the boundary-fixing logic of Parent 2 by enforcing that any node *not* immediately connected to the depot must lie in the narrower range $[3, n-1]$. This eliminates fractional solutions where internal nodes float near the trivial bounds (2 or $n$) without active depot arcs, significantly squeezing the polytope."
                    },
                    "fitness": 1.7028451877265267,
                    "solver_reports": [
                        {
                            "gap": 7.9012,
                            "total_time": 12.2,
                            "explored_nodes": 3520,
                            "simplex_iterations": 60486,
                            "explored_time": 12.17,
                            "work_units": 10.0
                        },
                        {
                            "gap": 55.9895,
                            "total_time": 11.3,
                            "explored_nodes": 1,
                            "simplex_iterations": 6973,
                            "explored_time": 11.25,
                            "work_units": 10.0
                        },
                        {
                            "gap": 22.0816,
                            "total_time": 11.04,
                            "explored_nodes": 1994,
                            "simplex_iterations": 37402,
                            "explored_time": 11.02,
                            "work_units": 10.04
                        },
                        {
                            "gap": 91.9378,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 3945,
                            "explored_time": 13.91,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.9062,
                            "total_time": 13.69,
                            "explored_nodes": 8804,
                            "simplex_iterations": 92126,
                            "explored_time": 13.67,
                            "work_units": 10.0
                        },
                        {
                            "gap": 37.375,
                            "total_time": 12.52,
                            "explored_nodes": 59,
                            "simplex_iterations": 5763,
                            "explored_time": 12.49,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.8481,
                            "total_time": 14.29,
                            "explored_nodes": 168310,
                            "simplex_iterations": 1101069,
                            "explored_time": 14.29,
                            "work_units": 10.05
                        },
                        {
                            "gap": 8.9884,
                            "total_time": 11.58,
                            "explored_nodes": 4131,
                            "simplex_iterations": 60158,
                            "explored_time": 11.55,
                            "work_units": 10.0
                        },
                        {
                            "gap": 42.3823,
                            "total_time": 13.16,
                            "explored_nodes": 171,
                            "simplex_iterations": 8366,
                            "explored_time": 13.13,
                            "work_units": 12.11
                        },
                        {
                            "gap": 32.2994,
                            "total_time": 13.59,
                            "explored_nodes": 14,
                            "simplex_iterations": 5778,
                            "explored_time": 13.53,
                            "work_units": 10.07
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "4351a2f7-68f5-48e9-850c-c1be6beacb5a"
                    ]
                },
                {
                    "id": "c335578b-b680-479b-94a5-df0e3b9f0898",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def lifted_mtz_rule(model, i, j):\n        # Apply only to intermediate nodes (excluding depot node 1)\n        if i != 1 and j != 1 and i != j:\n            n = len(model.N)\n            # Desrochers & Laporte (1991) Lifted MTZ Constraint\n            # This tightens the standard MTZ constraint by:\n            # 1. Reducing the Big-M coefficient from n to (n-1).\n            # 2. Including the reverse arc term (n-3)*x[j,i] to penalize 2-cycles.\n            # Formula: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n - 2\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    \n    model.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "def lifted_mtz_rule(model, i, j):\n    # Apply only to intermediate nodes (excluding depot node 1)\n    if i != 1 and j != 1 and i != j:\n        n = len(model.N)\n        # Desrochers & Laporte (1991) Lifted MTZ Constraint\n        # This tightens the standard MTZ constraint by:\n        # 1. Reducing the Big-M coefficient from n to (n-1).\n        # 2. Including the reverse arc term (n-3)*x[j,i] to penalize 2-cycles.\n        # Formula: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n - 2\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\n\nmodel.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "We implement the Desrochers & Laporte (1991) Lifted MTZ constraint. This acts as a hybrid offspring by merging the logic of Parent 1 (tightening potential variables $u$) with Parent 2 (penalizing 2-cycles involving $x_{i,j}$ and $x_{j,i}$). Unlike the standard MTZ, which treats arcs independently with a loose Big-M, this cut couples the forward and reverse arcs directly into the potential difference constraint. It strictly tightens the relaxation by reducing the Big-M coefficient to $n-1$ and forcing the potential difference to account for reverse flow, effectively cutting fractional subtours that both parents might miss individually."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 11.93,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 11.91,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.32,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 13.24,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 12.61,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 12.58,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.75,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.66,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 11.27,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 11.25,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 12.24,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 12.17,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 14.65,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 14.65,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 10.76,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 10.74,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 11.76,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 11.72,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 13.03,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 12.97,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "e2108170-8861-4776-9b67-fe9a8d46a4f7",
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "ad50ce03-fd55-4dde-8f92-4872dc58549f",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def hybrid_depot_sec_rule(model, i, j):\n        # Skip self-loops\n        if i == j:\n            return pyo.Constraint.Skip\n    \n        n = len(model.N)\n    \n        # 1. Depot-Tightening Logic (Inherited from Parent 1)\n        # These constraints strictly tighten the Big-M bounds for arcs connected to the depot (node 1).\n        # They eliminate fractional 'floating' values by forcing u[j]=2 immediately after the depot\n        # and u[i]=n immediately before the depot, which standard MTZ does not guarantee in relaxation.\n        if i == 1:\n            # For arc 1->j: Force u[j] <= 2 if x[1,j]=1. Since u[j]>=2, this fixes u[j]=2.\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n        elif j == 1:\n            # For arc i->1: Force u[i] >= n if x[i,1]=1. Since u[i]<=n, this fixes u[i]=n.\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n    \n        # 2. Explicit 2-Cycle Elimination (Inherited from Parent 2)\n        # For internal nodes (not connected to depot in this specific pair check), we apply the \n        # highly effective SEC2 cut from Parent 2. This replaces Parent 1's heavy internal lifting \n        # with a leaner, higher-fitness constraint that directly prunes fractional 2-cycles.\n        elif i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n    \n        return pyo.Constraint.Skip\n    \n    model.hybrid_depot_sec = pyo.Constraint(model.N, model.N, rule=hybrid_depot_sec_rule)\n\n    return model\n",
                        "added_cut": "def hybrid_depot_sec_rule(model, i, j):\n    # Skip self-loops\n    if i == j:\n        return pyo.Constraint.Skip\n\n    n = len(model.N)\n\n    # 1. Depot-Tightening Logic (Inherited from Parent 1)\n    # These constraints strictly tighten the Big-M bounds for arcs connected to the depot (node 1).\n    # They eliminate fractional 'floating' values by forcing u[j]=2 immediately after the depot\n    # and u[i]=n immediately before the depot, which standard MTZ does not guarantee in relaxation.\n    if i == 1:\n        # For arc 1->j: Force u[j] <= 2 if x[1,j]=1. Since u[j]>=2, this fixes u[j]=2.\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n    elif j == 1:\n        # For arc i->1: Force u[i] >= n if x[i,1]=1. Since u[i]<=n, this fixes u[i]=n.\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n\n    # 2. Explicit 2-Cycle Elimination (Inherited from Parent 2)\n    # For internal nodes (not connected to depot in this specific pair check), we apply the \n    # highly effective SEC2 cut from Parent 2. This replaces Parent 1's heavy internal lifting \n    # with a leaner, higher-fitness constraint that directly prunes fractional 2-cycles.\n    elif i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n\n    return pyo.Constraint.Skip\n\nmodel.hybrid_depot_sec = pyo.Constraint(model.N, model.N, rule=hybrid_depot_sec_rule)",
                        "idea": "This hybrid constraint minimizes joint violation by fusing the high-impact explicit 2-cycle cuts from Parent 2 with the precise boundary tightening of Parent 1. By applying the explicit subtour elimination ($x_{i,j} + x_{j,i} \\le 1$) to internal nodes, it inherits the superior fitness and relaxation tightening of Parent 2. Simultaneously, it selectively applies Parent 1's tightening logic only to depot-connected arcs ($1 \\to j$ and $i \\to 1$), fixing the continuous variables $u$ to their exact integer values ($2$ and $n$) at the tour's endpoints. This avoids the computational overhead of Parent 1's internal lifting while retaining its unique strength in anchoring the tour."
                    },
                    "fitness": 8.714545839683938,
                    "solver_reports": [
                        {
                            "gap": 10.4833,
                            "total_time": 12.03,
                            "explored_nodes": 1938,
                            "simplex_iterations": 30784,
                            "explored_time": 12.02,
                            "work_units": 10.03
                        },
                        {
                            "gap": 12.6546,
                            "total_time": 13.4,
                            "explored_nodes": 1,
                            "simplex_iterations": 4042,
                            "explored_time": 13.35,
                            "work_units": 10.0
                        },
                        {
                            "gap": 8.4709,
                            "total_time": 13.0,
                            "explored_nodes": 1586,
                            "simplex_iterations": 31927,
                            "explored_time": 12.99,
                            "work_units": 10.05
                        },
                        {
                            "gap": 32.0687,
                            "total_time": 15.02,
                            "explored_nodes": 1,
                            "simplex_iterations": 2643,
                            "explored_time": 14.95,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.7346,
                            "total_time": 13.7,
                            "explored_nodes": 3338,
                            "simplex_iterations": 56342,
                            "explored_time": 13.67,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.827,
                            "total_time": 15.62,
                            "explored_nodes": 1,
                            "simplex_iterations": 12852,
                            "explored_time": 15.56,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.0781,
                            "total_time": 12.01,
                            "explored_nodes": 283947,
                            "simplex_iterations": 1897855,
                            "explored_time": 12.0,
                            "work_units": 10.01
                        },
                        {
                            "gap": 2.9734,
                            "total_time": 12.87,
                            "explored_nodes": 1017,
                            "simplex_iterations": 39527,
                            "explored_time": 12.86,
                            "work_units": 10.02
                        },
                        {
                            "gap": 9.478,
                            "total_time": 13.26,
                            "explored_nodes": 59,
                            "simplex_iterations": 7180,
                            "explored_time": 13.21,
                            "work_units": 12.25
                        },
                        {
                            "gap": 15.4547,
                            "total_time": 14.21,
                            "explored_nodes": 1,
                            "simplex_iterations": 3094,
                            "explored_time": 14.16,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Min_Violation",
                    "parents_id": [
                        "4351a2f7-68f5-48e9-850c-c1be6beacb5a",
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                }
            ],
            10.353038952236112
        ],
        [
            [
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "f07c2a9e-e511-48d8-a27e-f006ee9cbff6",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Desrochers & Laporte Lifted MTZ Constraints\n    # This constraint combines the explicit cycle-breaking of Parent 1 with the variable tightening of Parent 2.\n    # By introducing the reverse-arc term (n-3)*x[j,i] and tightening the RHS to (n-2), we strictly lift the MTZ formulation.\n    # This makes fractional 2-cycles infeasible (satisfying Parent 1) and enforces the exact geometric bounds on 'u' (satisfying Parent 2).\n    def lifted_mtz_rule(model, i, j):\n        # Apply only to pairs of non-depot nodes\n        if i != 1 and j != 1 and i != j:\n            # Standard MTZ: u[i] - u[j] + n*x[i,j] <= n-1\n            # Lifted MTZ:   u[i] - u[j] + (n-1)*x[i,j] + (n-3)*x[j,i] <= n-2\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    model.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Desrochers & Laporte Lifted MTZ Constraints\n# This constraint combines the explicit cycle-breaking of Parent 1 with the variable tightening of Parent 2.\n# By introducing the reverse-arc term (n-3)*x[j,i] and tightening the RHS to (n-2), we strictly lift the MTZ formulation.\n# This makes fractional 2-cycles infeasible (satisfying Parent 1) and enforces the exact geometric bounds on 'u' (satisfying Parent 2).\ndef lifted_mtz_rule(model, i, j):\n    # Apply only to pairs of non-depot nodes\n    if i != 1 and j != 1 and i != j:\n        # Standard MTZ: u[i] - u[j] + n*x[i,j] <= n-1\n        # Lifted MTZ:   u[i] - u[j] + (n-1)*x[i,j] + (n-3)*x[j,i] <= n-2\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\nmodel.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "The offspring implements the Desrochers & Laporte lifting for MTZ constraints. It synergizes the parents by: 1) Explicitly penalizing the reverse arc $x_{j,i}$ with coefficient $(n-3)$, which mathematically forbids the fractional 2-cycles targeted by Parent 1 (since $x_{i,j}=x_{j,i}=1$ becomes infeasible); and 2) Tightening the constraint slack from $n-1$ to $n-2$ (the exact geometric limit of $u_i - u_j$), fulfilling Parent 2's objective of enforcing strict bounds on the potential variables."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 11.92,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 11.9,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.84,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 13.76,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 12.64,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 12.61,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.85,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.73,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 13.01,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 12.99,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 12.68,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 12.61,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 13.9,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 13.89,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 10.35,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 10.34,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 11.64,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 11.61,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 13.17,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 13.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Min_Violation",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "a5b5e126-005b-48ea-8d3f-65cad8f7b2ac"
                    ]
                },
                {
                    "id": "60f6c81e-a4e7-46f1-b577-704edd0d5b89",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Hybrid Strong Cuts: Depot-Locked Bounds + DL Lifting + Position Sum\n    \n    # 1. Depot-Locked Positional Bounds (From Parent 2)\n    # Strengthens the relaxation by enforcing strict values (2 or n) for nodes connected to the depot\n    # and tightening the range to [3, n-1] for intermediate nodes.\n    # Lower Bound: u[i] >= 3 - x[1,i] + (n-3)x[i,1]\n    model.depot_locked_lb = pyo.Constraint(model.N, rule=lambda m, i: \n        m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1] if i != 1 else pyo.Constraint.Skip)\n    \n    # Upper Bound: u[i] <= n - 1 + x[i,1] - (n-3)x[1,i]\n    model.depot_locked_ub = pyo.Constraint(model.N, rule=lambda m, i: \n        m.u[i] <= n - 1 + m.x[i, 1] - (n - 3) * m.x[1, i] if i != 1 else pyo.Constraint.Skip)\n    \n    # 2. Desrochers-Laporte (DL) Lifted Cuts (From Parent 2)\n    # Stronger subtour elimination using reverse arc lifting.\n    # u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\n    def dl_cuts_rule(m, i, j):\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    model.dl_cuts = pyo.Constraint(model.N, model.N, rule=dl_cuts_rule)\n    \n    # 3. Global Position-Sum Equality (New Component)\n    # Minimizes joint violation by enforcing the exact sum of position variables.\n    # Since u defines a permutation of 1..n, sum(u) must equal n(n+1)/2.\n    # This cuts off fractional solutions where u values are collectively depressed.\n    model.position_sum = pyo.Constraint(expr=sum(model.u[i] for i in model.N if i != 1) == (n * (n + 1) // 2) - 1)\n\n    return model\n",
                        "added_cut": "# Hybrid Strong Cuts: Depot-Locked Bounds + DL Lifting + Position Sum\n\n# 1. Depot-Locked Positional Bounds (From Parent 2)\n# Strengthens the relaxation by enforcing strict values (2 or n) for nodes connected to the depot\n# and tightening the range to [3, n-1] for intermediate nodes.\n# Lower Bound: u[i] >= 3 - x[1,i] + (n-3)x[i,1]\nmodel.depot_locked_lb = pyo.Constraint(model.N, rule=lambda m, i: \n    m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1] if i != 1 else pyo.Constraint.Skip)\n\n# Upper Bound: u[i] <= n - 1 + x[i,1] - (n-3)x[1,i]\nmodel.depot_locked_ub = pyo.Constraint(model.N, rule=lambda m, i: \n    m.u[i] <= n - 1 + m.x[i, 1] - (n - 3) * m.x[1, i] if i != 1 else pyo.Constraint.Skip)\n\n# 2. Desrochers-Laporte (DL) Lifted Cuts (From Parent 2)\n# Stronger subtour elimination using reverse arc lifting.\n# u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\ndef dl_cuts_rule(m, i, j):\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\nmodel.dl_cuts = pyo.Constraint(model.N, model.N, rule=dl_cuts_rule)\n\n# 3. Global Position-Sum Equality (New Component)\n# Minimizes joint violation by enforcing the exact sum of position variables.\n# Since u defines a permutation of 1..n, sum(u) must equal n(n+1)/2.\n# This cuts off fractional solutions where u values are collectively depressed.\nmodel.position_sum = pyo.Constraint(expr=sum(model.u[i] for i in model.N if i != 1) == (n * (n + 1) // 2) - 1)",
                        "idea": "We construct a hybrid formulation that minimizes joint violation by integrating the strongest components of both parents: the **Depot-Locked Bounds** and **Desrochers-Laporte (DL) Cuts** (Parent 2). These constraints tightly bound individual $u_i$ values and relative differences. To further tighten the feasible region and prevent the accumulation of relaxation error, we introduce a **Global Position-Sum Constraint**. This equality forces the sum of position variables to strictly equal $\\frac{n(n+1)}{2} - 1$, effectively acting as a global cut that eliminates fractional solutions where position variables are artificially low to satisfy difference constraints."
                    },
                    "fitness": 1.5667454889751604,
                    "solver_reports": [
                        {
                            "gap": 18.459,
                            "total_time": 11.79,
                            "explored_nodes": 115,
                            "simplex_iterations": 4963,
                            "explored_time": 11.77,
                            "work_units": 10.28
                        },
                        {
                            "total_time": 12.1,
                            "explored_nodes": 1,
                            "simplex_iterations": 2658,
                            "explored_time": 11.99,
                            "work_units": 10.03
                        },
                        {
                            "gap": 15.9876,
                            "total_time": 11.78,
                            "explored_nodes": 87,
                            "simplex_iterations": 4349,
                            "explored_time": 11.77,
                            "work_units": 10.01
                        },
                        {
                            "gap": 68.9826,
                            "total_time": 13.25,
                            "explored_nodes": 1,
                            "simplex_iterations": 857,
                            "explored_time": 13.16,
                            "work_units": 10.0
                        },
                        {
                            "gap": 5.3333,
                            "total_time": 10.68,
                            "explored_nodes": 2821,
                            "simplex_iterations": 69624,
                            "explored_time": 10.66,
                            "work_units": 10.0
                        },
                        {
                            "gap": 92.2137,
                            "total_time": 11.34,
                            "explored_nodes": 1,
                            "simplex_iterations": 2250,
                            "explored_time": 11.27,
                            "work_units": 10.01
                        },
                        {
                            "gap": 0.0,
                            "total_time": 5.84,
                            "postsolve": 0.01,
                            "explored_nodes": 124029,
                            "simplex_iterations": 789974,
                            "explored_time": 5.84,
                            "work_units": 3.72
                        },
                        {
                            "gap": 6.2944,
                            "total_time": 13.1,
                            "explored_nodes": 1,
                            "simplex_iterations": 3928,
                            "explored_time": 13.04,
                            "work_units": 10.0
                        },
                        {
                            "gap": 45.1186,
                            "total_time": 11.8,
                            "explored_nodes": 1,
                            "simplex_iterations": 1744,
                            "explored_time": 11.73,
                            "work_units": 10.0
                        },
                        {
                            "gap": 34.9888,
                            "total_time": 13.22,
                            "explored_nodes": 1,
                            "simplex_iterations": 1636,
                            "explored_time": 13.16,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Min_Violation",
                    "parents_id": [
                        "913a02db-5ac8-4b6d-bc79-038fe25b976c",
                        "02dbc955-1fc7-47d0-a42a-7bf0f22756b4"
                    ]
                },
                {
                    "id": "f56d4438-9294-4a9f-93d6-eaed89618f4f",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def lifted_mtz_depot_rule(model, i, j):\n        # Skip self-loops\n        if i == j:\n            return pyo.Constraint.Skip\n        \n        n = len(model.N)\n        \n        # 1. Depot-Tightening (Inherited from Parent 2)\n        # These branches strictly anchor the potentials u at the start and end of the tour.\n        # If arc 1->j is used, u[j] must be the second node (value 2).\n        if i == 1:\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n        \n        # If arc i->1 is used, u[i] must be the last node (value n).\n        if j == 1:\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n            \n        # 2. Lifted MTZ for Internal Nodes (Generalizing Parent 1)\n        # This implements the Desrochers & Laporte lifted constraint: \n        # u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} <= n-2.\n        # It subsumes the 2-cycle cut (Parent 1) by coupling the potentials u with both \n        # forward and reverse arcs, strictly tightening the relaxation compared to standard MTZ.\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n    model.lifted_mtz_depot = pyo.Constraint(model.N, model.N, rule=lifted_mtz_depot_rule)\n\n    return model\n",
                        "added_cut": "def lifted_mtz_depot_rule(model, i, j):\n    # Skip self-loops\n    if i == j:\n        return pyo.Constraint.Skip\n    \n    n = len(model.N)\n    \n    # 1. Depot-Tightening (Inherited from Parent 2)\n    # These branches strictly anchor the potentials u at the start and end of the tour.\n    # If arc 1->j is used, u[j] must be the second node (value 2).\n    if i == 1:\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n    \n    # If arc i->1 is used, u[i] must be the last node (value n).\n    if j == 1:\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n        \n    # 2. Lifted MTZ for Internal Nodes (Generalizing Parent 1)\n    # This implements the Desrochers & Laporte lifted constraint: \n    # u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} <= n-2.\n    # It subsumes the 2-cycle cut (Parent 1) by coupling the potentials u with both \n    # forward and reverse arcs, strictly tightening the relaxation compared to standard MTZ.\n    return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\nmodel.lifted_mtz_depot = pyo.Constraint(model.N, model.N, rule=lifted_mtz_depot_rule)",
                        "idea": "This constraint fuses the robust endpoint fixing from Parent 2 with a generalized 'Lifted MTZ' formulation that supersedes Parent 1. By fixing $u_j=2$ and $u_i=n$ for depot connections, it eliminates loose bounds at the tour's fringe. For internal nodes, it replaces the separate 2-cycle cuts with the Desrochers & Laporte lifting ($u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} \\le n-2$), which implicitly forbids 2-cycles ($x_{ij}+x_{ji} \\le 1$) while simultaneously tightening the linear relaxation of the subtour constraints significantly beyond the standard formulation."
                    },
                    "fitness": 7.334430269612348,
                    "solver_reports": [
                        {
                            "gap": 12.5439,
                            "total_time": 12.46,
                            "explored_nodes": 231,
                            "simplex_iterations": 6578,
                            "explored_time": 12.43,
                            "work_units": 10.55
                        },
                        {
                            "total_time": 16.17,
                            "explored_nodes": 1,
                            "simplex_iterations": 1826,
                            "explored_time": 16.08,
                            "work_units": 10.01
                        },
                        {
                            "gap": 12.2086,
                            "total_time": 12.25,
                            "explored_nodes": 445,
                            "simplex_iterations": 17365,
                            "explored_time": 12.22,
                            "work_units": 10.08
                        },
                        {
                            "total_time": 12.88,
                            "explored_nodes": 1,
                            "simplex_iterations": 1596,
                            "explored_time": 12.76,
                            "work_units": 10.01
                        },
                        {
                            "gap": 6.5217,
                            "total_time": 11.65,
                            "explored_nodes": 5231,
                            "simplex_iterations": 63695,
                            "explored_time": 11.62,
                            "work_units": 10.0
                        },
                        {
                            "gap": 51.1297,
                            "total_time": 12.21,
                            "explored_nodes": 1,
                            "simplex_iterations": 1599,
                            "explored_time": 12.14,
                            "work_units": 10.01
                        },
                        {
                            "gap": 0.0,
                            "total_time": 2.68,
                            "postsolve": 0.0,
                            "explored_nodes": 59829,
                            "simplex_iterations": 349234,
                            "explored_time": 2.68,
                            "work_units": 1.6
                        },
                        {
                            "gap": 3.5139,
                            "total_time": 12.95,
                            "explored_nodes": 2813,
                            "simplex_iterations": 49802,
                            "explored_time": 12.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.5644,
                            "total_time": 11.99,
                            "explored_nodes": 1,
                            "simplex_iterations": 1310,
                            "explored_time": 11.95,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 12.68,
                            "explored_nodes": 1,
                            "simplex_iterations": 1865,
                            "explored_time": 12.63,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Min_Violation",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "ad50ce03-fd55-4dde-8f92-4872dc58549f"
                    ]
                },
                {
                    "id": "380454ef-453d-4b81-b1a6-d0d77d48ccab",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Hybrid Formulation: Rank-Sum Enhanced DL-MTZ\n    # Combines structural Desrochers-Laporte lifting with Tightened Depot Bounds and a novel Global Rank-Sum cut.\n    \n    # 1. Global Rank-Sum Equality (New)\n    # Since u[i] for i in {2..n} must be a permutation of {2..n}, their sum is invariant.\n    # This equality cuts off fractional relaxations where u variables 'bunch' or drift to minimize local violations,\n    # significantly tightening the feasible region towards the convex hull.\n    # Sum = n(n+1)/2 - 1 (since u[1]=1 is excluded).\n    model.rank_sum_eq = pyo.Constraint(expr=sum(model.u[i] for i in model.N if i != 1) == (n * (n + 1)) // 2 - 1)\n    \n    # 2. Tightened Depot-Position Bounds (From Parent 2)\n    # Strictly dominates standard MTZ bounds by forcing exact values when connected to the depot.\n    # Logic: If x[1,i]=1 => u[i]>=2. If x[i,1]=1 => u[i]>=n. Else => u[i]>=3.\n    model.tight_lb = pyo.Constraint(model.N, rule=lambda m, i: \n        m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1] if i != 1 else pyo.Constraint.Skip)\n    \n    # Logic: If x[1,i]=1 => u[i]<=2. If x[i,1]=1 => u[i]<=n. Else => u[i]<=n-1.\n    model.tight_ub = pyo.Constraint(model.N, rule=lambda m, i: \n        m.u[i] <= n - 1 + m.x[i, 1] - (n - 3) * m.x[1, i] if i != 1 else pyo.Constraint.Skip)\n    \n    # 3. Desrochers-Laporte (DL) Lifted Cuts (From Parent 1 & 2)\n    # Strengthens the subtour elimination logic by incorporating the reverse arc x[j,i].\n    # Formula: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\n    def dl_cuts_rule(m, i, j):\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    model.dl_cuts = pyo.Constraint(model.N, model.N, rule=dl_cuts_rule)\n\n    return model\n",
                        "added_cut": "# Hybrid Formulation: Rank-Sum Enhanced DL-MTZ\n# Combines structural Desrochers-Laporte lifting with Tightened Depot Bounds and a novel Global Rank-Sum cut.\n\n# 1. Global Rank-Sum Equality (New)\n# Since u[i] for i in {2..n} must be a permutation of {2..n}, their sum is invariant.\n# This equality cuts off fractional relaxations where u variables 'bunch' or drift to minimize local violations,\n# significantly tightening the feasible region towards the convex hull.\n# Sum = n(n+1)/2 - 1 (since u[1]=1 is excluded).\nmodel.rank_sum_eq = pyo.Constraint(expr=sum(model.u[i] for i in model.N if i != 1) == (n * (n + 1)) // 2 - 1)\n\n# 2. Tightened Depot-Position Bounds (From Parent 2)\n# Strictly dominates standard MTZ bounds by forcing exact values when connected to the depot.\n# Logic: If x[1,i]=1 => u[i]>=2. If x[i,1]=1 => u[i]>=n. Else => u[i]>=3.\nmodel.tight_lb = pyo.Constraint(model.N, rule=lambda m, i: \n    m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1] if i != 1 else pyo.Constraint.Skip)\n\n# Logic: If x[1,i]=1 => u[i]<=2. If x[i,1]=1 => u[i]<=n. Else => u[i]<=n-1.\nmodel.tight_ub = pyo.Constraint(model.N, rule=lambda m, i: \n    m.u[i] <= n - 1 + m.x[i, 1] - (n - 3) * m.x[1, i] if i != 1 else pyo.Constraint.Skip)\n\n# 3. Desrochers-Laporte (DL) Lifted Cuts (From Parent 1 & 2)\n# Strengthens the subtour elimination logic by incorporating the reverse arc x[j,i].\n# Formula: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\ndef dl_cuts_rule(m, i, j):\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\nmodel.dl_cuts = pyo.Constraint(model.N, model.N, rule=dl_cuts_rule)",
                        "idea": "We introduce the **Rank-Sum Enhanced DL-MTZ** formulation. This hybrid strategy retains the structurally robust **Desrochers-Laporte** (DL) lifted cuts and the **Super-Lifted Bounds** (Parent 2) which lock position variables based on depot connectivity. To strictly tighten the relaxation further, we add a **Global Rank-Sum Equality** constraint (sum of u_i for i != 1 equals n(n+1)/2 - 1). This global cut forces the position variables to inhabit the exact hyperplane of valid permutations, pruning fractional solutions where u_i values drift or cluster locally to satisfy difference constraints, thus driving the formulation closer to the convex hull."
                    },
                    "fitness": 4.534999912460602,
                    "solver_reports": [
                        {
                            "gap": 14.8168,
                            "total_time": 11.85,
                            "explored_nodes": 87,
                            "simplex_iterations": 3135,
                            "explored_time": 11.83,
                            "work_units": 10.5
                        },
                        {
                            "gap": 7.9709,
                            "total_time": 14.54,
                            "explored_nodes": 1,
                            "simplex_iterations": 2241,
                            "explored_time": 14.46,
                            "work_units": 10.01
                        },
                        {
                            "gap": 10.2068,
                            "total_time": 11.41,
                            "explored_nodes": 82,
                            "simplex_iterations": 5282,
                            "explored_time": 11.39,
                            "work_units": 10.07
                        },
                        {
                            "total_time": 13.02,
                            "explored_nodes": 1,
                            "simplex_iterations": 1525,
                            "explored_time": 12.92,
                            "work_units": 10.01
                        },
                        {
                            "gap": 8.7694,
                            "total_time": 10.04,
                            "explored_nodes": 4072,
                            "simplex_iterations": 64937,
                            "explored_time": 10.03,
                            "work_units": 10.01
                        },
                        {
                            "gap": 19.4348,
                            "total_time": 12.39,
                            "explored_nodes": 1,
                            "simplex_iterations": 1727,
                            "explored_time": 12.3,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 0.94,
                            "postsolve": 0.0,
                            "explored_nodes": 7187,
                            "simplex_iterations": 53367,
                            "explored_time": 0.94,
                            "work_units": 0.72
                        },
                        {
                            "gap": 2.6305,
                            "total_time": 11.71,
                            "explored_nodes": 2764,
                            "simplex_iterations": 52401,
                            "explored_time": 11.67,
                            "work_units": 10.01
                        },
                        {
                            "gap": 36.6581,
                            "total_time": 12.24,
                            "explored_nodes": 1,
                            "simplex_iterations": 1782,
                            "explored_time": 12.18,
                            "work_units": 10.01
                        },
                        {
                            "gap": 16.7777,
                            "total_time": 13.39,
                            "explored_nodes": 1,
                            "simplex_iterations": 1774,
                            "explored_time": 13.31,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "913a02db-5ac8-4b6d-bc79-038fe25b976c",
                        "02dbc955-1fc7-47d0-a42a-7bf0f22756b4"
                    ]
                },
                {
                    "id": "7a510a6e-84ea-4063-8266-9af87ec44f35",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Depot-Anchored 3-Cycle Elimination\n    # This constraint targets specific subtours of length 3 that pass through the depot (1 -> i -> j -> 1).\n    # Standard MTZ constraints and Parent 1's bounds allow these subtours in the relaxation for n >= 3.\n    # By explicitly forbidding them, we tighten the LP relaxation at the critical depot node.\n    # This complements Parent 2 (which handles 2-cycles) and Parent 1 (which handles potentials).\n    \n    def depot_sec3_rule(model, i, j):\n        # Eliminate subtour 1 -> i -> j -> 1\n        # Only valid if n > 3 (for n=3, this is the only valid tour)\n        if n > 3 and i != 1 and j != 1 and i != j:\n            return model.x[1, i] + model.x[i, j] + model.x[j, 1] <= 2\n        return pyo.Constraint.Skip\n    \n    model.depot_sec3 = pyo.Constraint(model.N, model.N, rule=depot_sec3_rule)\n\n    return model\n",
                        "added_cut": "# Depot-Anchored 3-Cycle Elimination\n# This constraint targets specific subtours of length 3 that pass through the depot (1 -> i -> j -> 1).\n# Standard MTZ constraints and Parent 1's bounds allow these subtours in the relaxation for n >= 3.\n# By explicitly forbidding them, we tighten the LP relaxation at the critical depot node.\n# This complements Parent 2 (which handles 2-cycles) and Parent 1 (which handles potentials).\n\ndef depot_sec3_rule(model, i, j):\n    # Eliminate subtour 1 -> i -> j -> 1\n    # Only valid if n > 3 (for n=3, this is the only valid tour)\n    if n > 3 and i != 1 and j != 1 and i != j:\n        return model.x[1, i] + model.x[i, j] + model.x[j, 1] <= 2\n    return pyo.Constraint.Skip\n\nmodel.depot_sec3 = pyo.Constraint(model.N, model.N, rule=depot_sec3_rule)",
                        "idea": "We introduce **Depot-Anchored 3-Cycle Elimination**. While Parent 1 tightly bounds node potentials and Parent 2 eliminates 2-cycles, analysis shows that MTZ-based formulations (even with Parent 1's bounds) fail to eliminate 3-cycles anchored at the depot ($1 \\to i \\to j \\to 1$) in the LP relaxation for $n \\ge 3$. This cut explicitly forbids these specific subtours. It provides a complementary $O(n^2)$ tightening that covers the structural gap between Parent 2's local cycle cuts and Parent 1's global potential bounds."
                    },
                    "fitness": 2.8571350070097488,
                    "solver_reports": [
                        {
                            "gap": 6.3023,
                            "total_time": 14.32,
                            "explored_nodes": 59,
                            "simplex_iterations": 7230,
                            "explored_time": 14.3,
                            "work_units": 10.04
                        },
                        {
                            "gap": 36.7843,
                            "total_time": 15.62,
                            "explored_nodes": 1,
                            "simplex_iterations": 4559,
                            "explored_time": 15.53,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.6052,
                            "total_time": 12.59,
                            "explored_nodes": 871,
                            "simplex_iterations": 22032,
                            "explored_time": 12.58,
                            "work_units": 10.02
                        },
                        {
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 3566,
                            "explored_time": 14.05,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.6579,
                            "total_time": 13.46,
                            "explored_nodes": 2814,
                            "simplex_iterations": 51785,
                            "explored_time": 13.44,
                            "work_units": 10.0
                        },
                        {
                            "gap": 70.5691,
                            "total_time": 13.96,
                            "explored_nodes": 1,
                            "simplex_iterations": 4120,
                            "explored_time": 13.89,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 4.84,
                            "postsolve": 0.0,
                            "explored_nodes": 78507,
                            "simplex_iterations": 610433,
                            "explored_time": 4.84,
                            "work_units": 2.91
                        },
                        {
                            "gap": 4.0189,
                            "total_time": 11.81,
                            "explored_nodes": 2834,
                            "simplex_iterations": 42762,
                            "explored_time": 11.78,
                            "work_units": 10.0
                        },
                        {
                            "gap": 29.9922,
                            "total_time": 13.01,
                            "explored_nodes": 115,
                            "simplex_iterations": 6306,
                            "explored_time": 12.98,
                            "work_units": 10.99
                        },
                        {
                            "gap": 28.1605,
                            "total_time": 14.6,
                            "explored_nodes": 1,
                            "simplex_iterations": 3974,
                            "explored_time": 14.52,
                            "work_units": 10.16
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "02dbc955-1fc7-47d0-a42a-7bf0f22756b4",
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "d202e33c-0dbe-4fb0-8a0d-d70852dba9f8",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Global Position-Sum Constraint\n    # This constraint acts as an aggregation-based lifting by enforcing the exact sum of the \n    # positional variables u[i] for i in {2..n}. Since u is a permutation of {2..n}, the sum is constant.\n    # This hyperplane cuts off fractional solutions where u variables satisfy local difference \n    # bounds (DL cuts) but deviate from the required global density/distribution.\n    model.position_sum = pyo.Constraint(expr=sum(model.u[i] for i in model.N if i != 1) == (n * (n + 1)) / 2 - 1)\n\n    return model\n",
                        "added_cut": "# Global Position-Sum Constraint\n# This constraint acts as an aggregation-based lifting by enforcing the exact sum of the \n# positional variables u[i] for i in {2..n}. Since u is a permutation of {2..n}, the sum is constant.\n# This hyperplane cuts off fractional solutions where u variables satisfy local difference \n# bounds (DL cuts) but deviate from the required global density/distribution.\nmodel.position_sum = pyo.Constraint(expr=sum(model.u[i] for i in model.N if i != 1) == (n * (n + 1)) / 2 - 1)",
                        "idea": "We introduce the **Global Position-Sum Equality**, a zero-slack valid hyperplane that enforces the permutation property of the MTZ positional variables. While the Super-Lifted Bounds and DL cuts tightly constrain relative orderings ($u_i - u_j$) and specific value ranges, standard LP relaxations often allow $u$ values to 'float' or cluster to minimize costs. By fixing $\\sum_{i \\neq 1} u_i = \\frac{n(n+1)}{2} - 1$, we globally couple the variables, pruning fractional polytopes where the 'center of mass' of the tour positions is incorrect, thus strengthening the relaxation beyond local difference constraints."
                    },
                    "fitness": 3.522809849385326,
                    "solver_reports": [
                        {
                            "gap": 9.8206,
                            "total_time": 10.42,
                            "explored_nodes": 2488,
                            "simplex_iterations": 41589,
                            "explored_time": 10.4,
                            "work_units": 10.22
                        },
                        {
                            "total_time": 12.36,
                            "explored_nodes": 1,
                            "simplex_iterations": 9360,
                            "explored_time": 12.31,
                            "work_units": 10.0
                        },
                        {
                            "gap": 10.1541,
                            "total_time": 11.33,
                            "explored_nodes": 171,
                            "simplex_iterations": 12029,
                            "explored_time": 11.32,
                            "work_units": 11.14
                        },
                        {
                            "total_time": 16.02,
                            "explored_nodes": 1,
                            "simplex_iterations": 3888,
                            "explored_time": 15.95,
                            "work_units": 10.0
                        },
                        {
                            "gap": 9.1667,
                            "total_time": 10.54,
                            "explored_nodes": 4061,
                            "simplex_iterations": 68895,
                            "explored_time": 10.51,
                            "work_units": 10.0
                        },
                        {
                            "gap": 66.7036,
                            "total_time": 13.71,
                            "explored_nodes": 59,
                            "simplex_iterations": 8389,
                            "explored_time": 13.68,
                            "work_units": 11.12
                        },
                        {
                            "gap": 4.2635,
                            "total_time": 13.43,
                            "explored_nodes": 235808,
                            "simplex_iterations": 1521184,
                            "explored_time": 13.42,
                            "work_units": 10.02
                        },
                        {
                            "gap": 4.4512,
                            "total_time": 11.95,
                            "explored_nodes": 2895,
                            "simplex_iterations": 49993,
                            "explored_time": 11.93,
                            "work_units": 11.17
                        },
                        {
                            "gap": 10.4455,
                            "total_time": 13.44,
                            "explored_nodes": 59,
                            "simplex_iterations": 8531,
                            "explored_time": 13.42,
                            "work_units": 12.2
                        },
                        {
                            "gap": 20.4432,
                            "total_time": 12.98,
                            "explored_nodes": 1,
                            "simplex_iterations": 4856,
                            "explored_time": 12.95,
                            "work_units": 10.04
                        }
                    ],
                    "generator": "Lifted",
                    "parents_id": [
                        "02dbc955-1fc7-47d0-a42a-7bf0f22756b4"
                    ]
                },
                {
                    "id": "fdf5c59c-357d-499b-be23-493c55a7b492",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Global Permutation-Sum Constraint\n    # Unlike Parent 1 and 2 which focus on local bounds and pairwise arc differences, \n    # this cut enforces a global property of the TSP tour: the sum of positions u[i] \n    # must exactly equal the sum of the integer sequence 1..n.\n    \n    def global_potential_sum_rule(model):\n        n = len(model.N)\n        # The sum of positions 1, 2, ..., n is n*(n+1)/2.\n        # This forces the 'center of mass' of the u-variables to be correct in the relaxation,\n        # preventing solutions where u-values are artificially clustered low or high.\n        return sum(model.u[i] for i in model.N) == (n * (n + 1)) / 2\n    \n    model.global_potential_sum = pyo.Constraint(rule=global_potential_sum_rule)\n\n    return model\n",
                        "added_cut": "# Global Permutation-Sum Constraint\n# Unlike Parent 1 and 2 which focus on local bounds and pairwise arc differences, \n# this cut enforces a global property of the TSP tour: the sum of positions u[i] \n# must exactly equal the sum of the integer sequence 1..n.\n\ndef global_potential_sum_rule(model):\n    n = len(model.N)\n    # The sum of positions 1, 2, ..., n is n*(n+1)/2.\n    # This forces the 'center of mass' of the u-variables to be correct in the relaxation,\n    # preventing solutions where u-values are artificially clustered low or high.\n    return sum(model.u[i] for i in model.N) == (n * (n + 1)) / 2\n\nmodel.global_potential_sum = pyo.Constraint(rule=global_potential_sum_rule)",
                        "idea": "The **Global Permutation-Sum Constraint** enforces that the sum of all position variables $\\sum u_i$ equals exactly $n(n+1)/2$. While Parents 1 and 2 tighten the polytope boundaries locally (via node-depot bounds and arc-difference cuts), this equality constraint acts globally on the **volume** of the relaxation. It eliminates fractional solutions where $u_i$ values are compressed (e.g., bunched around small values to satisfy difference constraints minimally) without forming a valid permutation, thereby strictly reducing the search space dimension."
                    },
                    "fitness": 1.3133586149742393,
                    "solver_reports": [
                        {
                            "gap": 17.9989,
                            "total_time": 11.43,
                            "explored_nodes": 4686,
                            "simplex_iterations": 74993,
                            "explored_time": 11.42,
                            "work_units": 10.01
                        },
                        {
                            "gap": 28.6605,
                            "total_time": 13.56,
                            "explored_nodes": 1,
                            "simplex_iterations": 7207,
                            "explored_time": 13.49,
                            "work_units": 10.0
                        },
                        {
                            "gap": 19.2413,
                            "total_time": 10.95,
                            "explored_nodes": 171,
                            "simplex_iterations": 12839,
                            "explored_time": 10.93,
                            "work_units": 10.66
                        },
                        {
                            "total_time": 14.6,
                            "explored_nodes": 1,
                            "simplex_iterations": 3449,
                            "explored_time": 14.53,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.624,
                            "total_time": 11.04,
                            "explored_nodes": 9522,
                            "simplex_iterations": 95669,
                            "explored_time": 11.02,
                            "work_units": 10.0
                        },
                        {
                            "gap": 59.6158,
                            "total_time": 13.51,
                            "explored_nodes": 59,
                            "simplex_iterations": 7790,
                            "explored_time": 13.48,
                            "work_units": 10.48
                        },
                        {
                            "gap": 4.563,
                            "total_time": 13.63,
                            "explored_nodes": 230058,
                            "simplex_iterations": 1428176,
                            "explored_time": 13.62,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.7335,
                            "total_time": 8.76,
                            "explored_nodes": 2961,
                            "simplex_iterations": 53320,
                            "explored_time": 8.74,
                            "work_units": 10.03
                        },
                        {
                            "gap": 17.248,
                            "total_time": 12.35,
                            "explored_nodes": 59,
                            "simplex_iterations": 7754,
                            "explored_time": 12.32,
                            "work_units": 11.93
                        },
                        {
                            "gap": 39.8359,
                            "total_time": 12.75,
                            "explored_nodes": 115,
                            "simplex_iterations": 10111,
                            "explored_time": 12.73,
                            "work_units": 10.13
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "02dbc955-1fc7-47d0-a42a-7bf0f22756b4",
                        "31bf341f-f61d-456f-804f-fef98ecc609c"
                    ]
                }
            ],
            10.353038952236112
        ],
        [
            [
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "17fe43c9-9158-4c3b-8282-7cfd9c624e2c",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def hybrid_tight_dl_rule(model, i, j):\n        # Skip self-loops\n        if i == j:\n            return pyo.Constraint.Skip\n        \n        n = len(model.N)\n        \n        # 1. Tightened Depot-Connection Upper Bound (Logic from Parent 2)\n        # If i=1 (arc 1->j), we restrict u[j].\n        # If x[1,j]=1 -> u[j] <= 2.\n        # If x[1,j]=0 and x[j,1]=0 -> u[j] <= n-1 (Strictly tighter than Parent 1's u[j] <= n).\n        if i == 1:\n            return model.u[j] + (n - 3) * model.x[i, j] - model.x[j, i] <= n - 1\n            \n        # 2. Tightened Depot-Connection Lower Bound (Logic from Parent 2)\n        # If j=1 (arc i->1), we restrict u[i].\n        # If x[i,1]=1 -> u[i] >= n.\n        # If x[i,1]=0 and x[1,i]=0 -> u[i] >= 3 (Strictly tighter than Parent 1's u[i] >= 2).\n        if j == 1:\n            return model.u[i] - (n - 3) * model.x[i, j] + model.x[j, i] >= 3\n            \n        # 3. Desrochers-Laporte (DL) Lifted MTZ (Structure from Parent 1)\n        # Standard strong lifting for internal nodes (i, j != 1).\n        # u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} <= n-2\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n    model.hybrid_dl_cuts = pyo.Constraint(model.N, model.N, rule=hybrid_tight_dl_rule)\n\n    return model\n",
                        "added_cut": "def hybrid_tight_dl_rule(model, i, j):\n    # Skip self-loops\n    if i == j:\n        return pyo.Constraint.Skip\n    \n    n = len(model.N)\n    \n    # 1. Tightened Depot-Connection Upper Bound (Logic from Parent 2)\n    # If i=1 (arc 1->j), we restrict u[j].\n    # If x[1,j]=1 -> u[j] <= 2.\n    # If x[1,j]=0 and x[j,1]=0 -> u[j] <= n-1 (Strictly tighter than Parent 1's u[j] <= n).\n    if i == 1:\n        return model.u[j] + (n - 3) * model.x[i, j] - model.x[j, i] <= n - 1\n        \n    # 2. Tightened Depot-Connection Lower Bound (Logic from Parent 2)\n    # If j=1 (arc i->1), we restrict u[i].\n    # If x[i,1]=1 -> u[i] >= n.\n    # If x[i,1]=0 and x[1,i]=0 -> u[i] >= 3 (Strictly tighter than Parent 1's u[i] >= 2).\n    if j == 1:\n        return model.u[i] - (n - 3) * model.x[i, j] + model.x[j, i] >= 3\n        \n    # 3. Desrochers-Laporte (DL) Lifted MTZ (Structure from Parent 1)\n    # Standard strong lifting for internal nodes (i, j != 1).\n    # u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} <= n-2\n    return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\nmodel.hybrid_dl_cuts = pyo.Constraint(model.N, model.N, rule=hybrid_tight_dl_rule)",
                        "idea": "This constraint fuses the high-performing Desrochers-Laporte lifting (Parent 1) with the strictly tighter variable bounds from Parent 2. By formulating the depot connections as conditional cuts that enforce $u_k \\in [3, n-1]$ for nodes not directly connected to the depot, it eliminates fractional solutions allowed by standard MTZ bounds (which permit values near 2 or $n$), while maintaining the robust coefficient lifting for internal arcs to approximate the convex hull."
                    },
                    "fitness": 7.543592703463016,
                    "solver_reports": [
                        {
                            "gap": 14.5139,
                            "total_time": 12.31,
                            "explored_nodes": 87,
                            "simplex_iterations": 2414,
                            "explored_time": 12.28,
                            "work_units": 10.15
                        },
                        {
                            "gap": 4.8183,
                            "total_time": 13.46,
                            "explored_nodes": 1,
                            "simplex_iterations": 1865,
                            "explored_time": 13.33,
                            "work_units": 10.0
                        },
                        {
                            "gap": 9.3844,
                            "total_time": 11.33,
                            "explored_nodes": 659,
                            "simplex_iterations": 16064,
                            "explored_time": 11.31,
                            "work_units": 10.02
                        },
                        {
                            "total_time": 12.96,
                            "explored_nodes": 1,
                            "simplex_iterations": 1495,
                            "explored_time": 12.86,
                            "work_units": 10.01
                        },
                        {
                            "gap": 3.1019,
                            "total_time": 12.06,
                            "explored_nodes": 2831,
                            "simplex_iterations": 50496,
                            "explored_time": 12.03,
                            "work_units": 10.02
                        },
                        {
                            "gap": 3.8675,
                            "total_time": 13.0,
                            "explored_nodes": 1,
                            "simplex_iterations": 3981,
                            "explored_time": 12.94,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 1.38,
                            "postsolve": 0.01,
                            "explored_nodes": 26041,
                            "simplex_iterations": 142206,
                            "explored_time": 1.38,
                            "work_units": 0.72
                        },
                        {
                            "gap": 4.3692,
                            "total_time": 10.45,
                            "explored_nodes": 1453,
                            "simplex_iterations": 26112,
                            "explored_time": 10.43,
                            "work_units": 10.06
                        },
                        {
                            "gap": 17.3425,
                            "total_time": 11.66,
                            "explored_nodes": 3,
                            "simplex_iterations": 1600,
                            "explored_time": 11.61,
                            "work_units": 10.05
                        },
                        {
                            "gap": 17.3122,
                            "total_time": 13.37,
                            "explored_nodes": 1,
                            "simplex_iterations": 1515,
                            "explored_time": 13.29,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "f56d4438-9294-4a9f-93d6-eaed89618f4f",
                        "380454ef-453d-4b81-b1a6-d0d77d48ccab"
                    ]
                },
                {
                    "id": "2d30caee-0047-425b-ab6d-3b0bd5ab7fef",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Lifted MTZ (Desrochers & Laporte) Constraints\n    # This constraint recombines Parent 1's focus on 2-cycle elimination (using reverse arcs x[j,i])\n    # with Parent 2's focus on tightening the domain of position variables u.\n    def lifted_mtz_rule(model, i, j):\n        # Apply to all pairs of non-depot nodes\n        if i != 1 and j != 1 and i != j:\n            n = len(model.N)\n            # The constraint: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n            # This strengthens the standard MTZ by explicitly penalizing the reverse arc x[j,i].\n            # If a 2-cycle (x_ij=x_ji=1) were attempted, the LHS would explode, preventing it.\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    \n    model.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Lifted MTZ (Desrochers & Laporte) Constraints\n# This constraint recombines Parent 1's focus on 2-cycle elimination (using reverse arcs x[j,i])\n# with Parent 2's focus on tightening the domain of position variables u.\ndef lifted_mtz_rule(model, i, j):\n    # Apply to all pairs of non-depot nodes\n    if i != 1 and j != 1 and i != j:\n        n = len(model.N)\n        # The constraint: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n        # This strengthens the standard MTZ by explicitly penalizing the reverse arc x[j,i].\n        # If a 2-cycle (x_ij=x_ji=1) were attempted, the LHS would explode, preventing it.\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\n\nmodel.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "The Desrochers & Laporte lifted constraint synthesizes the parents by injecting the logic of 2-cycle elimination (Parent 1) directly into the potential-variable formulation (Parent 2). While Parent 1 explicitly cuts $x_{i,j} + x_{j,i} \\le 1$ and Parent 2 constrains the global mass of $u$, this offspring strengthens the local MTZ link between $x$ and $u$. By adding the term $(n-3)x_{j,i}$ to the standard potential constraint, it tightens the relaxation significantly: if the reverse arc $x_{j,i}$ is active, the bound on $u_i - u_j$ becomes tighter, preventing the loose positional assignments that allow fractional subtours to persist in the standard MTZ formulation."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 12.3,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 12.28,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.82,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 13.73,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 12.2,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 12.18,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.87,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.78,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 11.85,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 11.82,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 12.51,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 12.43,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 15.07,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 15.07,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 11.0,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 10.99,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 11.49,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 11.46,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 13.02,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 12.97,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Min_Violation",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "fdf5c59c-357d-499b-be23-493c55a7b492"
                    ]
                },
                {
                    "id": "b86b6dfa-ed88-4fdd-ab6b-26c539ba9113",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Two-Hop Precedence (THP) Constraints\n    # Extends the lifting logic of Parent 1 to paths of length 2.\n    # Logic: If path i -> k -> j exists (x[i,k]=1 and x[k,j]=1), then u[j] must be at least u[i] + 2.\n    # This enforces stricter positional separation than standard MTZ and explicitly eliminates 3-cycle subtours.\n    # Formulation: u[i] - u[j] + n * (x[i, k] + x[k, j]) <= 2*n - 2\n    \n    def two_hop_rule(model, i, k, j):\n        # Apply only to distinct non-depot nodes\n        if {i, j, k} & {1} or len({i, j, k}) < 3:\n            return pyo.Constraint.Skip\n        return model.u[i] - model.u[j] + n * (model.x[i, k] + model.x[k, j]) <= 2 * n - 2\n    \n    model.two_hop_mtz = pyo.Constraint(model.N, model.N, model.N, rule=two_hop_rule)\n\n    return model\n",
                        "added_cut": "# Two-Hop Precedence (THP) Constraints\n# Extends the lifting logic of Parent 1 to paths of length 2.\n# Logic: If path i -> k -> j exists (x[i,k]=1 and x[k,j]=1), then u[j] must be at least u[i] + 2.\n# This enforces stricter positional separation than standard MTZ and explicitly eliminates 3-cycle subtours.\n# Formulation: u[i] - u[j] + n * (x[i, k] + x[k, j]) <= 2*n - 2\n\ndef two_hop_rule(model, i, k, j):\n    # Apply only to distinct non-depot nodes\n    if {i, j, k} & {1} or len({i, j, k}) < 3:\n        return pyo.Constraint.Skip\n    return model.u[i] - model.u[j] + n * (model.x[i, k] + model.x[k, j]) <= 2 * n - 2\n\nmodel.two_hop_mtz = pyo.Constraint(model.N, model.N, model.N, rule=two_hop_rule)",
                        "idea": "We introduce **Two-Hop Precedence (THP) Cuts**, which strengthen the linear relaxation by enforcing ordering constraints over paths of length 2 ($i \\to k \\to j \\implies u_j \\ge u_i + 2$). This effectively bridges the gap between Parent 1 (which enforces 1-hop positional bounds via DL cuts) and Parent 2 (which targets small combinatorial cycles). By forcing a separation of 2 units for 2-hop paths, THP cuts strictly eliminate all size-3 subtours (which often persist in MTZ relaxations) and tighten the convex hull of the $u$-variables beyond what simple Rank-Sum or 2-cycle cuts achieve."
                    },
                    "fitness": 2.415957663047882,
                    "solver_reports": [
                        {
                            "total_time": 11.26,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 10.92,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 21.64,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 18.96,
                            "work_units": 12.49
                        },
                        {
                            "total_time": 11.42,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 10.92,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 20.4,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 16.35,
                            "work_units": 10.24
                        },
                        {
                            "total_time": 11.85,
                            "explored_nodes": 1,
                            "simplex_iterations": 441,
                            "explored_time": 11.66,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 18.68,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 16.8,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.2499,
                            "total_time": 12.03,
                            "explored_nodes": 3028,
                            "simplex_iterations": 19290,
                            "explored_time": 12.01,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 13.49,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 12.92,
                            "work_units": 10.13
                        },
                        {
                            "total_time": 15.73,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 14.32,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 19.52,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 17.55,
                            "work_units": 10.15
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "380454ef-453d-4b81-b1a6-d0d77d48ccab",
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "386fc150-f474-4a3e-85e9-b4867b71b7ad",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # 4. Depot-Interactive Lifted DL Cuts (Mutation)\n    # This cut strengthens the standard Desrochers-Laporte (DL) constraints by exploiting\n    # the tighter bounds of nodes not directly connected to the depot.\n    # Standard DL uses a Big-M of (n-2). We reduce this to (n-4) for internal nodes,\n    # adding slack variables (x[i,1] and x[1,j]) to validly cover the boundary cases.\n    # This strictly dominates the standard DL cuts provided in the input.\n    \n    def depot_lifted_dl_rule(model, i, j):\n        # Apply only for distinct non-depot nodes\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        \n        # Formulation: u[i] - u[j] + (n-3)x[i,j] + (n-5)x[j,i] <= n - 4 + x[i,1] + x[1,j]\n        # If nodes i,j are 'internal' (not first/last), max u_i - u_j is n-4.\n        # If connected to depot, the RHS increases to accommodate the larger range (n-2).\n        return (model.u[i] - model.u[j] + \n                (n - 3) * model.x[i, j] + \n                (n - 5) * model.x[j, i] - \n                model.x[i, 1] - model.x[1, j] <= n - 4)\n    \n    model.depot_lifted_dl = pyo.Constraint(model.N, model.N, rule=depot_lifted_dl_rule)\n\n    return model\n",
                        "added_cut": "# 4. Depot-Interactive Lifted DL Cuts (Mutation)\n# This cut strengthens the standard Desrochers-Laporte (DL) constraints by exploiting\n# the tighter bounds of nodes not directly connected to the depot.\n# Standard DL uses a Big-M of (n-2). We reduce this to (n-4) for internal nodes,\n# adding slack variables (x[i,1] and x[1,j]) to validly cover the boundary cases.\n# This strictly dominates the standard DL cuts provided in the input.\n\ndef depot_lifted_dl_rule(model, i, j):\n    # Apply only for distinct non-depot nodes\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    \n    # Formulation: u[i] - u[j] + (n-3)x[i,j] + (n-5)x[j,i] <= n - 4 + x[i,1] + x[1,j]\n    # If nodes i,j are 'internal' (not first/last), max u_i - u_j is n-4.\n    # If connected to depot, the RHS increases to accommodate the larger range (n-2).\n    return (model.u[i] - model.u[j] + \n            (n - 3) * model.x[i, j] + \n            (n - 5) * model.x[j, i] - \n            model.x[i, 1] - model.x[1, j] <= n - 4)\n\nmodel.depot_lifted_dl = pyo.Constraint(model.N, model.N, rule=depot_lifted_dl_rule)",
                        "idea": "We mutate the Desrochers-Laporte (DL) cuts by introducing depot-connectivity variables into the inequality. By recognizing that the maximum position difference between two 'internal' nodes (neither first nor last in the tour) is strictly $n-4$ (rather than $n-2$), we can tighten the Big-M coefficients on the arc variables $x_{ij}$ and $x_{ji}$. The terms $x_{i,1}$ and $x_{1,j}$ are added to the Right-Hand Side to relax the bound back to $n-2$ only when necessary, resulting in a strictly tighter formulation for the majority of the search space."
                    },
                    "fitness": 0.9031322657546172,
                    "solver_reports": [
                        {
                            "gap": 33.591,
                            "total_time": 11.61,
                            "explored_nodes": 470,
                            "simplex_iterations": 10708,
                            "explored_time": 11.6,
                            "work_units": 10.05
                        },
                        {
                            "gap": 25.5389,
                            "total_time": 11.57,
                            "explored_nodes": 1,
                            "simplex_iterations": 2382,
                            "explored_time": 11.48,
                            "work_units": 10.01
                        },
                        {
                            "gap": 15.0465,
                            "total_time": 12.13,
                            "explored_nodes": 143,
                            "simplex_iterations": 5397,
                            "explored_time": 12.12,
                            "work_units": 11.95
                        },
                        {
                            "total_time": 11.52,
                            "explored_nodes": 1,
                            "simplex_iterations": 1987,
                            "explored_time": 11.4,
                            "work_units": 10.0
                        },
                        {
                            "gap": 9.4499,
                            "total_time": 9.95,
                            "explored_nodes": 1205,
                            "simplex_iterations": 23464,
                            "explored_time": 9.94,
                            "work_units": 10.03
                        },
                        {
                            "gap": 29.0264,
                            "total_time": 10.79,
                            "explored_nodes": 1,
                            "simplex_iterations": 1908,
                            "explored_time": 10.72,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.9194,
                            "total_time": 11.85,
                            "explored_nodes": 182537,
                            "simplex_iterations": 1133508,
                            "explored_time": 11.85,
                            "work_units": 10.01
                        },
                        {
                            "gap": 10.4909,
                            "total_time": 10.83,
                            "explored_nodes": 143,
                            "simplex_iterations": 7860,
                            "explored_time": 10.81,
                            "work_units": 10.01
                        },
                        {
                            "gap": 30.3628,
                            "total_time": 12.66,
                            "explored_nodes": 1,
                            "simplex_iterations": 1286,
                            "explored_time": 12.61,
                            "work_units": 10.0
                        },
                        {
                            "gap": 51.4389,
                            "total_time": 12.29,
                            "explored_nodes": 1,
                            "simplex_iterations": 1517,
                            "explored_time": 12.23,
                            "work_units": 10.07
                        }
                    ],
                    "generator": "General",
                    "parents_id": [
                        "380454ef-453d-4b81-b1a6-d0d77d48ccab"
                    ]
                },
                {
                    "id": "5b4cc02b-6c23-4336-912f-1b88b08484a0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Strong Perimeter & DL-Lifted Formulation\n    # Combines the 'Strong Bounds' from Parent 2 with the 'Desrochers-Laporte' logic (Parent 1/2).\n    # This configuration strictly bounds node potentials and lifts internal subtour constraints.\n    \n    n = len(model.N)\n    \n    # 1. Strong Perimeter Bounds\n    # These constraints strictly anchor the potentials u[i] based on depot connectivity.\n    # Logic: \n    #   - If 1->i (start), u[i] forced to 2.\n    #   - If i->1 (end), u[i] forced to n.\n    #   - Else (internal node), u[i] restricted to [3, n-1] (tighter than standard [2, n]).\n    \n    def strong_perimeter_lb(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        # u[i] >= 3 - x[1,i] + (n-3)x[i,1]\n        return m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1]\n    model.strong_perimeter_lb = pyo.Constraint(model.N, rule=strong_perimeter_lb)\n    \n    def strong_perimeter_ub(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        # u[i] <= n-1 + x[i,1] - (n-3)x[1,i]\n        return m.u[i] <= (n - 1) + m.x[i, 1] - (n - 3) * m.x[1, i]\n    model.strong_perimeter_ub = pyo.Constraint(model.N, rule=strong_perimeter_ub)\n    \n    # 2. Desrochers-Laporte (DL) Lifted Cuts\n    # Replaces standard MTZ for internal nodes with a lifted version including the reverse arc x[j,i].\n    # Formula: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\n    \n    def dl_lifted_cuts_rule(m, i, j):\n        # Apply only to internal pairs (i,j != 1)\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    model.dl_lifted_cuts = pyo.Constraint(model.N, model.N, rule=dl_lifted_cuts_rule)\n\n    return model\n",
                        "added_cut": "# Strong Perimeter & DL-Lifted Formulation\n# Combines the 'Strong Bounds' from Parent 2 with the 'Desrochers-Laporte' logic (Parent 1/2).\n# This configuration strictly bounds node potentials and lifts internal subtour constraints.\n\nn = len(model.N)\n\n# 1. Strong Perimeter Bounds\n# These constraints strictly anchor the potentials u[i] based on depot connectivity.\n# Logic: \n#   - If 1->i (start), u[i] forced to 2.\n#   - If i->1 (end), u[i] forced to n.\n#   - Else (internal node), u[i] restricted to [3, n-1] (tighter than standard [2, n]).\n\ndef strong_perimeter_lb(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    # u[i] >= 3 - x[1,i] + (n-3)x[i,1]\n    return m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1]\nmodel.strong_perimeter_lb = pyo.Constraint(model.N, rule=strong_perimeter_lb)\n\ndef strong_perimeter_ub(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    # u[i] <= n-1 + x[i,1] - (n-3)x[1,i]\n    return m.u[i] <= (n - 1) + m.x[i, 1] - (n - 3) * m.x[1, i]\nmodel.strong_perimeter_ub = pyo.Constraint(model.N, rule=strong_perimeter_ub)\n\n# 2. Desrochers-Laporte (DL) Lifted Cuts\n# Replaces standard MTZ for internal nodes with a lifted version including the reverse arc x[j,i].\n# Formula: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\n\ndef dl_lifted_cuts_rule(m, i, j):\n    # Apply only to internal pairs (i,j != 1)\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\nmodel.dl_lifted_cuts = pyo.Constraint(model.N, model.N, rule=dl_lifted_cuts_rule)",
                        "idea": "This cut formulation creates a 'Strong Perimeter DL-MTZ' hybrid. It discards the dense Rank-Sum constraint from Parent 2 (likely the cause of its lower fitness due to matrix density) but retains its mathematically superior 'Strong Perimeter Bounds'. These bounds restrict internal node potentials to $[3, n-1]$ (vs standard $[2, n]$), explicitly reducing the feasible region search space. This is coupled with the Desrochers-Laporte lifted cuts for internal nodes to tighten the subtour relaxation by accounting for 2-cycles, ensuring a strictly tighter formulation than standard MTZ while maintaining sparsity."
                    },
                    "fitness": 0.986663100107317,
                    "solver_reports": [
                        {
                            "gap": 12.0058,
                            "total_time": 12.2,
                            "explored_nodes": 586,
                            "simplex_iterations": 12692,
                            "explored_time": 12.19,
                            "work_units": 10.07
                        },
                        {
                            "total_time": 13.04,
                            "explored_nodes": 1,
                            "simplex_iterations": 2264,
                            "explored_time": 12.94,
                            "work_units": 10.01
                        },
                        {
                            "gap": 7.052,
                            "total_time": 12.06,
                            "explored_nodes": 59,
                            "simplex_iterations": 4724,
                            "explored_time": 12.03,
                            "work_units": 10.2
                        },
                        {
                            "total_time": 13.22,
                            "explored_nodes": 1,
                            "simplex_iterations": 1772,
                            "explored_time": 13.11,
                            "work_units": 10.03
                        },
                        {
                            "gap": 5.2098,
                            "total_time": 11.91,
                            "explored_nodes": 2861,
                            "simplex_iterations": 56711,
                            "explored_time": 11.88,
                            "work_units": 10.01
                        },
                        {
                            "gap": 89.6603,
                            "total_time": 12.93,
                            "explored_nodes": 1,
                            "simplex_iterations": 1570,
                            "explored_time": 12.87,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 5.52,
                            "postsolve": 0.0,
                            "explored_nodes": 124119,
                            "simplex_iterations": 722437,
                            "explored_time": 5.52,
                            "work_units": 3.07
                        },
                        {
                            "gap": 2.5015,
                            "total_time": 13.95,
                            "explored_nodes": 406,
                            "simplex_iterations": 20826,
                            "explored_time": 13.93,
                            "work_units": 10.14
                        },
                        {
                            "gap": 21.9246,
                            "total_time": 13.21,
                            "explored_nodes": 1,
                            "simplex_iterations": 1121,
                            "explored_time": 13.14,
                            "work_units": 10.0
                        },
                        {
                            "gap": 71.3715,
                            "total_time": 14.13,
                            "explored_nodes": 1,
                            "simplex_iterations": 1580,
                            "explored_time": 14.05,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "f56d4438-9294-4a9f-93d6-eaed89618f4f",
                        "380454ef-453d-4b81-b1a6-d0d77d48ccab"
                    ]
                },
                {
                    "id": "cc82ac91-9c04-4f91-9b7b-f1a1f86a351d",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def advanced_mtz_tightening(model):\n        n = len(model.N)\n        # 1. Depot-Dependent Bounds\n        # These constraints tighten the domain of u[i] based on connectivity to the depot.\n        # They are valid because if a node is not connected to the depot, it cannot be at pos 2 (start) or pos n (end).\n        def lower_bound_rule(m, i):\n            if i == 1: return pyo.Constraint.Skip\n            # If x[1,i]=0, i is not 2nd node -> u[i] >= 3. If x[1,i]=1, u[i] >= 2.\n            return m.u[i] >= 3 - m.x[1, i]\n        model.u_tight_lower = pyo.Constraint(model.N, rule=lower_bound_rule)\n    \n        def upper_bound_rule(m, i):\n            if i == 1: return pyo.Constraint.Skip\n            # If x[i,1]=0, i is not last node -> u[i] <= n-1. If x[i,1]=1, u[i] <= n.\n            return m.u[i] <= n - 1 + m.x[i, 1]\n        model.u_tight_upper = pyo.Constraint(model.N, rule=upper_bound_rule)\n    \n        # 2. Super-Lifted MTZ Cut (Gouveia & Pires style logic)\n        # Uses the tightened bounds to strengthen the Desrochers & Laporte lifting.\n        # Standard DL: u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} <= n-2\n        # With u_i <= n-1 (if not to depot) and u_j >= 3 (if not from depot), we can shift RHS by 2.\n        def super_lifted_rule(m, i, j):\n            if i == 1 or j == 1 or i == j:\n                return pyo.Constraint.Skip\n            # This cut requires the bounds above to be present in the model to be valid on relaxations.\n            return m.u[i] - m.u[j] + (n - 3) * m.x[i, j] + (n - 5) * m.x[j, i] - m.x[i, 1] - m.x[1, j] <= n - 4\n        \n        model.super_lifted_mtz = pyo.Constraint(model.N, model.N, rule=super_lifted_rule)\n    \n    advanced_mtz_tightening(model)\n\n    return model\n",
                        "added_cut": "def advanced_mtz_tightening(model):\n    n = len(model.N)\n    # 1. Depot-Dependent Bounds\n    # These constraints tighten the domain of u[i] based on connectivity to the depot.\n    # They are valid because if a node is not connected to the depot, it cannot be at pos 2 (start) or pos n (end).\n    def lower_bound_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        # If x[1,i]=0, i is not 2nd node -> u[i] >= 3. If x[1,i]=1, u[i] >= 2.\n        return m.u[i] >= 3 - m.x[1, i]\n    model.u_tight_lower = pyo.Constraint(model.N, rule=lower_bound_rule)\n\n    def upper_bound_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        # If x[i,1]=0, i is not last node -> u[i] <= n-1. If x[i,1]=1, u[i] <= n.\n        return m.u[i] <= n - 1 + m.x[i, 1]\n    model.u_tight_upper = pyo.Constraint(model.N, rule=upper_bound_rule)\n\n    # 2. Super-Lifted MTZ Cut (Gouveia & Pires style logic)\n    # Uses the tightened bounds to strengthen the Desrochers & Laporte lifting.\n    # Standard DL: u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} <= n-2\n    # With u_i <= n-1 (if not to depot) and u_j >= 3 (if not from depot), we can shift RHS by 2.\n    def super_lifted_rule(m, i, j):\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        # This cut requires the bounds above to be present in the model to be valid on relaxations.\n        return m.u[i] - m.u[j] + (n - 3) * m.x[i, j] + (n - 5) * m.x[j, i] - m.x[i, 1] - m.x[1, j] <= n - 4\n    \n    model.super_lifted_mtz = pyo.Constraint(model.N, model.N, rule=super_lifted_rule)\n\nadvanced_mtz_tightening(model)",
                        "idea": "This mutation decomposes the strengthening into two explicit parts to ensure validity and solver stability. First, it introduces 'Depot-Dependent Bounds' ($u_j \\ge 3 - x_{1,j}$ and $u_i \\le n-1 + x_{i,1}$), which strictly enforce that nodes not directly connected to the depot cannot occupy the second or last positions. Second, leveraging these tighter bounds, it applies a 'Super-Lifted' MTZ constraint for internal nodes. This reduces the Big-M coefficients of the standard Desrochers & Laporte cut by 2 (from $n-1/n-3$ to $n-3/n-5$) and dynamically adjusts the RHS based on depot connections, creating a much tighter formulation than the individual's proposal."
                    },
                    "fitness": 0.9485625755515168,
                    "solver_reports": [
                        {
                            "gap": 11.3248,
                            "total_time": 13.05,
                            "explored_nodes": 87,
                            "simplex_iterations": 4138,
                            "explored_time": 13.03,
                            "work_units": 11.08
                        },
                        {
                            "total_time": 11.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 2532,
                            "explored_time": 11.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 12.9428,
                            "total_time": 10.31,
                            "explored_nodes": 250,
                            "simplex_iterations": 9175,
                            "explored_time": 10.29,
                            "work_units": 10.02
                        },
                        {
                            "total_time": 12.68,
                            "explored_nodes": 1,
                            "simplex_iterations": 1848,
                            "explored_time": 12.57,
                            "work_units": 10.01
                        },
                        {
                            "gap": 7.781,
                            "total_time": 10.45,
                            "explored_nodes": 5047,
                            "simplex_iterations": 60426,
                            "explored_time": 10.43,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 12.03,
                            "explored_nodes": 1,
                            "simplex_iterations": 1675,
                            "explored_time": 11.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.8339,
                            "total_time": 12.3,
                            "explored_nodes": 185623,
                            "simplex_iterations": 1177254,
                            "explored_time": 12.3,
                            "work_units": 10.04
                        },
                        {
                            "gap": 4.7535,
                            "total_time": 12.99,
                            "explored_nodes": 1,
                            "simplex_iterations": 4201,
                            "explored_time": 12.96,
                            "work_units": 10.0
                        },
                        {
                            "gap": 40.6994,
                            "total_time": 12.46,
                            "explored_nodes": 1,
                            "simplex_iterations": 1416,
                            "explored_time": 12.43,
                            "work_units": 10.01
                        },
                        {
                            "gap": 45.8125,
                            "total_time": 11.83,
                            "explored_nodes": 1,
                            "simplex_iterations": 2235,
                            "explored_time": 11.78,
                            "work_units": 10.01
                        }
                    ],
                    "generator": "General",
                    "parents_id": [
                        "f56d4438-9294-4a9f-93d6-eaed89618f4f"
                    ]
                },
                {
                    "id": "439b7646-41fc-4e16-af57-6085834c886b",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Desrochers & Laporte (1991) Lifted MTZ constraints\n    # This mutation strengthens the original 2-cycle elimination idea by incorporating it directly\n    # into the subtour elimination constraints for non-depot nodes.\n    def lifted_mtz_rule(model, i, j):\n        if i != 1 and j != 1 and i != j:\n            # Lifted inequality: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    \n    model.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Desrochers & Laporte (1991) Lifted MTZ constraints\n# This mutation strengthens the original 2-cycle elimination idea by incorporating it directly\n# into the subtour elimination constraints for non-depot nodes.\ndef lifted_mtz_rule(model, i, j):\n    if i != 1 and j != 1 and i != j:\n        # Lifted inequality: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\n\nmodel.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "The provided individual cut explicitly removes 2-cycles (x_ij + x_ji <= 1). The Lifted MTZ constraints (Desrochers & Laporte, 1991) generalize this by tightening the standard MTZ inequality with the term (n-3)x_ji. This modification strictly dominates the standard MTZ constraints and mathematically implies the elimination of 2-cycles when summed symmetrically, thus achieving the individual's goal while providing a much tighter convex hull for the linear relaxation."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 11.64,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 11.62,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.84,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 13.77,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 12.63,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 12.61,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.91,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.82,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 12.12,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 12.09,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 13.07,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 13.0,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 14.5,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 14.5,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 10.97,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 10.95,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 12.06,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 12.03,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 13.38,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 13.33,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "General",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                }
            ],
            10.353038952236112
        ],
        [
            [
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "9345ff90-a6cd-4c4a-a650-ba197640a146",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def hybrid_tightened_dl_rule(model, i, j):\n        # Skip self-loops\n        if i == j:\n            return pyo.Constraint.Skip\n        \n        n = len(model.N)\n        \n        # Part 1: Strict Depot-Neighbor Bounds (Inherited from Parent 1)\n        # These constraints explicitly tighten the domain of u for nodes connected to the depot.\n        \n        # Case i=1 (Arc 1->j): Tighten u[j] upper bound.\n        # If x[1,j]=1 -> u[j] <= 2. \n        # If x[1,j]=0 and x[j,1]=0 -> u[j] <= n-1 (Strictly tighter than standard n).\n        if i == 1:\n            return model.u[j] + (n - 3) * model.x[i, j] - model.x[j, i] <= n - 1\n    \n        # Case j=1 (Arc i->1): Tighten u[i] lower bound.\n        # If x[i,1]=1 -> u[i] >= n.\n        # If x[i,1]=0 and x[1,i]=0 -> u[i] >= 3 (Strictly tighter than standard 2).\n        if j == 1:\n            return model.u[i] - (n - 3) * model.x[i, j] + model.x[j, i] >= 3\n    \n        # Part 2: Tighter Conditional Lifting for Internal Nodes (Inherited from Parent 2)\n        # For i,j != 1, the max difference u[i]-u[j] is naturally smaller (n-4) unless\n        # they connect to the depot. We use tighter coefficients (n-3 instead of n-1)\n        # and lift with depot-connection vars (x[i,1], x[1,j]) to restore validity.\n        return (model.u[i] - model.u[j] + \n                (n - 3) * model.x[i, j] + \n                (n - 5) * model.x[j, i] - \n                model.x[i, 1] - model.x[1, j] <= n - 4)\n    \n    model.hybrid_dl_cuts = pyo.Constraint(model.N, model.N, rule=hybrid_tightened_dl_rule)\n\n    return model\n",
                        "added_cut": "def hybrid_tightened_dl_rule(model, i, j):\n    # Skip self-loops\n    if i == j:\n        return pyo.Constraint.Skip\n    \n    n = len(model.N)\n    \n    # Part 1: Strict Depot-Neighbor Bounds (Inherited from Parent 1)\n    # These constraints explicitly tighten the domain of u for nodes connected to the depot.\n    \n    # Case i=1 (Arc 1->j): Tighten u[j] upper bound.\n    # If x[1,j]=1 -> u[j] <= 2. \n    # If x[1,j]=0 and x[j,1]=0 -> u[j] <= n-1 (Strictly tighter than standard n).\n    if i == 1:\n        return model.u[j] + (n - 3) * model.x[i, j] - model.x[j, i] <= n - 1\n\n    # Case j=1 (Arc i->1): Tighten u[i] lower bound.\n    # If x[i,1]=1 -> u[i] >= n.\n    # If x[i,1]=0 and x[1,i]=0 -> u[i] >= 3 (Strictly tighter than standard 2).\n    if j == 1:\n        return model.u[i] - (n - 3) * model.x[i, j] + model.x[j, i] >= 3\n\n    # Part 2: Tighter Conditional Lifting for Internal Nodes (Inherited from Parent 2)\n    # For i,j != 1, the max difference u[i]-u[j] is naturally smaller (n-4) unless\n    # they connect to the depot. We use tighter coefficients (n-3 instead of n-1)\n    # and lift with depot-connection vars (x[i,1], x[1,j]) to restore validity.\n    return (model.u[i] - model.u[j] + \n            (n - 3) * model.x[i, j] + \n            (n - 5) * model.x[j, i] - \n            model.x[i, 1] - model.x[1, j] <= n - 4)\n\nmodel.hybrid_dl_cuts = pyo.Constraint(model.N, model.N, rule=hybrid_tightened_dl_rule)",
                        "idea": "This hybrid constraint integrates the strict depot-connection bounds from Parent 1 with the tightened internal lifting from Parent 2. For nodes directly interacting with the depot ($i=1$ or $j=1$), it enforces tight absolute position limits ($u_k \\in [3, n-1]$ if disconnected), eliminating fractional values near the domain boundaries. For internal node pairs ($i,j \\neq 1$), it replaces the standard Desrochers-Laporte cut with a stronger variant: the Big-M coefficients are reduced ($n-3$ vs $n-1$) relative to a tighter base RHS ($n-4$), conditionally relaxed by depot-adjacency variables ($x_{i,1}, x_{1,j}$). This creates a strictly tighter polyhedral approximation by distinguishing between internal sub-paths and depot-connected endpoints."
                    },
                    "fitness": 0.20582165181054227,
                    "solver_reports": [
                        {
                            "gap": 30.9614,
                            "total_time": 11.74,
                            "explored_nodes": 164,
                            "simplex_iterations": 5646,
                            "explored_time": 11.72,
                            "work_units": 10.04
                        },
                        {
                            "total_time": 11.3,
                            "explored_nodes": 1,
                            "simplex_iterations": 1885,
                            "explored_time": 11.22,
                            "work_units": 10.02
                        },
                        {
                            "gap": 18.9834,
                            "total_time": 11.11,
                            "explored_nodes": 200,
                            "simplex_iterations": 6168,
                            "explored_time": 11.09,
                            "work_units": 10.81
                        },
                        {
                            "total_time": 11.81,
                            "explored_nodes": 1,
                            "simplex_iterations": 1390,
                            "explored_time": 11.68,
                            "work_units": 10.15
                        },
                        {
                            "gap": 11.2948,
                            "total_time": 11.68,
                            "explored_nodes": 4501,
                            "simplex_iterations": 63284,
                            "explored_time": 11.64,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.3255,
                            "total_time": 12.72,
                            "explored_nodes": 1,
                            "simplex_iterations": 2539,
                            "explored_time": 12.65,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 1.97,
                            "postsolve": 0.0,
                            "explored_nodes": 26810,
                            "simplex_iterations": 157357,
                            "explored_time": 1.96,
                            "work_units": 1.25
                        },
                        {
                            "gap": 7.1489,
                            "total_time": 12.45,
                            "explored_nodes": 1,
                            "simplex_iterations": 2391,
                            "explored_time": 12.42,
                            "work_units": 10.0
                        },
                        {
                            "gap": 62.0915,
                            "total_time": 11.2,
                            "explored_nodes": 1,
                            "simplex_iterations": 1396,
                            "explored_time": 11.16,
                            "work_units": 10.0
                        },
                        {
                            "gap": 88.3692,
                            "total_time": 12.48,
                            "explored_nodes": 1,
                            "simplex_iterations": 1370,
                            "explored_time": 12.44,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "17fe43c9-9158-4c3b-8282-7cfd9c624e2c",
                        "386fc150-f474-4a3e-85e9-b4867b71b7ad"
                    ]
                },
                {
                    "id": "69e4e4da-3ca8-4de3-b51c-3d87ff41bf99",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def complete_lifted_mtz_rule(model, i, j):\n        # Skip self-loops\n        if i == j:\n            return pyo.Constraint.Skip\n        \n        n = len(model.N)\n        \n        # 1. Depot-Outgoing Case (i=1): Strict Upper Bound on u[j]\n        # If 1->j is used, u[j] must be 2. If not, and j->1 is not used, u[j] <= n-1.\n        # Parent 1's logic provides the strongest cut here.\n        if i == 1:\n            return model.u[j] + (n - 3) * model.x[i, j] - model.x[j, i] <= n - 1\n            \n        # 2. Depot-Incoming Case (j=1): Strict Lower Bound on u[i]\n        # If i->1 is used, u[i] must be n. If not, u[i] >= 3.\n        # Parent 1's logic provides the strongest cut here.\n        if j == 1:\n            return model.u[i] - (n - 3) * model.x[i, j] + model.x[j, i] >= 3\n            \n        # 3. Internal Node Case (i, j != 1): Depot-Aware Lifted DL Cut\n        # Parent 2's logic is strictly tighter for internal nodes, using coefficients (n-3)/(n-5)\n        # instead of (n-1)/(n-3) by exploiting the reduced range of u for non-depot-connected nodes.\n        # We incorporate slack terms x[i,1] and x[1,j] to handle boundary conditions validly.\n        return (model.u[i] - model.u[j] + \n                (n - 3) * model.x[i, j] + \n                (n - 5) * model.x[j, i] - \n                model.x[i, 1] - model.x[1, j] <= n - 4)\n    \n    model.complete_lifted_mtz = pyo.Constraint(model.N, model.N, rule=complete_lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "def complete_lifted_mtz_rule(model, i, j):\n    # Skip self-loops\n    if i == j:\n        return pyo.Constraint.Skip\n    \n    n = len(model.N)\n    \n    # 1. Depot-Outgoing Case (i=1): Strict Upper Bound on u[j]\n    # If 1->j is used, u[j] must be 2. If not, and j->1 is not used, u[j] <= n-1.\n    # Parent 1's logic provides the strongest cut here.\n    if i == 1:\n        return model.u[j] + (n - 3) * model.x[i, j] - model.x[j, i] <= n - 1\n        \n    # 2. Depot-Incoming Case (j=1): Strict Lower Bound on u[i]\n    # If i->1 is used, u[i] must be n. If not, u[i] >= 3.\n    # Parent 1's logic provides the strongest cut here.\n    if j == 1:\n        return model.u[i] - (n - 3) * model.x[i, j] + model.x[j, i] >= 3\n        \n    # 3. Internal Node Case (i, j != 1): Depot-Aware Lifted DL Cut\n    # Parent 2's logic is strictly tighter for internal nodes, using coefficients (n-3)/(n-5)\n    # instead of (n-1)/(n-3) by exploiting the reduced range of u for non-depot-connected nodes.\n    # We incorporate slack terms x[i,1] and x[1,j] to handle boundary conditions validly.\n    return (model.u[i] - model.u[j] + \n            (n - 3) * model.x[i, j] + \n            (n - 5) * model.x[j, i] - \n            model.x[i, 1] - model.x[1, j] <= n - 4)\n\nmodel.complete_lifted_mtz = pyo.Constraint(model.N, model.N, rule=complete_lifted_mtz_rule)",
                        "idea": "This offspring constraint fuses the complementary strengths of both parents into a single, comprehensive cutting plane. It adopts Parent 1's superior boundary logic for depot-adjacent nodes (enforcing strictly tighter bounds $u_j \\in [2, n-1]$ and $u_i \\in [3, n]$) and integrates it with Parent 2's tighter 'internal' lifting logic. By recognizing that internal nodes (unconnected to the depot) have a reduced positional range ($n-4$), the constraint lowers the Big-M coefficients from the standard $(n-1)$ to $(n-3)$ for the majority of the arc matrix, strictly dominating standard Desrochers-Laporte cuts while maintaining validity via depot-connection slack terms."
                    },
                    "fitness": 0.20582165181054227,
                    "solver_reports": [
                        {
                            "gap": 30.9614,
                            "total_time": 11.65,
                            "explored_nodes": 164,
                            "simplex_iterations": 5646,
                            "explored_time": 11.62,
                            "work_units": 10.04
                        },
                        {
                            "total_time": 11.19,
                            "explored_nodes": 1,
                            "simplex_iterations": 1885,
                            "explored_time": 11.13,
                            "work_units": 10.02
                        },
                        {
                            "gap": 18.9834,
                            "total_time": 11.17,
                            "explored_nodes": 200,
                            "simplex_iterations": 6168,
                            "explored_time": 11.15,
                            "work_units": 10.81
                        },
                        {
                            "total_time": 12.4,
                            "explored_nodes": 1,
                            "simplex_iterations": 1390,
                            "explored_time": 12.29,
                            "work_units": 10.15
                        },
                        {
                            "gap": 11.2948,
                            "total_time": 11.87,
                            "explored_nodes": 4501,
                            "simplex_iterations": 63284,
                            "explored_time": 11.84,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.3255,
                            "total_time": 12.56,
                            "explored_nodes": 1,
                            "simplex_iterations": 2539,
                            "explored_time": 12.5,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 1.97,
                            "postsolve": 0.01,
                            "explored_nodes": 26810,
                            "simplex_iterations": 157357,
                            "explored_time": 1.96,
                            "work_units": 1.25
                        },
                        {
                            "gap": 7.1489,
                            "total_time": 12.36,
                            "explored_nodes": 1,
                            "simplex_iterations": 2391,
                            "explored_time": 12.33,
                            "work_units": 10.0
                        },
                        {
                            "gap": 62.0915,
                            "total_time": 11.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 1396,
                            "explored_time": 11.44,
                            "work_units": 10.0
                        },
                        {
                            "gap": 88.3692,
                            "total_time": 13.65,
                            "explored_nodes": 1,
                            "simplex_iterations": 1370,
                            "explored_time": 13.59,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "17fe43c9-9158-4c3b-8282-7cfd9c624e2c",
                        "386fc150-f474-4a3e-85e9-b4867b71b7ad"
                    ]
                },
                {
                    "id": "9e15e7e7-daf0-4004-8a52-e7a2ea2efeee",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def tight_depot_lifted_dl_rule(model, i, j):\n        if i == j:\n            return pyo.Constraint.Skip\n        \n        n = len(model.N)\n        \n        # 1. Tightened Depot-Connection Upper Bound (i=1)\n        # If x[1,j]=1 -> u[j] <= 2. If x[1,j]=0, u[j] <= n-1 (since j cannot be the last node if not connected to 1).\n        if i == 1:\n            return model.u[j] + (n - 3) * model.x[i, j] - model.x[j, i] <= n - 1\n    \n        # 2. Tightened Depot-Connection Lower Bound (j=1)\n        # If x[i,1]=1 -> u[i] >= n. If x[i,1]=0, u[i] >= 3 (since i cannot be the first node if not connected from 1).\n        if j == 1:\n            return model.u[i] - (n - 3) * model.x[i, j] + model.x[j, i] >= 3\n    \n        # 3. Depot-Lifted Desrochers-Laporte (i, j != 1)\n        # Standard DL is u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} <= n-2.\n        # We strengthen this by observing that if i and j are NOT connected to the depot (x[i,1]=0, x[1,j]=0),\n        # then u_i <= n-1 and u_j >= 3, implying u_i - u_j <= n-4.\n        # We enforce this tighter bound (RHS n-4) and lift it with depot arcs x[i,1] and x[1,j] to recover validity for depot-connected paths.\n        return model.u[i] - model.u[j] + (n - 3) * model.x[i, j] + (n - 5) * model.x[j, i] - model.x[i, 1] - model.x[1, j] <= n - 4\n    \n    model.lifted_dl_cuts = pyo.Constraint(model.N, model.N, rule=tight_depot_lifted_dl_rule)\n\n    return model\n",
                        "added_cut": "def tight_depot_lifted_dl_rule(model, i, j):\n    if i == j:\n        return pyo.Constraint.Skip\n    \n    n = len(model.N)\n    \n    # 1. Tightened Depot-Connection Upper Bound (i=1)\n    # If x[1,j]=1 -> u[j] <= 2. If x[1,j]=0, u[j] <= n-1 (since j cannot be the last node if not connected to 1).\n    if i == 1:\n        return model.u[j] + (n - 3) * model.x[i, j] - model.x[j, i] <= n - 1\n\n    # 2. Tightened Depot-Connection Lower Bound (j=1)\n    # If x[i,1]=1 -> u[i] >= n. If x[i,1]=0, u[i] >= 3 (since i cannot be the first node if not connected from 1).\n    if j == 1:\n        return model.u[i] - (n - 3) * model.x[i, j] + model.x[j, i] >= 3\n\n    # 3. Depot-Lifted Desrochers-Laporte (i, j != 1)\n    # Standard DL is u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} <= n-2.\n    # We strengthen this by observing that if i and j are NOT connected to the depot (x[i,1]=0, x[1,j]=0),\n    # then u_i <= n-1 and u_j >= 3, implying u_i - u_j <= n-4.\n    # We enforce this tighter bound (RHS n-4) and lift it with depot arcs x[i,1] and x[1,j] to recover validity for depot-connected paths.\n    return model.u[i] - model.u[j] + (n - 3) * model.x[i, j] + (n - 5) * model.x[j, i] - model.x[i, 1] - model.x[1, j] <= n - 4\n\nmodel.lifted_dl_cuts = pyo.Constraint(model.N, model.N, rule=tight_depot_lifted_dl_rule)",
                        "idea": "This mutation strictly strengthens the Desrochers-Laporte (DL) constraint by lifting it with depot-connectivity variables. Standard DL allows a position difference $u_i - u_j$ of $n-2$; however, for nodes not directly connected to the depot, the tightened bounds $u_i \\le n-1$ and $u_j \\ge 3$ restrict this difference to $n-4$. By reducing the RHS to $n-4$ and the $x_{ij}, x_{ji}$ coefficients to $n-3$ and $n-5$ respectively, and subtracting $x_{i1}$ and $x_{1j}$ to validly relax the constraint only when depot connections exist, the cut eliminates fractional solutions allowed by standard DL in the 'internal' flow of the tour."
                    },
                    "fitness": 0.3788496874796631,
                    "solver_reports": [
                        {
                            "gap": 11.5779,
                            "total_time": 12.57,
                            "explored_nodes": 143,
                            "simplex_iterations": 5061,
                            "explored_time": 12.54,
                            "work_units": 11.51
                        },
                        {
                            "gap": 5.0813,
                            "total_time": 10.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 1289,
                            "explored_time": 10.9,
                            "work_units": 10.0
                        },
                        {
                            "gap": 11.4248,
                            "total_time": 10.55,
                            "explored_nodes": 200,
                            "simplex_iterations": 7330,
                            "explored_time": 10.53,
                            "work_units": 10.08
                        },
                        {
                            "total_time": 11.71,
                            "explored_nodes": 1,
                            "simplex_iterations": 1630,
                            "explored_time": 11.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 2.8107,
                            "total_time": 11.05,
                            "explored_nodes": 2818,
                            "simplex_iterations": 41828,
                            "explored_time": 11.03,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 11.55,
                            "explored_nodes": 1,
                            "simplex_iterations": 1546,
                            "explored_time": 11.49,
                            "work_units": 10.01
                        },
                        {
                            "gap": 0.0,
                            "total_time": 3.48,
                            "postsolve": 0.0,
                            "explored_nodes": 51208,
                            "simplex_iterations": 327024,
                            "explored_time": 3.48,
                            "work_units": 2.35
                        },
                        {
                            "gap": 2.2641,
                            "total_time": 12.99,
                            "explored_nodes": 2267,
                            "simplex_iterations": 41731,
                            "explored_time": 12.98,
                            "work_units": 10.01
                        },
                        {
                            "gap": 78.8026,
                            "total_time": 10.29,
                            "explored_nodes": 1,
                            "simplex_iterations": 1297,
                            "explored_time": 10.25,
                            "work_units": 10.0
                        },
                        {
                            "gap": 88.8425,
                            "total_time": 12.68,
                            "explored_nodes": 1,
                            "simplex_iterations": 1800,
                            "explored_time": 12.62,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Lifted",
                    "parents_id": [
                        "17fe43c9-9158-4c3b-8282-7cfd9c624e2c"
                    ]
                },
                {
                    "id": "c74d9eeb-48bb-47fe-a2cb-46d11416d26f",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Extended Flow-Position Coupling (SCF-MTZ Hybrid)\n    # Introduces auxiliary Single-Commodity Flow (SCF) variables to tighten the MTZ relaxation.\n    # This acts orthogonally to the parents' lifted cuts by enforcing structural flow conservation.\n    \n    # 1. Auxiliary Variables: f[i,j] represents the 'remaining tour load' flowing from i to j.\n    model.f = pyo.Var(model.A, domain=pyo.NonNegativeReals)\n    n = len(model.N)\n    \n    # 2. Flow Capacity: Flow is restricted to active arcs.\n    def flow_capacity_rule(m, i, j):\n        return m.f[i, j] <= (n - 1) * m.x[i, j]\n    model.flow_capacity = pyo.Constraint(model.A, rule=flow_capacity_rule)\n    \n    # 3. Flow Conservation: Each internal node consumes exactly 1 unit of flow.\n    # (Node 1 generates n-1, others consume 1 => Flow In - Flow Out = 1)\n    def flow_conservation_rule(m, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        flow_in = sum(m.f[j, i] for j in m.N if (j, i) in m.A)\n        flow_out = sum(m.f[i, j] for j in m.N if (i, j) in m.A)\n        return flow_in - flow_out == 1\n    model.flow_conservation = pyo.Constraint(model.N, rule=flow_conservation_rule)\n    \n    # 4. Position-Flow Linking: u[i] + Flow_Out[i] == n\n    # This creates a bijection between the visit sequence (u) and network flow (f).\n    # If u[i] is early (small), remaining flow is high. If u[i] is last (n), flow out is 0.\n    def u_flow_link_rule(m, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        flow_out = sum(m.f[i, j] for j in m.N if (i, j) in m.A)\n        return m.u[i] + flow_out == n\n    model.u_flow_link = pyo.Constraint(model.N, rule=u_flow_link_rule)\n\n    return model\n",
                        "added_cut": "# Extended Flow-Position Coupling (SCF-MTZ Hybrid)\n# Introduces auxiliary Single-Commodity Flow (SCF) variables to tighten the MTZ relaxation.\n# This acts orthogonally to the parents' lifted cuts by enforcing structural flow conservation.\n\n# 1. Auxiliary Variables: f[i,j] represents the 'remaining tour load' flowing from i to j.\nmodel.f = pyo.Var(model.A, domain=pyo.NonNegativeReals)\nn = len(model.N)\n\n# 2. Flow Capacity: Flow is restricted to active arcs.\ndef flow_capacity_rule(m, i, j):\n    return m.f[i, j] <= (n - 1) * m.x[i, j]\nmodel.flow_capacity = pyo.Constraint(model.A, rule=flow_capacity_rule)\n\n# 3. Flow Conservation: Each internal node consumes exactly 1 unit of flow.\n# (Node 1 generates n-1, others consume 1 => Flow In - Flow Out = 1)\ndef flow_conservation_rule(m, i):\n    if i == 1:\n        return pyo.Constraint.Skip\n    flow_in = sum(m.f[j, i] for j in m.N if (j, i) in m.A)\n    flow_out = sum(m.f[i, j] for j in m.N if (i, j) in m.A)\n    return flow_in - flow_out == 1\nmodel.flow_conservation = pyo.Constraint(model.N, rule=flow_conservation_rule)\n\n# 4. Position-Flow Linking: u[i] + Flow_Out[i] == n\n# This creates a bijection between the visit sequence (u) and network flow (f).\n# If u[i] is early (small), remaining flow is high. If u[i] is last (n), flow out is 0.\ndef u_flow_link_rule(m, i):\n    if i == 1:\n        return pyo.Constraint.Skip\n    flow_out = sum(m.f[i, j] for j in m.N if (i, j) in m.A)\n    return m.u[i] + flow_out == n\nmodel.u_flow_link = pyo.Constraint(model.N, rule=u_flow_link_rule)",
                        "idea": "This cut implements an 'Extended Flow-Position Coupling' which bridges the parent MTZ logic with a Single-Commodity Flow (SCF) formulation. Unlike the parents that rely on strengthening big-M coefficients (DL-lifting), this approach introduces auxiliary flow variables $f_{ij}$ representing the 'nodes remaining to visit'. The novel linking constraint $u_i + \\sum_j f_{ij} = n$ creates a tight structural bijection between the node potential $u_i$ and the network flow. This eliminates fractional subtours that satisfy algebraic MTZ bounds but violate flow conservation, providing a mathematically distinct and complementary tightening of the relaxation."
                    },
                    "fitness": 0.8106723384065728,
                    "solver_reports": [
                        {
                            "gap": 49.0824,
                            "total_time": 11.37,
                            "explored_nodes": 1,
                            "simplex_iterations": 12346,
                            "explored_time": 11.33,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 9.95,
                            "explored_nodes": 1,
                            "simplex_iterations": 16922,
                            "explored_time": 9.86,
                            "work_units": 10.0
                        },
                        {
                            "gap": 24.4163,
                            "total_time": 11.16,
                            "explored_nodes": 1,
                            "simplex_iterations": 15053,
                            "explored_time": 11.11,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 10.58,
                            "explored_nodes": 1,
                            "simplex_iterations": 20263,
                            "explored_time": 10.48,
                            "work_units": 10.14
                        },
                        {
                            "gap": 11.0054,
                            "total_time": 10.74,
                            "explored_nodes": 1,
                            "simplex_iterations": 20415,
                            "explored_time": 10.72,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 9.39,
                            "explored_nodes": 1,
                            "simplex_iterations": 13292,
                            "explored_time": 9.31,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 1.22,
                            "postsolve": 0.01,
                            "explored_nodes": 164,
                            "simplex_iterations": 6953,
                            "explored_time": 1.22,
                            "work_units": 0.73
                        },
                        {
                            "gap": 24.1982,
                            "total_time": 10.35,
                            "explored_nodes": 1,
                            "simplex_iterations": 14032,
                            "explored_time": 10.3,
                            "work_units": 10.0
                        },
                        {
                            "gap": 11.7156,
                            "total_time": 11.02,
                            "explored_nodes": 1,
                            "simplex_iterations": 14564,
                            "explored_time": 10.95,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 9.59,
                            "explored_nodes": 1,
                            "simplex_iterations": 11569,
                            "explored_time": 9.51,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "5b4cc02b-6c23-4336-912f-1b88b08484a0",
                        "17fe43c9-9158-4c3b-8282-7cfd9c624e2c"
                    ]
                },
                {
                    "id": "97d2b1a1-6c32-429b-9b34-00eadbe058fe",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Strong Perimeter & Depot-Interactive DL Formulation\n    # Integrates Parent 1's explicit variable bounds with Parent 2's tighter lifting logic.\n    \n    n = len(model.N)\n    \n    # 1. Strong Perimeter Bounds (From Parent 1)\n    # Constrains u[i] based on depot connectivity. \n    # Internal nodes are forced into [3, n-1], while start/end nodes are pinned to 2 and n.\n    \n    def strong_perimeter_lb(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        # If 1->i, u[i]>=2; If i->1, u[i]>=n; Else u[i]>=3\n        return m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1]\n    model.strong_perimeter_lb = pyo.Constraint(model.N, rule=strong_perimeter_lb)\n    \n    def strong_perimeter_ub(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        # If 1->i, u[i]<=2; If i->1, u[i]<=n; Else u[i]<=n-1\n        return m.u[i] <= (n - 1) + m.x[i, 1] - (n - 3) * m.x[1, i]\n    model.strong_perimeter_ub = pyo.Constraint(model.N, rule=strong_perimeter_ub)\n    \n    # 2. Depot-Interactive Lifted DL Cuts (From Parent 2)\n    # Replaces standard MTZ/DL with a tighter version for internal nodes.\n    # Because the bounds above ensure internal nodes have a range of size (n-4),\n    # we can reduce the Big-M coefficient from (n-1) to (n-3).\n    \n    def depot_lifted_dl_rule(m, i, j):\n        # Apply only for distinct non-depot nodes\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        \n        # Formula: u[i] - u[j] + (n-3)x[i,j] + (n-5)x[j,i] - x[i,1] - x[1,j] <= n - 4\n        return (m.u[i] - m.u[j] + \n                (n - 3) * m.x[i, j] + \n                (n - 5) * m.x[j, i] - \n                m.x[i, 1] - m.x[1, j] <= n - 4)\n    \n    model.depot_lifted_dl = pyo.Constraint(model.N, model.N, rule=depot_lifted_dl_rule)\n\n    return model\n",
                        "added_cut": "# Strong Perimeter & Depot-Interactive DL Formulation\n# Integrates Parent 1's explicit variable bounds with Parent 2's tighter lifting logic.\n\nn = len(model.N)\n\n# 1. Strong Perimeter Bounds (From Parent 1)\n# Constrains u[i] based on depot connectivity. \n# Internal nodes are forced into [3, n-1], while start/end nodes are pinned to 2 and n.\n\ndef strong_perimeter_lb(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    # If 1->i, u[i]>=2; If i->1, u[i]>=n; Else u[i]>=3\n    return m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1]\nmodel.strong_perimeter_lb = pyo.Constraint(model.N, rule=strong_perimeter_lb)\n\ndef strong_perimeter_ub(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    # If 1->i, u[i]<=2; If i->1, u[i]<=n; Else u[i]<=n-1\n    return m.u[i] <= (n - 1) + m.x[i, 1] - (n - 3) * m.x[1, i]\nmodel.strong_perimeter_ub = pyo.Constraint(model.N, rule=strong_perimeter_ub)\n\n# 2. Depot-Interactive Lifted DL Cuts (From Parent 2)\n# Replaces standard MTZ/DL with a tighter version for internal nodes.\n# Because the bounds above ensure internal nodes have a range of size (n-4),\n# we can reduce the Big-M coefficient from (n-1) to (n-3).\n\ndef depot_lifted_dl_rule(m, i, j):\n    # Apply only for distinct non-depot nodes\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    \n    # Formula: u[i] - u[j] + (n-3)x[i,j] + (n-5)x[j,i] - x[i,1] - x[1,j] <= n - 4\n    return (m.u[i] - m.u[j] + \n            (n - 3) * m.x[i, j] + \n            (n - 5) * m.x[j, i] - \n            m.x[i, 1] - m.x[1, j] <= n - 4)\n\nmodel.depot_lifted_dl = pyo.Constraint(model.N, model.N, rule=depot_lifted_dl_rule)",
                        "idea": "This hybrid cut combines the explicit domain reduction of Parent 1 with the tightened lifting coefficients of Parent 2. By enforcing 'Strong Perimeter Bounds', we guarantee that any node not connected to the depot lies in the potential range $[3, n-1]$ (a span of $n-4$). This reduced span validates the 'Depot-Interactive Lifted DL' constraints, which reduce the Big-M coefficient on $x_{i,j}$ from the standard $n-1$ to $n-3$. Slack variables $x_{i,1}$ and $x_{1,j}$ are added to the RHS to relax the constraint only when nodes connect to the depot, ensuring the tightest possible valid inequality for the majority of the search space."
                    },
                    "fitness": 0.6100775269609047,
                    "solver_reports": [
                        {
                            "gap": 21.1095,
                            "total_time": 10.79,
                            "explored_nodes": 59,
                            "simplex_iterations": 2997,
                            "explored_time": 10.77,
                            "work_units": 10.24
                        },
                        {
                            "gap": 13.3113,
                            "total_time": 10.94,
                            "explored_nodes": 1,
                            "simplex_iterations": 2082,
                            "explored_time": 10.85,
                            "work_units": 10.01
                        },
                        {
                            "gap": 14.3734,
                            "total_time": 10.12,
                            "explored_nodes": 87,
                            "simplex_iterations": 2838,
                            "explored_time": 10.09,
                            "work_units": 10.27
                        },
                        {
                            "total_time": 11.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 1514,
                            "explored_time": 11.59,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.3969,
                            "total_time": 11.24,
                            "explored_nodes": 3989,
                            "simplex_iterations": 53119,
                            "explored_time": 11.22,
                            "work_units": 10.0
                        },
                        {
                            "gap": 90.1687,
                            "total_time": 11.0,
                            "explored_nodes": 1,
                            "simplex_iterations": 1457,
                            "explored_time": 10.95,
                            "work_units": 10.01
                        },
                        {
                            "gap": 0.0,
                            "total_time": 5.04,
                            "postsolve": 0.0,
                            "explored_nodes": 74467,
                            "simplex_iterations": 499175,
                            "explored_time": 5.04,
                            "work_units": 3.54
                        },
                        {
                            "gap": 4.9653,
                            "total_time": 10.31,
                            "explored_nodes": 143,
                            "simplex_iterations": 8147,
                            "explored_time": 10.29,
                            "work_units": 10.06
                        },
                        {
                            "gap": 17.1954,
                            "total_time": 10.79,
                            "explored_nodes": 1,
                            "simplex_iterations": 1378,
                            "explored_time": 10.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 87.532,
                            "total_time": 12.46,
                            "explored_nodes": 1,
                            "simplex_iterations": 1735,
                            "explored_time": 12.39,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "5b4cc02b-6c23-4336-912f-1b88b08484a0",
                        "386fc150-f474-4a3e-85e9-b4867b71b7ad"
                    ]
                },
                {
                    "id": "8676aaf5-bee8-4e26-8f23-adf6c59abcab",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # 3. Global Permutation Sum Constraint\n    # This constraint strengthens the relaxation by enforcing that the sum of position variables u[i]\n    # must equal the sum of the sequence 1..n, which is n(n+1)/2. This is valid because u[i] values\n    # in any integer-feasible tour are exactly the set {1, ..., n}.\n    \n    def global_permutation_sum_rule(m):\n        # Calculate n based on the set N to ensure robustness\n        N_val = len(m.N)\n        return sum(m.u[i] for i in m.N) == (N_val * (N_val + 1)) / 2\n    \n    model.global_permutation_sum = pyo.Constraint(rule=global_permutation_sum_rule)\n\n    return model\n",
                        "added_cut": "# 3. Global Permutation Sum Constraint\n# This constraint strengthens the relaxation by enforcing that the sum of position variables u[i]\n# must equal the sum of the sequence 1..n, which is n(n+1)/2. This is valid because u[i] values\n# in any integer-feasible tour are exactly the set {1, ..., n}.\n\ndef global_permutation_sum_rule(m):\n    # Calculate n based on the set N to ensure robustness\n    N_val = len(m.N)\n    return sum(m.u[i] for i in m.N) == (N_val * (N_val + 1)) / 2\n\nmodel.global_permutation_sum = pyo.Constraint(rule=global_permutation_sum_rule)",
                        "idea": "The provided individual introduces 'Strong Perimeter' bounds and DL lifted cuts, which constrain the u variables locally and pairwise. However, the LP relaxation can still exploit the gaps by assigning fractional u values that satisfy difference constraints but don't form a permutation. The 'Global Permutation Sum' constraint (sum(u) = n(n+1)/2) acts as a global cut, enforcing the necessary aggregate value of the potentials, thereby chopping off these fractional solutions and tightening the dual bounds."
                    },
                    "fitness": 1.3133586149742393,
                    "solver_reports": [
                        {
                            "gap": 17.9989,
                            "total_time": 11.47,
                            "explored_nodes": 4686,
                            "simplex_iterations": 74993,
                            "explored_time": 11.46,
                            "work_units": 10.01
                        },
                        {
                            "gap": 28.6605,
                            "total_time": 13.33,
                            "explored_nodes": 1,
                            "simplex_iterations": 7207,
                            "explored_time": 13.27,
                            "work_units": 10.0
                        },
                        {
                            "gap": 19.2413,
                            "total_time": 10.23,
                            "explored_nodes": 171,
                            "simplex_iterations": 12839,
                            "explored_time": 10.21,
                            "work_units": 10.66
                        },
                        {
                            "total_time": 15.84,
                            "explored_nodes": 1,
                            "simplex_iterations": 3449,
                            "explored_time": 15.75,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.624,
                            "total_time": 10.75,
                            "explored_nodes": 9522,
                            "simplex_iterations": 95669,
                            "explored_time": 10.73,
                            "work_units": 10.0
                        },
                        {
                            "gap": 59.6158,
                            "total_time": 13.59,
                            "explored_nodes": 59,
                            "simplex_iterations": 7790,
                            "explored_time": 13.56,
                            "work_units": 10.48
                        },
                        {
                            "gap": 4.563,
                            "total_time": 13.66,
                            "explored_nodes": 230058,
                            "simplex_iterations": 1428176,
                            "explored_time": 13.65,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.7335,
                            "total_time": 9.34,
                            "explored_nodes": 2961,
                            "simplex_iterations": 53320,
                            "explored_time": 9.33,
                            "work_units": 10.03
                        },
                        {
                            "gap": 17.248,
                            "total_time": 12.71,
                            "explored_nodes": 59,
                            "simplex_iterations": 7754,
                            "explored_time": 12.68,
                            "work_units": 11.93
                        },
                        {
                            "gap": 39.8359,
                            "total_time": 12.67,
                            "explored_nodes": 115,
                            "simplex_iterations": 10111,
                            "explored_time": 12.64,
                            "work_units": 10.13
                        }
                    ],
                    "generator": "General",
                    "parents_id": [
                        "5b4cc02b-6c23-4336-912f-1b88b08484a0"
                    ]
                },
                {
                    "id": "5fd8394c-000c-4c24-9157-ca11f4f75f23",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Depot-Anchored Position Bounds\n    # These constraints tighten the continuous relaxation of the MTZ position variables (u)\n    # by explicitly linking them to the depot's immediate successors and predecessors.\n    # This acts as a boundary condition enforcement for the tour.\n    \n    def depot_lb_rule(model, i):\n        # For any non-depot node i:\n        # If i is visited immediately after depot (x[1,i]=1), u[i] >= 2.\n        # If i is NOT visited immediately after depot (x[1,i]=0), it must be at least 3rd in tour (u[i] >= 3).\n        # Combined: u[i] >= 3 - x[1,i]  =>  u[i] + x[1,i] >= 3\n        if i == 1:\n            return pyo.Constraint.Skip\n        return model.u[i] + model.x[1, i] >= 3\n    \n    model.depot_pos_lb = pyo.Constraint(model.N, rule=depot_lb_rule)\n    \n    def depot_ub_rule(model, i):\n        # For any non-depot node i:\n        # If i visits depot immediately (x[i,1]=1), u[i] <= n.\n        # If i does NOT visit depot immediately (x[i,1]=0), it cannot be the last node (u[i] <= n-1).\n        # Combined: u[i] <= (n-1) + x[i,1]  =>  u[i] - x[i,1] <= n - 1\n        if i == 1:\n            return pyo.Constraint.Skip\n        return model.u[i] - model.x[i, 1] <= n - 1\n    \n    model.depot_pos_ub = pyo.Constraint(model.N, rule=depot_ub_rule)\n\n    return model\n",
                        "added_cut": "# Depot-Anchored Position Bounds\n# These constraints tighten the continuous relaxation of the MTZ position variables (u)\n# by explicitly linking them to the depot's immediate successors and predecessors.\n# This acts as a boundary condition enforcement for the tour.\n\ndef depot_lb_rule(model, i):\n    # For any non-depot node i:\n    # If i is visited immediately after depot (x[1,i]=1), u[i] >= 2.\n    # If i is NOT visited immediately after depot (x[1,i]=0), it must be at least 3rd in tour (u[i] >= 3).\n    # Combined: u[i] >= 3 - x[1,i]  =>  u[i] + x[1,i] >= 3\n    if i == 1:\n        return pyo.Constraint.Skip\n    return model.u[i] + model.x[1, i] >= 3\n\nmodel.depot_pos_lb = pyo.Constraint(model.N, rule=depot_lb_rule)\n\ndef depot_ub_rule(model, i):\n    # For any non-depot node i:\n    # If i visits depot immediately (x[i,1]=1), u[i] <= n.\n    # If i does NOT visit depot immediately (x[i,1]=0), it cannot be the last node (u[i] <= n-1).\n    # Combined: u[i] <= (n-1) + x[i,1]  =>  u[i] - x[i,1] <= n - 1\n    if i == 1:\n        return pyo.Constraint.Skip\n    return model.u[i] - model.x[i, 1] <= n - 1\n\nmodel.depot_pos_ub = pyo.Constraint(model.N, rule=depot_ub_rule)",
                        "idea": "We introduce Depot-Anchored Position Bounds. While Parent 1 focuses on local cycle elimination and Parent 2 on 2-hop internal spacing, this offspring targets the global boundary conditions of the tour sequence. By logically linking the position variable u[i] to the depot connections x[1,i] and x[i,1], it tightens the domain of u specifically for nodes not adjacent to the depot (forcing u[i] >= 3 or u[i] <= n-1). This complements the parents by reducing the 'floating' behavior of position variables in the linear relaxation."
                    },
                    "fitness": 4.97969605589386,
                    "solver_reports": [
                        {
                            "gap": 9.7803,
                            "total_time": 13.03,
                            "explored_nodes": 3719,
                            "simplex_iterations": 58016,
                            "explored_time": 13.0,
                            "work_units": 10.0
                        },
                        {
                            "gap": 46.1022,
                            "total_time": 12.0,
                            "explored_nodes": 1,
                            "simplex_iterations": 6358,
                            "explored_time": 11.95,
                            "work_units": 10.0
                        },
                        {
                            "gap": 21.3155,
                            "total_time": 12.12,
                            "explored_nodes": 563,
                            "simplex_iterations": 18783,
                            "explored_time": 12.1,
                            "work_units": 11.05
                        },
                        {
                            "gap": 45.3316,
                            "total_time": 14.64,
                            "explored_nodes": 1,
                            "simplex_iterations": 3380,
                            "explored_time": 14.58,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1116,
                            "total_time": 11.48,
                            "explored_nodes": 2835,
                            "simplex_iterations": 62062,
                            "explored_time": 11.45,
                            "work_units": 10.01
                        },
                        {
                            "gap": 28.1667,
                            "total_time": 13.65,
                            "explored_nodes": 114,
                            "simplex_iterations": 9461,
                            "explored_time": 13.62,
                            "work_units": 10.11
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.07,
                            "explored_nodes": 291399,
                            "simplex_iterations": 1867312,
                            "explored_time": 13.06,
                            "work_units": 10.04
                        },
                        {
                            "gap": 7.8072,
                            "total_time": 10.74,
                            "explored_nodes": 4408,
                            "simplex_iterations": 67802,
                            "explored_time": 10.71,
                            "work_units": 10.0
                        },
                        {
                            "gap": 21.5371,
                            "total_time": 11.57,
                            "explored_nodes": 59,
                            "simplex_iterations": 5897,
                            "explored_time": 11.54,
                            "work_units": 11.14
                        },
                        {
                            "gap": 5.387,
                            "total_time": 14.89,
                            "explored_nodes": 87,
                            "simplex_iterations": 8137,
                            "explored_time": 14.85,
                            "work_units": 12.18
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "b86b6dfa-ed88-4fdd-ab6b-26c539ba9113"
                    ]
                }
            ],
            10.353038952236112
        ],
        [
            [
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "8d3ea118-3dfe-4fd2-a52e-9d17f5567521",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Accumulated Position Flow (Forward Gouveia-Pires Lifting)\n    # Complements Parent 1's \"Remaining Flow\" (Backward) logic by modeling \"Accumulated Rank\".\n    # This creates a structural \"sandwich\" for potentials: FlowIn(i) == u[i] == n - FlowOut_Parent1(i).\n    \n    n = len(model.N)\n    # 1. Auxiliary Variable: z[i,j] represents the 'accumulated position' (u[j]) carried by arc (i,j).\n    model.z = pyo.Var(model.A, domain=pyo.NonNegativeReals)\n    \n    # 2. Boundary Definitions for Depot Connections\n    # Arc 1->j: Node j is always at position 2 in the tour.\n    def z_depot_out_rule(m, j):\n        return m.z[1, j] == 2 * m.x[1, j]\n    model.z_depot_out = pyo.Constraint(model.N, rule=lambda m, j: z_depot_out_rule(m, j) if j != 1 else pyo.Constraint.Skip)\n    \n    # Arc i->1: Node i is at position n; virtual return step carries n+1 to close the loop.\n    def z_depot_in_rule(m, i):\n        return m.z[i, 1] == (n + 1) * m.x[i, 1]\n    model.z_depot_in = pyo.Constraint(model.N, rule=lambda m, i: z_depot_in_rule(m, i) if i != 1 else pyo.Constraint.Skip)\n    \n    # 3. Capacity Constraints for Internal Arcs\n    # For internal arcs, flow z[i,j] equals u[j], which is bounded by n.\n    def z_capacity_rule(m, i, j):\n        if i == 1 or j == 1:\n            return pyo.Constraint.Skip\n        return m.z[i, j] <= n * m.x[i, j]\n    model.z_capacity = pyo.Constraint(model.A, rule=z_capacity_rule)\n    \n    # 4. Positional Linking (Flow In)\n    # The sum of rank-flow entering node i defines its position u[i].\n    def z_link_in_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        flow_in = sum(m.z[k, i] for k in m.N if (k, i) in m.A)\n        return flow_in == m.u[i]\n    model.z_link_in = pyo.Constraint(model.N, rule=z_link_in_rule)\n    \n    # 5. Sequential Growth (Flow Out)\n    # The sum of rank-flow leaving node i must be u[i] + 1 (since u[succ] = u[curr] + 1).\n    def z_link_out_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        flow_out = sum(m.z[i, j] for j in m.N if (i, j) in m.A)\n        return flow_out == m.u[i] + 1\n    model.z_link_out = pyo.Constraint(model.N, rule=z_link_out_rule)\n\n    return model\n",
                        "added_cut": "# Accumulated Position Flow (Forward Gouveia-Pires Lifting)\n# Complements Parent 1's \"Remaining Flow\" (Backward) logic by modeling \"Accumulated Rank\".\n# This creates a structural \"sandwich\" for potentials: FlowIn(i) == u[i] == n - FlowOut_Parent1(i).\n\nn = len(model.N)\n# 1. Auxiliary Variable: z[i,j] represents the 'accumulated position' (u[j]) carried by arc (i,j).\nmodel.z = pyo.Var(model.A, domain=pyo.NonNegativeReals)\n\n# 2. Boundary Definitions for Depot Connections\n# Arc 1->j: Node j is always at position 2 in the tour.\ndef z_depot_out_rule(m, j):\n    return m.z[1, j] == 2 * m.x[1, j]\nmodel.z_depot_out = pyo.Constraint(model.N, rule=lambda m, j: z_depot_out_rule(m, j) if j != 1 else pyo.Constraint.Skip)\n\n# Arc i->1: Node i is at position n; virtual return step carries n+1 to close the loop.\ndef z_depot_in_rule(m, i):\n    return m.z[i, 1] == (n + 1) * m.x[i, 1]\nmodel.z_depot_in = pyo.Constraint(model.N, rule=lambda m, i: z_depot_in_rule(m, i) if i != 1 else pyo.Constraint.Skip)\n\n# 3. Capacity Constraints for Internal Arcs\n# For internal arcs, flow z[i,j] equals u[j], which is bounded by n.\ndef z_capacity_rule(m, i, j):\n    if i == 1 or j == 1:\n        return pyo.Constraint.Skip\n    return m.z[i, j] <= n * m.x[i, j]\nmodel.z_capacity = pyo.Constraint(model.A, rule=z_capacity_rule)\n\n# 4. Positional Linking (Flow In)\n# The sum of rank-flow entering node i defines its position u[i].\ndef z_link_in_rule(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    flow_in = sum(m.z[k, i] for k in m.N if (k, i) in m.A)\n    return flow_in == m.u[i]\nmodel.z_link_in = pyo.Constraint(model.N, rule=z_link_in_rule)\n\n# 5. Sequential Growth (Flow Out)\n# The sum of rank-flow leaving node i must be u[i] + 1 (since u[succ] = u[curr] + 1).\ndef z_link_out_rule(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    flow_out = sum(m.z[i, j] for j in m.N if (i, j) in m.A)\n    return flow_out == m.u[i] + 1\nmodel.z_link_out = pyo.Constraint(model.N, rule=z_link_out_rule)",
                        "idea": "This cut implements 'Accumulated Position Flow', a forward-looking counterpart to Parent 1's backward 'Remaining Flow'. It introduces auxiliary variables $z_{ij}$ representing the accumulated rank $u_j$ carried along active arcs. By strictly enforcing that In-Flow equals $u_i$ and Out-Flow equals $u_i + 1$, the formulation converts the loose MTZ inequalities ($u_j \\ge u_i + 1$) into tight flow-based equalities ($u_j = u_i + 1$) for active paths. Combined with 'Virtual Return' flow ($n+1$) on arcs returning to the depot, this creates a rigid 'flow sandwich' that complements Parent 1 (pinning $u$ from both rank-accumulation and rank-remaining perspectives) and Parent 2 (which operates on bound lifting) to eliminate fractional subtours."
                    },
                    "fitness": 5.384276003085686,
                    "solver_reports": [
                        {
                            "gap": 39.52,
                            "total_time": 11.9,
                            "explored_nodes": 1,
                            "simplex_iterations": 11707,
                            "explored_time": 11.83,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 11.32,
                            "explored_nodes": 1,
                            "simplex_iterations": 17616,
                            "explored_time": 11.24,
                            "work_units": 10.0
                        },
                        {
                            "gap": 8.9816,
                            "total_time": 11.78,
                            "explored_nodes": 1,
                            "simplex_iterations": 12454,
                            "explored_time": 11.73,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 10.2,
                            "explored_nodes": 1,
                            "simplex_iterations": 20906,
                            "explored_time": 10.09,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1359,
                            "total_time": 12.57,
                            "explored_nodes": 179,
                            "simplex_iterations": 67457,
                            "explored_time": 12.56,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 10.43,
                            "explored_nodes": 1,
                            "simplex_iterations": 13585,
                            "explored_time": 10.33,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 1.85,
                            "postsolve": 0.01,
                            "explored_nodes": 364,
                            "simplex_iterations": 16799,
                            "explored_time": 1.85,
                            "work_units": 1.1
                        },
                        {
                            "gap": 5.7688,
                            "total_time": 11.89,
                            "explored_nodes": 1,
                            "simplex_iterations": 11698,
                            "explored_time": 11.83,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 9.29,
                            "explored_nodes": 1,
                            "simplex_iterations": 9775,
                            "explored_time": 9.22,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 10.18,
                            "explored_nodes": 1,
                            "simplex_iterations": 11726,
                            "explored_time": 10.1,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "c74d9eeb-48bb-47fe-a2cb-46d11416d26f",
                        "97d2b1a1-6c32-429b-9b34-00eadbe058fe"
                    ]
                },
                {
                    "id": "2d4d607d-bfa3-4813-b125-8951ee9fa86e",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Strengthened Permutation Logic\n    # 1. Global Permutation Sum (Retained): Enforces that position variables sum to the triangular number n(n+1)/2.\n    model.global_u_sum = pyo.Constraint(expr=sum(model.u[i] for i in model.N) == (n * (n + 1)) // 2)\n    \n    # 2. Depot-Coupled Bounds (Mutation): Tighten u bounds based on connectivity to the depot (Node 1).\n    # These constraints force u[i] to its logical limit if node i is the first or last visited node.\n    \n    # If arc (1, i) is used, i is the 2nd node visited => u[i] must be 2.\n    # Rule: u[i] <= n - (n - 2) * x[1, i]\n    # Check: If x[1,i]=1 -> u[i]<=2 (and u>=2 implies u=2). If x[1,i]=0 -> u[i]<=n (valid).\n    def start_coupling_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        return m.u[i] <= n - (n - 2) * m.x[1, i]\n    model.u_start_coupling = pyo.Constraint(model.N, rule=start_coupling_rule)\n    \n    # If arc (i, 1) is used, i is the last node visited => u[i] must be n.\n    # Rule: u[i] >= 2 + (n - 2) * x[i, 1]\n    # Check: If x[i,1]=1 -> u[i]>=n (and u<=n implies u=n). If x[i,1]=0 -> u[i]>=2 (valid).\n    def end_coupling_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        return m.u[i] >= 2 + (n - 2) * m.x[i, 1]\n    model.u_end_coupling = pyo.Constraint(model.N, rule=end_coupling_rule)\n\n    return model\n",
                        "added_cut": "# Strengthened Permutation Logic\n# 1. Global Permutation Sum (Retained): Enforces that position variables sum to the triangular number n(n+1)/2.\nmodel.global_u_sum = pyo.Constraint(expr=sum(model.u[i] for i in model.N) == (n * (n + 1)) // 2)\n\n# 2. Depot-Coupled Bounds (Mutation): Tighten u bounds based on connectivity to the depot (Node 1).\n# These constraints force u[i] to its logical limit if node i is the first or last visited node.\n\n# If arc (1, i) is used, i is the 2nd node visited => u[i] must be 2.\n# Rule: u[i] <= n - (n - 2) * x[1, i]\n# Check: If x[1,i]=1 -> u[i]<=2 (and u>=2 implies u=2). If x[1,i]=0 -> u[i]<=n (valid).\ndef start_coupling_rule(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    return m.u[i] <= n - (n - 2) * m.x[1, i]\nmodel.u_start_coupling = pyo.Constraint(model.N, rule=start_coupling_rule)\n\n# If arc (i, 1) is used, i is the last node visited => u[i] must be n.\n# Rule: u[i] >= 2 + (n - 2) * x[i, 1]\n# Check: If x[i,1]=1 -> u[i]>=n (and u<=n implies u=n). If x[i,1]=0 -> u[i]>=2 (valid).\ndef end_coupling_rule(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    return m.u[i] >= 2 + (n - 2) * m.x[i, 1]\nmodel.u_end_coupling = pyo.Constraint(model.N, rule=end_coupling_rule)",
                        "idea": "The original cut enforces a global property (the sum of ranks), but allows 'loose' values locally. The mutation strengthens this by adding Depot-Coupled Bounds, which enforce the boundary conditions of the permutation sequence. Specifically, in any valid tour, the node immediately following the depot must have position 2 ($x_{1i}=1 \\implies u_i=2$) and the node preceding it must have position $n$ ($x_{i1}=1 \\implies u_i=n$). These cuts prune fractional solutions where $u$ values drift from their logical endpoints, complementing the global sum constraint."
                    },
                    "fitness": 2.4955156293822514,
                    "solver_reports": [
                        {
                            "gap": 13.7379,
                            "total_time": 11.26,
                            "explored_nodes": 4797,
                            "simplex_iterations": 54470,
                            "explored_time": 11.25,
                            "work_units": 10.05
                        },
                        {
                            "gap": 43.3,
                            "total_time": 12.26,
                            "explored_nodes": 1,
                            "simplex_iterations": 7637,
                            "explored_time": 12.2,
                            "work_units": 10.0
                        },
                        {
                            "gap": 9.748,
                            "total_time": 11.56,
                            "explored_nodes": 801,
                            "simplex_iterations": 18789,
                            "explored_time": 11.55,
                            "work_units": 10.03
                        },
                        {
                            "gap": 92.0264,
                            "total_time": 13.7,
                            "explored_nodes": 1,
                            "simplex_iterations": 3856,
                            "explored_time": 13.62,
                            "work_units": 10.0
                        },
                        {
                            "gap": 2.5185,
                            "total_time": 13.3,
                            "explored_nodes": 3102,
                            "simplex_iterations": 71982,
                            "explored_time": 13.3,
                            "work_units": 11.0
                        },
                        {
                            "gap": 75.7476,
                            "total_time": 13.1,
                            "explored_nodes": 59,
                            "simplex_iterations": 9516,
                            "explored_time": 13.06,
                            "work_units": 10.79
                        },
                        {
                            "gap": 4.0068,
                            "total_time": 13.24,
                            "explored_nodes": 279937,
                            "simplex_iterations": 1885324,
                            "explored_time": 13.24,
                            "work_units": 10.01
                        },
                        {
                            "gap": 3.6475,
                            "total_time": 9.31,
                            "explored_nodes": 1377,
                            "simplex_iterations": 47481,
                            "explored_time": 9.3,
                            "work_units": 10.03
                        },
                        {
                            "gap": 33.8403,
                            "total_time": 12.25,
                            "explored_nodes": 171,
                            "simplex_iterations": 13787,
                            "explored_time": 12.23,
                            "work_units": 10.33
                        },
                        {
                            "gap": 34.3464,
                            "total_time": 12.19,
                            "explored_nodes": 1,
                            "simplex_iterations": 6325,
                            "explored_time": 12.15,
                            "work_units": 10.06
                        }
                    ],
                    "generator": "General",
                    "parents_id": [
                        "8676aaf5-bee8-4e26-8f23-adf6c59abcab"
                    ]
                },
                {
                    "id": "702d77e6-dd3c-4a92-8018-61487927a7e6",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    n = len(model.N)\n    \n    # 1. Global Permutation Sum (From Parent 2)\n    # This constraint enforces the aggregate 'center of mass' for the position variables.\n    # Since u defines a permutation of 1..n, its sum must be n(n+1)/2. This global cut\n    # effectively prunes fractional solutions that satisfy local differences but not the total magnitude.\n    def global_permutation_sum_rule(m):\n        return sum(m.u[i] for i in m.N) == (n * (n + 1)) / 2\n    model.global_permutation_sum = pyo.Constraint(rule=global_permutation_sum_rule)\n    \n    # 2. Strong Perimeter Bounds (From Parent 1)\n    # These constraints tighten the domain of u[i] based on immediate connectivity to the depot.\n    # By coupling u[i] with x[1,i] and x[i,1], we force u[i]=2 for the first visited node \n    # and u[i]=n for the last, while restricting intermediate nodes to [3, n-1].\n    # This provides local tightening that complements the global sum constraint.\n    \n    def strong_perimeter_lb(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        # LB: If 1->i then u>=2; If i->1 then u>=n; Else u>=3\n        return m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1]\n    model.strong_perimeter_lb = pyo.Constraint(model.N, rule=strong_perimeter_lb)\n    \n    def strong_perimeter_ub(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        # UB: If 1->i then u<=2; If i->1 then u<=n; Else u<=n-1\n        return m.u[i] <= (n - 1) + m.x[i, 1] - (n - 3) * m.x[1, i]\n    model.strong_perimeter_ub = pyo.Constraint(model.N, rule=strong_perimeter_ub)\n\n    return model\n",
                        "added_cut": "n = len(model.N)\n\n# 1. Global Permutation Sum (From Parent 2)\n# This constraint enforces the aggregate 'center of mass' for the position variables.\n# Since u defines a permutation of 1..n, its sum must be n(n+1)/2. This global cut\n# effectively prunes fractional solutions that satisfy local differences but not the total magnitude.\ndef global_permutation_sum_rule(m):\n    return sum(m.u[i] for i in m.N) == (n * (n + 1)) / 2\nmodel.global_permutation_sum = pyo.Constraint(rule=global_permutation_sum_rule)\n\n# 2. Strong Perimeter Bounds (From Parent 1)\n# These constraints tighten the domain of u[i] based on immediate connectivity to the depot.\n# By coupling u[i] with x[1,i] and x[i,1], we force u[i]=2 for the first visited node \n# and u[i]=n for the last, while restricting intermediate nodes to [3, n-1].\n# This provides local tightening that complements the global sum constraint.\n\ndef strong_perimeter_lb(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    # LB: If 1->i then u>=2; If i->1 then u>=n; Else u>=3\n    return m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1]\nmodel.strong_perimeter_lb = pyo.Constraint(model.N, rule=strong_perimeter_lb)\n\ndef strong_perimeter_ub(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    # UB: If 1->i then u<=2; If i->1 then u<=n; Else u<=n-1\n    return m.u[i] <= (n - 1) + m.x[i, 1] - (n - 3) * m.x[1, i]\nmodel.strong_perimeter_ub = pyo.Constraint(model.N, rule=strong_perimeter_ub)",
                        "idea": "This hybrid formulation combines the high-fitness 'Global Permutation Sum' from Parent 2 with the locally tightening 'Strong Perimeter Bounds' from Parent 1. The global sum constraint acts as a powerful valid inequality that anchors the aggregate value of the position variables $u$, preventing fractional drift allowed by standard MTZ difference constraints. The perimeter bounds complement this by explicitly restricting the domain of $u_i$ based on depot connectivity (forcing start/end nodes to $2$ and $n$, and internal nodes to $[3, n-1]$). This combination retains the most robust and efficient components of both parentsdiscarding the computationally expensive $O(n^2)$ lifted DL cuts from Parent 1to create a tighter, low-overhead relaxation."
                    },
                    "fitness": 3.794992568521715,
                    "solver_reports": [
                        {
                            "gap": 20.8971,
                            "total_time": 11.98,
                            "explored_nodes": 2316,
                            "simplex_iterations": 39799,
                            "explored_time": 11.96,
                            "work_units": 11.58
                        },
                        {
                            "gap": 48.9726,
                            "total_time": 11.79,
                            "explored_nodes": 1,
                            "simplex_iterations": 6307,
                            "explored_time": 11.73,
                            "work_units": 10.0
                        },
                        {
                            "gap": 5.4918,
                            "total_time": 11.05,
                            "explored_nodes": 1045,
                            "simplex_iterations": 29406,
                            "explored_time": 11.04,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.75,
                            "explored_nodes": 1,
                            "simplex_iterations": 3243,
                            "explored_time": 13.68,
                            "work_units": 10.0
                        },
                        {
                            "gap": 5.3314,
                            "total_time": 11.17,
                            "explored_nodes": 2873,
                            "simplex_iterations": 46302,
                            "explored_time": 11.15,
                            "work_units": 10.0
                        },
                        {
                            "gap": 48.5673,
                            "total_time": 12.38,
                            "explored_nodes": 7,
                            "simplex_iterations": 5079,
                            "explored_time": 12.35,
                            "work_units": 10.05
                        },
                        {
                            "gap": 4.8196,
                            "total_time": 13.51,
                            "explored_nodes": 200944,
                            "simplex_iterations": 1321598,
                            "explored_time": 13.5,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.596,
                            "total_time": 10.49,
                            "explored_nodes": 3620,
                            "simplex_iterations": 57345,
                            "explored_time": 10.46,
                            "work_units": 10.0
                        },
                        {
                            "gap": 35.761,
                            "total_time": 10.47,
                            "explored_nodes": 87,
                            "simplex_iterations": 7356,
                            "explored_time": 10.43,
                            "work_units": 10.6
                        },
                        {
                            "gap": 6.2436,
                            "total_time": 13.05,
                            "explored_nodes": 87,
                            "simplex_iterations": 9093,
                            "explored_time": 13.03,
                            "work_units": 12.26
                        }
                    ],
                    "generator": "Min_Violation",
                    "parents_id": [
                        "97d2b1a1-6c32-429b-9b34-00eadbe058fe",
                        "8676aaf5-bee8-4e26-8f23-adf6c59abcab"
                    ]
                },
                {
                    "id": "839269d3-0acc-47be-97c7-a587d2afd46d",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def lifted_mtz_rule(m, i, j):\n        # Apply only to distinct non-depot nodes\n        if i != 1 and j != 1 and i != j:\n            n = len(m.N)\n            # Desrochers-Laporte Lifted MTZ Constraint\n            # Hybridizes the position potential logic (u) with 2-cycle elimination logic (x[j,i])\n            # Standard MTZ: u[i] - u[j] + n*x[i,j] <= n - 1\n            # Lifted: u[i] - u[j] + (n-1)*x[i,j] + (n-3)*x[j,i] <= n - 2\n            return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    \n    model.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "def lifted_mtz_rule(m, i, j):\n    # Apply only to distinct non-depot nodes\n    if i != 1 and j != 1 and i != j:\n        n = len(m.N)\n        # Desrochers-Laporte Lifted MTZ Constraint\n        # Hybridizes the position potential logic (u) with 2-cycle elimination logic (x[j,i])\n        # Standard MTZ: u[i] - u[j] + n*x[i,j] <= n - 1\n        # Lifted: u[i] - u[j] + (n-1)*x[i,j] + (n-3)*x[j,i] <= n - 2\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\n\nmodel.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "This hybrid constraint implements the Desrochers-Laporte lifting, effectively merging the position-potential logic of Parent 1 with the strict 2-cycle exclusion structure of Parent 2. By introducing the reverse arc term (n-3)*x[j,i] into the potential difference inequality, it tightens the Big-M coefficients significantly (from n to n-1) and prevents fractional solutions where disjoint 2-cycles satisfy weaker MTZ bounds."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 11.65,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 11.63,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 14.06,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 13.97,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 12.82,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 12.78,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.86,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.76,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 11.77,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 11.74,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 12.39,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 14.31,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 14.3,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 10.58,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 10.57,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 12.05,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 12.02,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 13.42,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 13.36,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "8676aaf5-bee8-4e26-8f23-adf6c59abcab",
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "3930edc9-382e-4c83-9409-09f38da0948a",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def apply_lifted_perimeter_and_sum(m):\n        # Retrieve n dynamically from the model set\n        n_val = len(m.N)\n        \n        # 1. Global Permutation Sum\n        # Enforces that the sum of all position variables equals the sum of 1..n.\n        # This chops off fractional solutions where u values average correctly but lack permutation structure.\n        m.global_permutation_sum = pyo.Constraint(expr=sum(m.u[i] for i in m.N) == (n_val * (n_val + 1)) / 2)\n    \n        # 2. Depot-Lifted Lower Bounds\n        # Lifts the box constraint u[i] >= 2 using the connection to the depot.\n        # If node i connects to depot (i -> 1), it must be the last node, so u[i] = n.\n        # Valid Inequality: u[i] >= 2 + (n - 2) * x[i, 1]\n        def lifted_lb_rule(m, i):\n            if i == 1: return pyo.Constraint.Skip\n            return m.u[i] >= 2 + (n_val - 2) * m.x[i, 1]\n        m.lifted_u_lower = pyo.Constraint(m.N, rule=lifted_lb_rule)\n    \n        # 3. Depot-Lifted Upper Bounds\n        # Lifts the box constraint u[i] <= n using the connection from the depot.\n        # If depot connects to node i (1 -> i), it must be the second node, so u[i] = 2.\n        # Valid Inequality: u[i] <= n - (n - 2) * x[1, i]\n        def lifted_ub_rule(m, i):\n            if i == 1: return pyo.Constraint.Skip\n            return m.u[i] <= n_val - (n_val - 2) * m.x[1, i]\n        m.lifted_u_upper = pyo.Constraint(m.N, rule=lifted_ub_rule)\n    \n    # Apply the combined lifted cuts to the model\n    apply_lifted_perimeter_and_sum(model)\n\n    return model\n",
                        "added_cut": "def apply_lifted_perimeter_and_sum(m):\n    # Retrieve n dynamically from the model set\n    n_val = len(m.N)\n    \n    # 1. Global Permutation Sum\n    # Enforces that the sum of all position variables equals the sum of 1..n.\n    # This chops off fractional solutions where u values average correctly but lack permutation structure.\n    m.global_permutation_sum = pyo.Constraint(expr=sum(m.u[i] for i in m.N) == (n_val * (n_val + 1)) / 2)\n\n    # 2. Depot-Lifted Lower Bounds\n    # Lifts the box constraint u[i] >= 2 using the connection to the depot.\n    # If node i connects to depot (i -> 1), it must be the last node, so u[i] = n.\n    # Valid Inequality: u[i] >= 2 + (n - 2) * x[i, 1]\n    def lifted_lb_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        return m.u[i] >= 2 + (n_val - 2) * m.x[i, 1]\n    m.lifted_u_lower = pyo.Constraint(m.N, rule=lifted_lb_rule)\n\n    # 3. Depot-Lifted Upper Bounds\n    # Lifts the box constraint u[i] <= n using the connection from the depot.\n    # If depot connects to node i (1 -> i), it must be the second node, so u[i] = 2.\n    # Valid Inequality: u[i] <= n - (n - 2) * x[1, i]\n    def lifted_ub_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        return m.u[i] <= n_val - (n_val - 2) * m.x[1, i]\n    m.lifted_u_upper = pyo.Constraint(m.N, rule=lifted_ub_rule)\n\n# Apply the combined lifted cuts to the model\napply_lifted_perimeter_and_sum(model)",
                        "idea": "The original 'Global Permutation Sum' constraint ($ \\sum u_i = n(n+1)/2 $) is a necessary condition for any valid tour but allows weak fractional assignments for $u$ (e.g., all $u_i$ taking average values). We **lift** this cut by simultaneously tightening the bounds of the variables participating in the sum. The 'Depot-Lifted Bounds' exploit the specific logic of the MTZ formulation: any node $i$ immediately following the depot ($x_{1,i}=1$) is forced to position $u_i=2$, and any node immediately preceding the depot ($x_{i,1}=1$) is forced to $u_i=n$. These conditional logical implications are lifted into linear inequalities ($u_i \\le n - (n-2)x_{1,i}$ and $u_i \\ge 2 + (n-2)x_{i,1}$), which strictly dominate the original bounds. This tightens the domain of each term in the global sum, significantly reducing the feasible region for the LP relaxation."
                    },
                    "fitness": 4.955715823627981,
                    "solver_reports": [
                        {
                            "gap": 16.264,
                            "total_time": 11.0,
                            "explored_nodes": 2646,
                            "simplex_iterations": 42494,
                            "explored_time": 10.98,
                            "work_units": 10.02
                        },
                        {
                            "gap": 26.8683,
                            "total_time": 12.44,
                            "explored_nodes": 1,
                            "simplex_iterations": 8222,
                            "explored_time": 12.39,
                            "work_units": 10.01
                        },
                        {
                            "gap": 10.5006,
                            "total_time": 11.67,
                            "explored_nodes": 1108,
                            "simplex_iterations": 33084,
                            "explored_time": 11.65,
                            "work_units": 10.45
                        },
                        {
                            "total_time": 13.18,
                            "explored_nodes": 1,
                            "simplex_iterations": 4737,
                            "explored_time": 13.12,
                            "work_units": 10.0
                        },
                        {
                            "gap": 2.0741,
                            "total_time": 13.46,
                            "explored_nodes": 3102,
                            "simplex_iterations": 62056,
                            "explored_time": 13.45,
                            "work_units": 10.1
                        },
                        {
                            "gap": 21.6025,
                            "total_time": 11.82,
                            "explored_nodes": 31,
                            "simplex_iterations": 7319,
                            "explored_time": 11.79,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.4061,
                            "total_time": 13.81,
                            "explored_nodes": 270121,
                            "simplex_iterations": 1944694,
                            "explored_time": 13.81,
                            "work_units": 10.03
                        },
                        {
                            "gap": 4.5302,
                            "total_time": 10.88,
                            "explored_nodes": 3092,
                            "simplex_iterations": 62675,
                            "explored_time": 10.86,
                            "work_units": 11.37
                        },
                        {
                            "gap": 16.6456,
                            "total_time": 13.09,
                            "explored_nodes": 59,
                            "simplex_iterations": 8591,
                            "explored_time": 13.06,
                            "work_units": 12.37
                        },
                        {
                            "gap": 21.0586,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 4745,
                            "explored_time": 12.44,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Lifted",
                    "parents_id": [
                        "8676aaf5-bee8-4e26-8f23-adf6c59abcab"
                    ]
                },
                {
                    "id": "bc664cbd-5dac-46da-a38e-7498eff7cced",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Lifted Depot-Anchored Position Bounds\n    # These constraints strengthen the original depot-anchored bounds by solving the lifting problem\n    # for the variables x[i,1] (in the lower bound) and x[1,i] (in the upper bound).\n    # This ensures the bounds are tight for both the second node (u=2) and the last node (u=n).\n    \n    def lifted_depot_lb_rule(model, i):\n        # Original: u[i] >= 3 - x[1,i]. Loose when i is the last node (u[i]=n).\n        # Lifted: Add term (n-3)*x[i,1]. If x[i,1]=1, RHS becomes 3 + n - 3 = n.\n        if i == 1:\n            return pyo.Constraint.Skip\n        return model.u[i] + model.x[1, i] - (n - 3) * model.x[i, 1] >= 3\n    \n    model.lifted_depot_pos_lb = pyo.Constraint(model.N, rule=lifted_depot_lb_rule)\n    \n    def lifted_depot_ub_rule(model, i):\n        # Original: u[i] <= n - 1 + x[i,1]. Loose when i is the second node (u[i]=2).\n        # Lifted: Subtract term (n-3)*x[1,i]. If x[1,i]=1, RHS becomes n - 1 - (n - 3) = 2.\n        if i == 1:\n            return pyo.Constraint.Skip\n        return model.u[i] - model.x[i, 1] + (n - 3) * model.x[1, i] <= n - 1\n    \n    model.lifted_depot_pos_ub = pyo.Constraint(model.N, rule=lifted_depot_ub_rule)\n\n    return model\n",
                        "added_cut": "# Lifted Depot-Anchored Position Bounds\n# These constraints strengthen the original depot-anchored bounds by solving the lifting problem\n# for the variables x[i,1] (in the lower bound) and x[1,i] (in the upper bound).\n# This ensures the bounds are tight for both the second node (u=2) and the last node (u=n).\n\ndef lifted_depot_lb_rule(model, i):\n    # Original: u[i] >= 3 - x[1,i]. Loose when i is the last node (u[i]=n).\n    # Lifted: Add term (n-3)*x[i,1]. If x[i,1]=1, RHS becomes 3 + n - 3 = n.\n    if i == 1:\n        return pyo.Constraint.Skip\n    return model.u[i] + model.x[1, i] - (n - 3) * model.x[i, 1] >= 3\n\nmodel.lifted_depot_pos_lb = pyo.Constraint(model.N, rule=lifted_depot_lb_rule)\n\ndef lifted_depot_ub_rule(model, i):\n    # Original: u[i] <= n - 1 + x[i,1]. Loose when i is the second node (u[i]=2).\n    # Lifted: Subtract term (n-3)*x[1,i]. If x[1,i]=1, RHS becomes n - 1 - (n - 3) = 2.\n    if i == 1:\n        return pyo.Constraint.Skip\n    return model.u[i] - model.x[i, 1] + (n - 3) * model.x[1, i] <= n - 1\n\nmodel.lifted_depot_pos_ub = pyo.Constraint(model.N, rule=lifted_depot_ub_rule)",
                        "idea": "We apply sequential lifting to the original depot-anchored cuts to tighten the MTZ relaxations at the tour's extrema. The original lower bound ($u_i \\ge 3 - x_{1,i}$) is valid but weak when node $i$ is the last node in the tour ($u_i=n$). By introducing the term $(n-3)x_{i,1}$, we force the lower bound to equal $n$ when $x_{i,1}=1$, making it tight for both start and end positions. Symmetrically, the upper bound is lifted with $-(n-3)x_{1,i}$ to enforce $u_i \\le 2$ when node $i$ follows the depot immediately. This significantly reduces the feasible region for fractional $u_i$ values."
                    },
                    "fitness": 5.198400885920934,
                    "solver_reports": [
                        {
                            "gap": 9.4983,
                            "total_time": 12.67,
                            "explored_nodes": 3555,
                            "simplex_iterations": 62970,
                            "explored_time": 12.63,
                            "work_units": 10.0
                        },
                        {
                            "gap": 30.8065,
                            "total_time": 13.25,
                            "explored_nodes": 1,
                            "simplex_iterations": 5407,
                            "explored_time": 13.21,
                            "work_units": 10.0
                        },
                        {
                            "gap": 12.0668,
                            "total_time": 11.76,
                            "explored_nodes": 3939,
                            "simplex_iterations": 62276,
                            "explored_time": 11.75,
                            "work_units": 10.04
                        },
                        {
                            "gap": 63.3055,
                            "total_time": 13.52,
                            "explored_nodes": 1,
                            "simplex_iterations": 3302,
                            "explored_time": 13.46,
                            "work_units": 10.0
                        },
                        {
                            "gap": 2.5185,
                            "total_time": 13.16,
                            "explored_nodes": 7783,
                            "simplex_iterations": 119965,
                            "explored_time": 13.15,
                            "work_units": 10.0
                        },
                        {
                            "gap": 27.8641,
                            "total_time": 13.34,
                            "explored_nodes": 87,
                            "simplex_iterations": 8464,
                            "explored_time": 13.31,
                            "work_units": 10.36
                        },
                        {
                            "gap": 4.8481,
                            "total_time": 12.2,
                            "explored_nodes": 214664,
                            "simplex_iterations": 1492228,
                            "explored_time": 12.2,
                            "work_units": 10.02
                        },
                        {
                            "gap": 2.8455,
                            "total_time": 11.71,
                            "explored_nodes": 2882,
                            "simplex_iterations": 49257,
                            "explored_time": 11.7,
                            "work_units": 10.0
                        },
                        {
                            "gap": 39.114,
                            "total_time": 13.48,
                            "explored_nodes": 171,
                            "simplex_iterations": 9083,
                            "explored_time": 13.45,
                            "work_units": 11.52
                        },
                        {
                            "gap": 11.0694,
                            "total_time": 14.61,
                            "explored_nodes": 143,
                            "simplex_iterations": 9553,
                            "explored_time": 14.57,
                            "work_units": 11.07
                        }
                    ],
                    "generator": "Lifted",
                    "parents_id": [
                        "5fd8394c-000c-4c24-9157-ca11f4f75f23"
                    ]
                },
                {
                    "id": "5c44afa2-dfe4-4791-b030-a8b41d7619d1",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Internal 2-Cycle Lifted MTZ Constraints\n    # This constraint implements the Desrochers and Laporte (1991) lifting for the MTZ formulation.\n    # It strengthens the pairwise relationships between internal nodes (non-depot) by incorporating\n    # the reverse arc x[j,i]. This is distinct from Parent 1 (Global Sum) and Parent 2 (Depot Bounds)\n    # as it specifically tightens the bounds for the internal structure of the tour.\n    \n    def internal_lifted_mtz_rule(model, i, j):\n        # Apply only to distinct internal nodes (excluding the depot node 1)\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        \n        n = len(model.N)\n        # The lifted inequality: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\n        # This inequality is tighter than the standard MTZ (u[i] - u[j] + n*x[i,j] <= n-1)\n        # in two cases:\n        # 1. When x[i,j]=0 and x[j,i]=0: Bound becomes n-2 (vs n-1).\n        # 2. When x[j,i]=1: Forces u[i] - u[j] <= 1, which combined with the reverse MTZ implies u[i] = u[j] + 1.\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n    model.internal_lifted_mtz = pyo.Constraint(model.N, model.N, rule=internal_lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Internal 2-Cycle Lifted MTZ Constraints\n# This constraint implements the Desrochers and Laporte (1991) lifting for the MTZ formulation.\n# It strengthens the pairwise relationships between internal nodes (non-depot) by incorporating\n# the reverse arc x[j,i]. This is distinct from Parent 1 (Global Sum) and Parent 2 (Depot Bounds)\n# as it specifically tightens the bounds for the internal structure of the tour.\n\ndef internal_lifted_mtz_rule(model, i, j):\n    # Apply only to distinct internal nodes (excluding the depot node 1)\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    \n    n = len(model.N)\n    # The lifted inequality: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\n    # This inequality is tighter than the standard MTZ (u[i] - u[j] + n*x[i,j] <= n-1)\n    # in two cases:\n    # 1. When x[i,j]=0 and x[j,i]=0: Bound becomes n-2 (vs n-1).\n    # 2. When x[j,i]=1: Forces u[i] - u[j] <= 1, which combined with the reverse MTZ implies u[i] = u[j] + 1.\n    return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\nmodel.internal_lifted_mtz = pyo.Constraint(model.N, model.N, rule=internal_lifted_mtz_rule)",
                        "idea": "This offspring introduces 'Internal 2-Cycle Lifted MTZ' cuts, derived from the Desrochers and Laporte lifting. While Parent 1 constrains the global mass of position variables and Parent 2 anchors them at the depot boundaries, this cut targets the **internal** logical links between nodes $i, j \\neq 1$. By including the reverse arc $x_{ji}$ in the constraint formulation ($u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} \\le n-2$), it significantly tightens the Big-M coefficient for disconnected pairs and enforces exact position adjacency for 2-cycles, bridging the gap between the parents' global/boundary focus and the model's internal pairwise weakness."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 11.98,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 11.96,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.65,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 13.58,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 12.87,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 12.84,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.83,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.74,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 11.48,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 11.45,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 12.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 12.88,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 14.6,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 14.59,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 9.33,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 9.31,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 11.75,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 11.71,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 13.51,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 13.45,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "8676aaf5-bee8-4e26-8f23-adf6c59abcab",
                        "5fd8394c-000c-4c24-9157-ca11f4f75f23"
                    ]
                }
            ],
            10.353038952236112
        ],
        [
            [
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "f21f048b-8c56-4e0e-a346-29a759bc0024",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Desrochers & Laporte (1991) Bidirectional Lifted MTZ Cuts\n    # This constraint strengthens the standard MTZ formulation by introducing a \n    # bidirectional coupling between nodes i and j. It complements Parent 1 (depot bounds)\n    # and Parent 2 (flow variables) by tightening the internal pairwise potential relations.\n    \n    n = len(model.N)\n    \n    def bidirectional_lifted_mtz_rule(m, i, j):\n        # Apply only to internal node pairs (excluding the depot)\n        if i != 1 and j != 1 and i != j:\n            # Standard MTZ: u[i] - u[j] + n*x[i,j] <= n - 1\n            # Lifted D-L:   u[i] - u[j] + (n-1)*x[i,j] + (n-3)*x[j,i] <= n - 2\n            # Features:\n            # 1. Tightens the 'Big-M' coefficient from n to (n-1).\n            # 2. Includes the reverse arc term (n-3)*x[j,i] to constrain potentials \n            #    based on backward connectivity, eliminating 2-cycle subtours in the relaxation.\n            return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    \n    model.bidirectional_lifted_mtz = pyo.Constraint(model.N, model.N, rule=bidirectional_lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Desrochers & Laporte (1991) Bidirectional Lifted MTZ Cuts\n# This constraint strengthens the standard MTZ formulation by introducing a \n# bidirectional coupling between nodes i and j. It complements Parent 1 (depot bounds)\n# and Parent 2 (flow variables) by tightening the internal pairwise potential relations.\n\nn = len(model.N)\n\ndef bidirectional_lifted_mtz_rule(m, i, j):\n    # Apply only to internal node pairs (excluding the depot)\n    if i != 1 and j != 1 and i != j:\n        # Standard MTZ: u[i] - u[j] + n*x[i,j] <= n - 1\n        # Lifted D-L:   u[i] - u[j] + (n-1)*x[i,j] + (n-3)*x[j,i] <= n - 2\n        # Features:\n        # 1. Tightens the 'Big-M' coefficient from n to (n-1).\n        # 2. Includes the reverse arc term (n-3)*x[j,i] to constrain potentials \n        #    based on backward connectivity, eliminating 2-cycle subtours in the relaxation.\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\n\nmodel.bidirectional_lifted_mtz = pyo.Constraint(model.N, model.N, rule=bidirectional_lifted_mtz_rule)",
                        "idea": "This cut implements Desrochers & Laporte's bidirectional lifting, which serves as a 'middle-ground' structural strengthening between the parents. While Parent 1 focuses on pinning potentials at the tour's endpoints (Depot interactions) and Parent 2 enforces exact flow consistency using expensive auxiliary variables, this offspring targets the **internal** node-to-node relationships. By explicitly coupling the forward ($x_{i,j}$) and backward ($x_{j,i}$) arcs in a single inequality and tightening the 'Big-M' coefficient, it significantly restricts the feasible region for fractional subtours in the middle of the tour without the computational overhead of additional flow variables."
                    },
                    "fitness": 5.749458180182717,
                    "solver_reports": [
                        {
                            "gap": 11.7846,
                            "total_time": 11.37,
                            "explored_nodes": 543,
                            "simplex_iterations": 11251,
                            "explored_time": 11.34,
                            "work_units": 10.09
                        },
                        {
                            "gap": 14.9279,
                            "total_time": 14.7,
                            "explored_nodes": 1,
                            "simplex_iterations": 2078,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 15.1493,
                            "total_time": 11.46,
                            "explored_nodes": 87,
                            "simplex_iterations": 5248,
                            "explored_time": 11.44,
                            "work_units": 10.07
                        },
                        {
                            "total_time": 11.27,
                            "explored_nodes": 1,
                            "simplex_iterations": 2040,
                            "explored_time": 11.19,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.4378,
                            "total_time": 12.73,
                            "explored_nodes": 3526,
                            "simplex_iterations": 55582,
                            "explored_time": 12.72,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.5036,
                            "total_time": 12.68,
                            "explored_nodes": 1,
                            "simplex_iterations": 1759,
                            "explored_time": 12.62,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.9213,
                            "total_time": 14.18,
                            "explored_nodes": 384194,
                            "simplex_iterations": 2350050,
                            "explored_time": 14.18,
                            "work_units": 10.02
                        },
                        {
                            "gap": 2.6982,
                            "total_time": 14.12,
                            "explored_nodes": 2998,
                            "simplex_iterations": 53069,
                            "explored_time": 14.08,
                            "work_units": 10.01
                        },
                        {
                            "gap": 24.2041,
                            "total_time": 11.28,
                            "explored_nodes": 15,
                            "simplex_iterations": 2460,
                            "explored_time": 11.25,
                            "work_units": 10.12
                        },
                        {
                            "gap": 10.4753,
                            "total_time": 12.74,
                            "explored_nodes": 1,
                            "simplex_iterations": 1944,
                            "explored_time": 12.67,
                            "work_units": 10.1
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "bc664cbd-5dac-46da-a38e-7498eff7cced",
                        "8d3ea118-3dfe-4fd2-a52e-9d17f5567521"
                    ]
                },
                {
                    "id": "87ae8b53-905e-4dd7-92d9-52b0979eb9a1",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def strong_internal_mtz_rule(model, i, j):\n        # Apply Desrochers & Laporte lifting to internal arcs (i, j != 1).\n        # This extends the sequential lifting logic of the depot-anchored cuts\n        # to the pairwise subtour elimination constraints.\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        \n        # Standard MTZ: u_i - u_j + n*x_{ij} <= n - 1\n        # Lifted MTZ:   u_i - u_j + (n-1)*x_{ij} + (n-3)*x_{ji} <= n - 2\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n    model.strong_internal_mtz = pyo.Constraint(model.N, model.N, rule=strong_internal_mtz_rule)\n\n    return model\n",
                        "added_cut": "def strong_internal_mtz_rule(model, i, j):\n    # Apply Desrochers & Laporte lifting to internal arcs (i, j != 1).\n    # This extends the sequential lifting logic of the depot-anchored cuts\n    # to the pairwise subtour elimination constraints.\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    \n    # Standard MTZ: u_i - u_j + n*x_{ij} <= n - 1\n    # Lifted MTZ:   u_i - u_j + (n-1)*x_{ij} + (n-3)*x_{ji} <= n - 2\n    return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\nmodel.strong_internal_mtz = pyo.Constraint(model.N, model.N, rule=strong_internal_mtz_rule)",
                        "idea": "We apply sequential lifting to the internal pairwise constraints (Desrochers & Laporte), complementing the individual's depot-anchored bound tightening. While the individual's cuts strengthen $u_i$ relative to the depot, this mutation strengthens the relative ordering $u_i - u_j$ between non-depot nodes. By tightening the Big-M coefficient from $n$ to $n-1$ and lifting the reverse arc $x_{ji}$ with coefficient $n-3$, the cut significantly reduces the slack for fractional cycles in the relaxation."
                    },
                    "fitness": 4.554829604258969,
                    "solver_reports": [
                        {
                            "gap": 11.8089,
                            "total_time": 11.09,
                            "explored_nodes": 495,
                            "simplex_iterations": 10786,
                            "explored_time": 11.06,
                            "work_units": 10.04
                        },
                        {
                            "gap": 11.4825,
                            "total_time": 13.57,
                            "explored_nodes": 1,
                            "simplex_iterations": 2294,
                            "explored_time": 13.48,
                            "work_units": 10.0
                        },
                        {
                            "gap": 12.5166,
                            "total_time": 12.44,
                            "explored_nodes": 201,
                            "simplex_iterations": 8460,
                            "explored_time": 12.42,
                            "work_units": 10.05
                        },
                        {
                            "total_time": 12.06,
                            "explored_nodes": 1,
                            "simplex_iterations": 2125,
                            "explored_time": 11.97,
                            "work_units": 10.01
                        },
                        {
                            "gap": 3.9764,
                            "total_time": 12.96,
                            "explored_nodes": 3851,
                            "simplex_iterations": 48903,
                            "explored_time": 12.94,
                            "work_units": 10.0
                        },
                        {
                            "gap": 33.1642,
                            "total_time": 13.04,
                            "explored_nodes": 1,
                            "simplex_iterations": 1731,
                            "explored_time": 12.98,
                            "work_units": 10.01
                        },
                        {
                            "gap": 3.0372,
                            "total_time": 13.72,
                            "explored_nodes": 683982,
                            "simplex_iterations": 3870269,
                            "explored_time": 13.72,
                            "work_units": 10.01
                        },
                        {
                            "gap": 2.0959,
                            "total_time": 14.0,
                            "explored_nodes": 2784,
                            "simplex_iterations": 58202,
                            "explored_time": 13.97,
                            "work_units": 10.0
                        },
                        {
                            "gap": 27.8274,
                            "total_time": 11.79,
                            "explored_nodes": 59,
                            "simplex_iterations": 3310,
                            "explored_time": 11.75,
                            "work_units": 10.47
                        },
                        {
                            "gap": 22.5364,
                            "total_time": 13.7,
                            "explored_nodes": 1,
                            "simplex_iterations": 1633,
                            "explored_time": 13.64,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Lifted",
                    "parents_id": [
                        "bc664cbd-5dac-46da-a38e-7498eff7cced"
                    ]
                },
                {
                    "id": "3ee62516-3597-47a2-acfe-37924594fa59",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # 1. Internal Displacement Bounds\n    # Strictly forces u[i] into [3, n-1] if node i is not directly connected to the depot.\n    # This prunes fractional solutions where internal nodes drift to u=2 or u=n.\n    \n    def internal_lb_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        # Logic: If x[1,i]=1 -> u>=2. If x[i,1]=1 -> u>=n. Else -> u>=3.\n        # Form: u >= 3 - x[1,i] + (n-3)*x[i,1]\n        return m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1]\n    model.internal_u_lower = pyo.Constraint(model.N, rule=internal_lb_rule)\n    \n    def internal_ub_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        # Logic: If x[1,i]=1 -> u<=2. If x[i,1]=1 -> u<=n. Else -> u<=n-1.\n        # Form: u <= (n-1) + x[i,1] - (n-3)*x[1,i]\n        return m.u[i] <= (n - 1) + m.x[i, 1] - (n - 3) * m.x[1, i]\n    model.internal_u_upper = pyo.Constraint(model.N, rule=internal_ub_rule)\n    \n    # 2. Lifted MTZ (Desrochers & Laporte)\n    # Strengthens the subtour elimination by including the reverse arc x[j,i].\n    # This tightens the relative ordering constraints for internal nodes.\n    def lifted_mtz_rule(m, i, j):\n        if i != j and i != 1 and j != 1:\n            return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    model.lifted_mtz_dl = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# 1. Internal Displacement Bounds\n# Strictly forces u[i] into [3, n-1] if node i is not directly connected to the depot.\n# This prunes fractional solutions where internal nodes drift to u=2 or u=n.\n\ndef internal_lb_rule(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    # Logic: If x[1,i]=1 -> u>=2. If x[i,1]=1 -> u>=n. Else -> u>=3.\n    # Form: u >= 3 - x[1,i] + (n-3)*x[i,1]\n    return m.u[i] >= 3 - m.x[1, i] + (n - 3) * m.x[i, 1]\nmodel.internal_u_lower = pyo.Constraint(model.N, rule=internal_lb_rule)\n\ndef internal_ub_rule(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    # Logic: If x[1,i]=1 -> u<=2. If x[i,1]=1 -> u<=n. Else -> u<=n-1.\n    # Form: u <= (n-1) + x[i,1] - (n-3)*x[1,i]\n    return m.u[i] <= (n - 1) + m.x[i, 1] - (n - 3) * m.x[1, i]\nmodel.internal_u_upper = pyo.Constraint(model.N, rule=internal_ub_rule)\n\n# 2. Lifted MTZ (Desrochers & Laporte)\n# Strengthens the subtour elimination by including the reverse arc x[j,i].\n# This tightens the relative ordering constraints for internal nodes.\ndef lifted_mtz_rule(m, i, j):\n    if i != j and i != 1 and j != 1:\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\nmodel.lifted_mtz_dl = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "Introduces 'Strengthened Internal Logic' to complement the parents' depot-focused cuts. It enforces stricter bounds [3, n-1] for nodes not connected to the depot (pruning mid-tour drift) and applies the Desrochers & Laporte lifted MTZ constraints (using reverse arcs) to tighten internal relative ordering."
                    },
                    "fitness": 1.3261707852101838,
                    "solver_reports": [
                        {
                            "gap": 16.6372,
                            "total_time": 12.59,
                            "explored_nodes": 471,
                            "simplex_iterations": 12029,
                            "explored_time": 12.57,
                            "work_units": 10.02
                        },
                        {
                            "gap": 5.1145,
                            "total_time": 14.45,
                            "explored_nodes": 1,
                            "simplex_iterations": 1685,
                            "explored_time": 14.32,
                            "work_units": 10.0
                        },
                        {
                            "gap": 9.5397,
                            "total_time": 14.04,
                            "explored_nodes": 49,
                            "simplex_iterations": 5163,
                            "explored_time": 14.03,
                            "work_units": 10.05
                        },
                        {
                            "total_time": 13.3,
                            "explored_nodes": 1,
                            "simplex_iterations": 1767,
                            "explored_time": 13.2,
                            "work_units": 10.02
                        },
                        {
                            "gap": 5.3546,
                            "total_time": 11.7,
                            "explored_nodes": 3305,
                            "simplex_iterations": 50416,
                            "explored_time": 11.68,
                            "work_units": 10.0
                        },
                        {
                            "gap": 90.9579,
                            "total_time": 12.87,
                            "explored_nodes": 1,
                            "simplex_iterations": 1680,
                            "explored_time": 12.79,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 2.26,
                            "postsolve": 0.0,
                            "explored_nodes": 24128,
                            "simplex_iterations": 167464,
                            "explored_time": 2.26,
                            "work_units": 1.49
                        },
                        {
                            "gap": 4.845,
                            "total_time": 10.39,
                            "explored_nodes": 907,
                            "simplex_iterations": 23661,
                            "explored_time": 10.37,
                            "work_units": 10.06
                        },
                        {
                            "gap": 20.6573,
                            "total_time": 12.82,
                            "explored_nodes": 8,
                            "simplex_iterations": 1258,
                            "explored_time": 12.77,
                            "work_units": 10.02
                        },
                        {
                            "gap": 66.2862,
                            "total_time": 13.87,
                            "explored_nodes": 1,
                            "simplex_iterations": 1565,
                            "explored_time": 13.78,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "3930edc9-382e-4c83-9409-09f38da0948a",
                        "2d4d607d-bfa3-4813-b125-8951ee9fa86e"
                    ]
                },
                {
                    "id": "202307c1-f3df-4801-be9c-c9c324055142",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def add_combined_cuts(model):\n        # Retrieve n dynamically from the model set\n        n_val = len(model.N)\n    \n        # 1. Sequentially Lifted Lower Bounds (Refined from Parent 1)\n        # These bounds strictly dominate Parent 2's bounds by handling the \"non-adjacent\" case.\n        # Logic:\n        #   - If 1->i (x[1,i]=1), then u[i] >= 2.\n        #   - If i->1 (x[i,1]=1), then u[i] >= n (last node).\n        #   - If neither (node i not adjacent to depot), then u[i] >= 3 (cannot be 2nd or last).\n        # Expression: u[i] >= 3 - x[1,i] + (n-3)*x[i,1]\n        def lifted_lb_rule(m, i):\n            if i == 1:\n                return pyo.Constraint.Skip\n            return m.u[i] >= 3 - m.x[1, i] + (n_val - 3) * m.x[i, 1]\n        model.lifted_depot_lb = pyo.Constraint(model.N, rule=lifted_lb_rule)\n    \n        # 2. Sequentially Lifted Upper Bounds (Refined from Parent 1)\n        # Logic:\n        #   - If 1->i, u[i] <= 2.\n        #   - If i->1, u[i] <= n.\n        #   - If neither, u[i] <= n-1.\n        # Expression: u[i] <= (n-1) + x[i,1] - (n-3)*x[1,i]\n        def lifted_ub_rule(m, i):\n            if i == 1:\n                return pyo.Constraint.Skip\n            return m.u[i] <= (n_val - 1) + m.x[i, 1] - (n_val - 3) * m.x[1, i]\n        model.lifted_depot_ub = pyo.Constraint(model.N, rule=lifted_ub_rule)\n    \n        # 3. Global Permutation Sum (From Parent 2)\n        # Enforces that the sum of all position variables equals n(n+1)/2.\n        # This global cut removes fractional solutions where u variables are clustered around the mean.\n        model.global_permutation_sum = pyo.Constraint(expr=sum(model.u[i] for i in model.N) == (n_val * (n_val + 1)) / 2)\n    \n    add_combined_cuts(model)\n\n    return model\n",
                        "added_cut": "def add_combined_cuts(model):\n    # Retrieve n dynamically from the model set\n    n_val = len(model.N)\n\n    # 1. Sequentially Lifted Lower Bounds (Refined from Parent 1)\n    # These bounds strictly dominate Parent 2's bounds by handling the \"non-adjacent\" case.\n    # Logic:\n    #   - If 1->i (x[1,i]=1), then u[i] >= 2.\n    #   - If i->1 (x[i,1]=1), then u[i] >= n (last node).\n    #   - If neither (node i not adjacent to depot), then u[i] >= 3 (cannot be 2nd or last).\n    # Expression: u[i] >= 3 - x[1,i] + (n-3)*x[i,1]\n    def lifted_lb_rule(m, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        return m.u[i] >= 3 - m.x[1, i] + (n_val - 3) * m.x[i, 1]\n    model.lifted_depot_lb = pyo.Constraint(model.N, rule=lifted_lb_rule)\n\n    # 2. Sequentially Lifted Upper Bounds (Refined from Parent 1)\n    # Logic:\n    #   - If 1->i, u[i] <= 2.\n    #   - If i->1, u[i] <= n.\n    #   - If neither, u[i] <= n-1.\n    # Expression: u[i] <= (n-1) + x[i,1] - (n-3)*x[1,i]\n    def lifted_ub_rule(m, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        return m.u[i] <= (n_val - 1) + m.x[i, 1] - (n_val - 3) * m.x[1, i]\n    model.lifted_depot_ub = pyo.Constraint(model.N, rule=lifted_ub_rule)\n\n    # 3. Global Permutation Sum (From Parent 2)\n    # Enforces that the sum of all position variables equals n(n+1)/2.\n    # This global cut removes fractional solutions where u variables are clustered around the mean.\n    model.global_permutation_sum = pyo.Constraint(expr=sum(model.u[i] for i in model.N) == (n_val * (n_val + 1)) / 2)\n\nadd_combined_cuts(model)",
                        "idea": "The **Combined Lifted Bounds and Permutation Sum** integrates the strongest elements of both parents to tighten the formulation globally and locally. It adopts Parent 1's sequential lifting logic, which strictly dominates Parent 2's bounds by enforcing $u_i \\in [3, n-1]$ for nodes not adjacent to the depot (whereas Parent 2 only enforces $[2, n]$). It then applies Parent 2's global permutation sum equality ($\\sum u_i = n(n+1)/2$), which creates a hyperplane cut invalidating fractional solutions where $u_i$ values satisfy bounds but fail to form a permutation (e.g., clustering). The synergy between the narrowed domains of individual variables and the global sum constraint significantly reduces the feasible region of the LP relaxation."
                    },
                    "fitness": 3.6819756586231387,
                    "solver_reports": [
                        {
                            "gap": 12.2276,
                            "total_time": 11.56,
                            "explored_nodes": 843,
                            "simplex_iterations": 19407,
                            "explored_time": 11.54,
                            "work_units": 10.67
                        },
                        {
                            "gap": 19.6554,
                            "total_time": 12.28,
                            "explored_nodes": 1,
                            "simplex_iterations": 7041,
                            "explored_time": 12.22,
                            "work_units": 10.0
                        },
                        {
                            "gap": 8.8546,
                            "total_time": 11.71,
                            "explored_nodes": 1068,
                            "simplex_iterations": 34072,
                            "explored_time": 11.69,
                            "work_units": 10.43
                        },
                        {
                            "gap": 53.5928,
                            "total_time": 13.88,
                            "explored_nodes": 1,
                            "simplex_iterations": 3503,
                            "explored_time": 13.81,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.2034,
                            "total_time": 12.64,
                            "explored_nodes": 6099,
                            "simplex_iterations": 76609,
                            "explored_time": 12.62,
                            "work_units": 10.0
                        },
                        {
                            "gap": 34.5845,
                            "total_time": 11.48,
                            "explored_nodes": 7,
                            "simplex_iterations": 6755,
                            "explored_time": 11.46,
                            "work_units": 10.21
                        },
                        {
                            "gap": 4.7911,
                            "total_time": 14.68,
                            "explored_nodes": 174912,
                            "simplex_iterations": 1157156,
                            "explored_time": 14.67,
                            "work_units": 10.02
                        },
                        {
                            "gap": 5.257,
                            "total_time": 10.79,
                            "explored_nodes": 2791,
                            "simplex_iterations": 66900,
                            "explored_time": 10.78,
                            "work_units": 10.0
                        },
                        {
                            "gap": 24.311,
                            "total_time": 13.06,
                            "explored_nodes": 59,
                            "simplex_iterations": 8547,
                            "explored_time": 13.04,
                            "work_units": 11.61
                        },
                        {
                            "gap": 28.2217,
                            "total_time": 12.52,
                            "explored_nodes": 1,
                            "simplex_iterations": 4103,
                            "explored_time": 12.5,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "bc664cbd-5dac-46da-a38e-7498eff7cced",
                        "3930edc9-382e-4c83-9409-09f38da0948a"
                    ]
                },
                {
                    "id": "eae4d92c-eb47-4bd4-b055-a79beb2778f7",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Desrochers and Laporte (1991) Strong Lifted MTZ Cuts\n    # These constraints target the internal pairwise ordering of non-depot nodes, complementing\n    # the parents' focus on depot-anchored bounds and global sums. By tightening the Big-M \n    # coefficient from n to (n-1) and lifting with the reverse arc x[j,i], we enforce stricter \n    # sequential logic in the 'middle' of the tour where standard MTZ is weakest.\n    \n    def strong_lifted_mtz_rule(model, i, j):\n        # Apply only to distinct pairs of non-depot nodes\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        \n        # Standard MTZ: u[i] - u[j] + n * x[i,j] <= n - 1\n        # Lifted DL:    u[i] - u[j] + (n - 1) * x[i,j] + (n - 3) * x[j,i] <= n - 2\n        # This cut dominates the standard MTZ for all i, j != 1.\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n    model.strong_lifted_mtz = pyo.Constraint(model.N, model.N, rule=strong_lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Desrochers and Laporte (1991) Strong Lifted MTZ Cuts\n# These constraints target the internal pairwise ordering of non-depot nodes, complementing\n# the parents' focus on depot-anchored bounds and global sums. By tightening the Big-M \n# coefficient from n to (n-1) and lifting with the reverse arc x[j,i], we enforce stricter \n# sequential logic in the 'middle' of the tour where standard MTZ is weakest.\n\ndef strong_lifted_mtz_rule(model, i, j):\n    # Apply only to distinct pairs of non-depot nodes\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    \n    # Standard MTZ: u[i] - u[j] + n * x[i,j] <= n - 1\n    # Lifted DL:    u[i] - u[j] + (n - 1) * x[i,j] + (n - 3) * x[j,i] <= n - 2\n    # This cut dominates the standard MTZ for all i, j != 1.\n    return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\nmodel.strong_lifted_mtz = pyo.Constraint(model.N, model.N, rule=strong_lifted_mtz_rule)",
                        "idea": "We implement the Desrochers-Laporte lifted inequalities to address the structural weakness of the standard MTZ constraints regarding internal node connections. While Parent 1 restricts $u_i$ based on depot adjacency (perimeter) and Parent 2 constrains the global $u$-sum (volume), neither effectively propagates integrality between intermediate nodes $i$ and $j$. This cut strengthens that pairwise link by reducing the Big-M coefficient and incorporating the reverse arc $x_{j,i}$, tightening the relaxation in the search space interior orthogonal to the parents' boundary constraints."
                    },
                    "fitness": 4.554829604258969,
                    "solver_reports": [
                        {
                            "gap": 11.8089,
                            "total_time": 12.52,
                            "explored_nodes": 495,
                            "simplex_iterations": 10786,
                            "explored_time": 12.5,
                            "work_units": 10.04
                        },
                        {
                            "gap": 11.4825,
                            "total_time": 12.73,
                            "explored_nodes": 1,
                            "simplex_iterations": 2294,
                            "explored_time": 12.67,
                            "work_units": 10.0
                        },
                        {
                            "gap": 12.5166,
                            "total_time": 12.23,
                            "explored_nodes": 201,
                            "simplex_iterations": 8460,
                            "explored_time": 12.21,
                            "work_units": 10.05
                        },
                        {
                            "total_time": 12.01,
                            "explored_nodes": 1,
                            "simplex_iterations": 2125,
                            "explored_time": 11.92,
                            "work_units": 10.01
                        },
                        {
                            "gap": 3.9764,
                            "total_time": 12.34,
                            "explored_nodes": 3851,
                            "simplex_iterations": 48903,
                            "explored_time": 12.32,
                            "work_units": 10.0
                        },
                        {
                            "gap": 33.1642,
                            "total_time": 14.28,
                            "explored_nodes": 1,
                            "simplex_iterations": 1731,
                            "explored_time": 14.21,
                            "work_units": 10.01
                        },
                        {
                            "gap": 3.0372,
                            "total_time": 12.74,
                            "explored_nodes": 683982,
                            "simplex_iterations": 3870269,
                            "explored_time": 12.74,
                            "work_units": 10.01
                        },
                        {
                            "gap": 2.0959,
                            "total_time": 14.06,
                            "explored_nodes": 2784,
                            "simplex_iterations": 58202,
                            "explored_time": 14.03,
                            "work_units": 10.0
                        },
                        {
                            "gap": 27.8274,
                            "total_time": 11.54,
                            "explored_nodes": 59,
                            "simplex_iterations": 3310,
                            "explored_time": 11.51,
                            "work_units": 10.47
                        },
                        {
                            "gap": 22.5364,
                            "total_time": 13.52,
                            "explored_nodes": 1,
                            "simplex_iterations": 1633,
                            "explored_time": 13.47,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "bc664cbd-5dac-46da-a38e-7498eff7cced",
                        "702d77e6-dd3c-4a92-8018-61487927a7e6"
                    ]
                },
                {
                    "id": "6bd8c450-e3aa-4248-8e4d-97e925be3e22",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Desrochers-Laporte Lifted MTZ Constraints\n    # This complementary cut strengthens the internal node ordering logic by linking\n    # forward and backward arcs between any pair of non-depot nodes.\n    def lifted_mtz_rule(m, i, j):\n        # Apply only to internal pairs (excluding depot node 1)\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        \n        # Standard MTZ is: u[i] - u[j] + n*x[i,j] <= n-1\n        # The lifted version adds the reverse arc term (n-3)*x[j,i] to tighten the bound.\n        # This inequality is valid for the TSP and significantly reduces the feasible region\n        # of the LP relaxation by exploiting the mutual exclusivity of x[i,j] and x[j,i].\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    \n    model.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Desrochers-Laporte Lifted MTZ Constraints\n# This complementary cut strengthens the internal node ordering logic by linking\n# forward and backward arcs between any pair of non-depot nodes.\ndef lifted_mtz_rule(m, i, j):\n    # Apply only to internal pairs (excluding depot node 1)\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    \n    # Standard MTZ is: u[i] - u[j] + n*x[i,j] <= n-1\n    # The lifted version adds the reverse arc term (n-3)*x[j,i] to tighten the bound.\n    # This inequality is valid for the TSP and significantly reduces the feasible region\n    # of the LP relaxation by exploiting the mutual exclusivity of x[i,j] and x[j,i].\n    return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n\nmodel.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "This offspring implements the Desrochers-Laporte (DL) lifted inequalities, acting as a structural bridge between the two parents. While Parent 1 targets local 2-cycles using only flow variables ($x$) and Parent 2 constrains position variables ($u$) via global sums and depot bounds, this cut enforces a tighter coupling between $u$ and $x$ for all internal edges. By incorporating the reverse arc term $(n-3)x_{j,i}$, it implicitly eliminates 2-cycles and fractional 3-cycles within the potential formulation itself. This complements Parent 2's 'center of mass' constraints by providing necessary internal rigidity and improves upon Parent 1 by leveraging the $u$-variables to propagate these restrictions across the tour."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 12.19,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 12.17,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.74,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 13.67,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 12.83,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 12.81,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.92,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.82,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 12.59,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 12.57,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 12.4,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 12.33,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 15.1,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 15.09,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 10.79,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 10.77,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 11.63,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 11.6,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 13.07,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 13.01,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "702d77e6-dd3c-4a92-8018-61487927a7e6"
                    ]
                },
                {
                    "id": "66f29ae4-6ca9-4d63-9c8e-0aa3cf34e29a",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Desrochers-Laporte Lifted MTZ & Depot Anchoring\n    # A \"Potential Tunnel\" constraint set that tightens u-variables without auxiliary flow variables.\n    \n    # 1. Desrochers-Laporte (DL) Lifting for internal nodes\n    # This tightens the standard MTZ constraint by incorporating the reverse arc (x[j,i]).\n    # It implicitly enforces 2-cycle elimination (Parent 1 logic) within the potential formulation.\n    # Formula: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n    def dl_lifting_rule(m, i, j):\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    model.dl_lifting = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)\n    \n    # 2. Depot Anchoring (Boundary Fixing)\n    # Rigidly couples the potential u to the depot connections (Parent 2 logic) but uses \n    # bounds-tightening (Parent 1 style) instead of flow variables.\n    \n    # Start Anchor: If arc 1->j exists, node j must be at position 2.\n    # Constraint: u[j] <= n - (n - 2) * x[1, j]\n    # Check: If x[1,j]=1 => u[j] <= 2. Since u[j]>=2, u[j]=2. If x=0, u[j]<=n (valid).\n    def start_anchor_rule(m, j):\n        if j == 1: return pyo.Constraint.Skip\n        return m.u[j] <= n - (n - 2) * m.x[1, j]\n    model.start_anchor = pyo.Constraint(model.N, rule=start_anchor_rule)\n    \n    # End Anchor: If arc i->1 exists, node i must be at position n.\n    # Constraint: u[i] >= 2 + (n - 2) * x[i, 1]\n    # Check: If x[i,1]=1 => u[i] >= n. Since u[i]<=n, u[i]=n. If x=0, u[i]>=2 (valid).\n    def end_anchor_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        return m.u[i] >= 2 + (n - 2) * m.x[i, 1]\n    model.end_anchor = pyo.Constraint(model.N, rule=end_anchor_rule)\n\n    return model\n",
                        "added_cut": "# Desrochers-Laporte Lifted MTZ & Depot Anchoring\n# A \"Potential Tunnel\" constraint set that tightens u-variables without auxiliary flow variables.\n\n# 1. Desrochers-Laporte (DL) Lifting for internal nodes\n# This tightens the standard MTZ constraint by incorporating the reverse arc (x[j,i]).\n# It implicitly enforces 2-cycle elimination (Parent 1 logic) within the potential formulation.\n# Formula: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\ndef dl_lifting_rule(m, i, j):\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\nmodel.dl_lifting = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)\n\n# 2. Depot Anchoring (Boundary Fixing)\n# Rigidly couples the potential u to the depot connections (Parent 2 logic) but uses \n# bounds-tightening (Parent 1 style) instead of flow variables.\n\n# Start Anchor: If arc 1->j exists, node j must be at position 2.\n# Constraint: u[j] <= n - (n - 2) * x[1, j]\n# Check: If x[1,j]=1 => u[j] <= 2. Since u[j]>=2, u[j]=2. If x=0, u[j]<=n (valid).\ndef start_anchor_rule(m, j):\n    if j == 1: return pyo.Constraint.Skip\n    return m.u[j] <= n - (n - 2) * m.x[1, j]\nmodel.start_anchor = pyo.Constraint(model.N, rule=start_anchor_rule)\n\n# End Anchor: If arc i->1 exists, node i must be at position n.\n# Constraint: u[i] >= 2 + (n - 2) * x[i, 1]\n# Check: If x[i,1]=1 => u[i] >= n. Since u[i]<=n, u[i]=n. If x=0, u[i]>=2 (valid).\ndef end_anchor_rule(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    return m.u[i] >= 2 + (n - 2) * m.x[i, 1]\nmodel.end_anchor = pyo.Constraint(model.N, rule=end_anchor_rule)",
                        "idea": "This offspring implements 'Depot-Anchored Lifted MTZ', a hybrid cut that merges the cycle-breaking logic of Parent 1 with the positional enforcement of Parent 2. By using Desrochers-Laporte lifting, it tightens the internal MTZ constraints using reverse arcs (making 2-cycles infeasible in the potential space). Simultaneously, it adds 'Depot Anchors' that strictly force $u_j=2$ for the start node and $u_i=n$ for the end node of the tour. This creates a rigid 'potential tunnel' that significantly strengthens the linear relaxation without the computational overhead of Parent 2's auxiliary flow variables."
                    },
                    "fitness": 0.9970115781103867,
                    "solver_reports": [
                        {
                            "gap": 10.0098,
                            "total_time": 12.1,
                            "explored_nodes": 376,
                            "simplex_iterations": 10293,
                            "explored_time": 12.08,
                            "work_units": 10.04
                        },
                        {
                            "gap": 3.119,
                            "total_time": 14.18,
                            "explored_nodes": 1,
                            "simplex_iterations": 2124,
                            "explored_time": 14.08,
                            "work_units": 10.0
                        },
                        {
                            "gap": 12.0657,
                            "total_time": 12.37,
                            "explored_nodes": 199,
                            "simplex_iterations": 11196,
                            "explored_time": 12.35,
                            "work_units": 10.33
                        },
                        {
                            "total_time": 12.95,
                            "explored_nodes": 1,
                            "simplex_iterations": 1775,
                            "explored_time": 12.85,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.2229,
                            "total_time": 10.76,
                            "explored_nodes": 3536,
                            "simplex_iterations": 46234,
                            "explored_time": 10.73,
                            "work_units": 10.0
                        },
                        {
                            "gap": 85.7841,
                            "total_time": 12.5,
                            "explored_nodes": 1,
                            "simplex_iterations": 1446,
                            "explored_time": 12.42,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 2.75,
                            "postsolve": 0.0,
                            "explored_nodes": 30694,
                            "simplex_iterations": 223917,
                            "explored_time": 2.74,
                            "work_units": 1.54
                        },
                        {
                            "gap": 2.8842,
                            "total_time": 10.54,
                            "explored_nodes": 718,
                            "simplex_iterations": 20434,
                            "explored_time": 10.52,
                            "work_units": 10.02
                        },
                        {
                            "gap": 11.5082,
                            "total_time": 10.93,
                            "explored_nodes": 59,
                            "simplex_iterations": 3028,
                            "explored_time": 10.89,
                            "work_units": 11.09
                        },
                        {
                            "gap": 87.8934,
                            "total_time": 13.85,
                            "explored_nodes": 1,
                            "simplex_iterations": 1594,
                            "explored_time": 13.76,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "8d3ea118-3dfe-4fd2-a52e-9d17f5567521"
                    ]
                }
            ],
            10.353038952236112
        ],
        [
            [
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "ad5bb2ca-311b-47df-8dcb-7b810972e6a4",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def depot_structural_mtz_rule(model, i, j):\n        # Skip constraints involving the depot or self-loops\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        \n        # We strengthen the standard MTZ constraint by tightening the RHS based on depot connectivity logic.\n        # Standard MTZ: u[i] - u[j] + n*x[i,j] <= n - 1.\n        # Desrochers & Laporte (DL): u[i] - u[j] + (n-1)*x[i,j] + (n-3)*x[j,i] <= n - 2.\n        \n        # Our lifted cut: u[i] - u[j] + (n-3)*x[i,j] + (n-5)*x[j,i] - x[i,1] - x[1,j] <= n - 4\n        # Justification:\n        # 1. When x[i,1]=0 (i is not last) and x[1,j]=0 (j is not first), u[i] <= n-1 and u[j] >= 3.\n        #    Thus, u[i] - u[j] <= n-4. This allows tightening the RHS from n-2 to n-4.\n        # 2. To maintain validity when x[i,1]=1 or x[1,j]=1, we subtract these variables (effectively relaxing the RHS).\n        # 3. Coefficients for x[i,j] and x[j,i] are adjusted to (n-3) and (n-5) to satisfy the tighter RHS.\n        # This cut is strictly stronger than DL when x[i,1] and x[1,j] are zero.\n    \n        return model.u[i] - model.u[j] + (n - 3) * model.x[i, j] + (n - 5) * model.x[j, i] - model.x[i, 1] - model.x[1, j] <= n - 4\n    \n    model.depot_structural_mtz = pyo.Constraint(model.N, model.N, rule=depot_structural_mtz_rule)\n\n    return model\n",
                        "added_cut": "def depot_structural_mtz_rule(model, i, j):\n    # Skip constraints involving the depot or self-loops\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    \n    # We strengthen the standard MTZ constraint by tightening the RHS based on depot connectivity logic.\n    # Standard MTZ: u[i] - u[j] + n*x[i,j] <= n - 1.\n    # Desrochers & Laporte (DL): u[i] - u[j] + (n-1)*x[i,j] + (n-3)*x[j,i] <= n - 2.\n    \n    # Our lifted cut: u[i] - u[j] + (n-3)*x[i,j] + (n-5)*x[j,i] - x[i,1] - x[1,j] <= n - 4\n    # Justification:\n    # 1. When x[i,1]=0 (i is not last) and x[1,j]=0 (j is not first), u[i] <= n-1 and u[j] >= 3.\n    #    Thus, u[i] - u[j] <= n-4. This allows tightening the RHS from n-2 to n-4.\n    # 2. To maintain validity when x[i,1]=1 or x[1,j]=1, we subtract these variables (effectively relaxing the RHS).\n    # 3. Coefficients for x[i,j] and x[j,i] are adjusted to (n-3) and (n-5) to satisfy the tighter RHS.\n    # This cut is strictly stronger than DL when x[i,1] and x[1,j] are zero.\n\n    return model.u[i] - model.u[j] + (n - 3) * model.x[i, j] + (n - 5) * model.x[j, i] - model.x[i, 1] - model.x[1, j] <= n - 4\n\nmodel.depot_structural_mtz = pyo.Constraint(model.N, model.N, rule=depot_structural_mtz_rule)",
                        "idea": "We apply a Depot-Structural Lifting that dominates the Desrochers & Laporte cut. By observing that for internal arcs where nodes i and j are not immediately connected to the depot (i.e., x[i,1]=0 and x[1,j]=0), the maximum potential difference u[i] - u[j] is only n-4 (since u[i] <= n-1 and u[j] >= 3). We tighten the RHS to n-4 and introduce the depot connection variables x[i,1] and x[1,j] into the constraint to recover validity for endpoints. This results in a cut that is strictly tighter than standard lifted cuts for the majority of arcs in the graph."
                    },
                    "fitness": 0.9031322657546172,
                    "solver_reports": [
                        {
                            "gap": 33.591,
                            "total_time": 11.13,
                            "explored_nodes": 470,
                            "simplex_iterations": 10708,
                            "explored_time": 11.11,
                            "work_units": 10.05
                        },
                        {
                            "gap": 25.5389,
                            "total_time": 11.71,
                            "explored_nodes": 1,
                            "simplex_iterations": 2382,
                            "explored_time": 11.58,
                            "work_units": 10.01
                        },
                        {
                            "gap": 15.0465,
                            "total_time": 12.3,
                            "explored_nodes": 143,
                            "simplex_iterations": 5397,
                            "explored_time": 12.28,
                            "work_units": 11.95
                        },
                        {
                            "total_time": 11.67,
                            "explored_nodes": 1,
                            "simplex_iterations": 1987,
                            "explored_time": 11.54,
                            "work_units": 10.0
                        },
                        {
                            "gap": 9.4499,
                            "total_time": 10.05,
                            "explored_nodes": 1205,
                            "simplex_iterations": 23464,
                            "explored_time": 10.04,
                            "work_units": 10.03
                        },
                        {
                            "gap": 29.0264,
                            "total_time": 10.68,
                            "explored_nodes": 1,
                            "simplex_iterations": 1908,
                            "explored_time": 10.61,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.9194,
                            "total_time": 12.75,
                            "explored_nodes": 182537,
                            "simplex_iterations": 1133508,
                            "explored_time": 12.75,
                            "work_units": 10.01
                        },
                        {
                            "gap": 10.4909,
                            "total_time": 10.5,
                            "explored_nodes": 143,
                            "simplex_iterations": 7860,
                            "explored_time": 10.49,
                            "work_units": 10.01
                        },
                        {
                            "gap": 30.3628,
                            "total_time": 11.16,
                            "explored_nodes": 1,
                            "simplex_iterations": 1286,
                            "explored_time": 11.12,
                            "work_units": 10.0
                        },
                        {
                            "gap": 51.4389,
                            "total_time": 12.1,
                            "explored_nodes": 1,
                            "simplex_iterations": 1517,
                            "explored_time": 12.01,
                            "work_units": 10.07
                        }
                    ],
                    "generator": "Lifted",
                    "parents_id": [
                        "87ae8b53-905e-4dd7-92d9-52b0979eb9a1"
                    ]
                },
                {
                    "id": "14babc02-0c79-407c-9196-f8d5ab3dc85b",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Depot-Tightened Lifted MTZ Cuts\n    # Hybridizing the Desrochers-Laporte (DL) lifting with depot-adjacency logic.\n    # While Parent 1 and 2 focus on the standard DL form (RHS n-2), this offspring\n    # exploits the observation that for internal nodes i and j (not immediately adjacent \n    # to the depot), the potential difference u[i] - u[j] is bounded by (n-1) - 3 = n-4.\n    # We explicitly incorporate the depot connection variables x[i,1] and x[1,j] to \n    # 'unlock' the wider bounds only when necessary, allowing for tighter coefficients \n    # on the subtour lifting terms (n-3 vs n-1).\n    \n    n = len(model.N)\n    \n    def depot_tightened_lifted_mtz_rule(m, i, j):\n        # Apply to pairs of non-depot nodes\n        if i != 1 and j != 1 and i != j:\n            # Standard DL: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n - 2\n            # Hybrid Cut:  u[i] - u[j] + (n-3)x[i,j] + (n-5)x[j,i] - x[i,1] - x[1,j] <= n - 4\n            # Validity:\n            # 1. If x[i,j]=1 (i->j): u[i]-u[j]=-1. LHS = -1 + n-3 = n-4. Tight.\n            # 2. If disconnected from depot: u[i] <= n-1, u[j] >= 3 => u[i]-u[j] <= n-4.\n            # 3. If connected to depot (x[i,1]=1 or x[1,j]=1), the negative terms relax the RHS.\n            return m.u[i] - m.u[j] + (n - 3) * m.x[i, j] + (n - 5) * m.x[j, i] - m.x[i, 1] - m.x[1, j] <= n - 4\n        return pyo.Constraint.Skip\n    \n    model.depot_tightened_lifted_mtz = pyo.Constraint(model.N, model.N, rule=depot_tightened_lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Depot-Tightened Lifted MTZ Cuts\n# Hybridizing the Desrochers-Laporte (DL) lifting with depot-adjacency logic.\n# While Parent 1 and 2 focus on the standard DL form (RHS n-2), this offspring\n# exploits the observation that for internal nodes i and j (not immediately adjacent \n# to the depot), the potential difference u[i] - u[j] is bounded by (n-1) - 3 = n-4.\n# We explicitly incorporate the depot connection variables x[i,1] and x[1,j] to \n# 'unlock' the wider bounds only when necessary, allowing for tighter coefficients \n# on the subtour lifting terms (n-3 vs n-1).\n\nn = len(model.N)\n\ndef depot_tightened_lifted_mtz_rule(m, i, j):\n    # Apply to pairs of non-depot nodes\n    if i != 1 and j != 1 and i != j:\n        # Standard DL: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n - 2\n        # Hybrid Cut:  u[i] - u[j] + (n-3)x[i,j] + (n-5)x[j,i] - x[i,1] - x[1,j] <= n - 4\n        # Validity:\n        # 1. If x[i,j]=1 (i->j): u[i]-u[j]=-1. LHS = -1 + n-3 = n-4. Tight.\n        # 2. If disconnected from depot: u[i] <= n-1, u[j] >= 3 => u[i]-u[j] <= n-4.\n        # 3. If connected to depot (x[i,1]=1 or x[1,j]=1), the negative terms relax the RHS.\n        return m.u[i] - m.u[j] + (n - 3) * m.x[i, j] + (n - 5) * m.x[j, i] - m.x[i, 1] - m.x[1, j] <= n - 4\n    return pyo.Constraint.Skip\n\nmodel.depot_tightened_lifted_mtz = pyo.Constraint(model.N, model.N, rule=depot_tightened_lifted_mtz_rule)",
                        "idea": "This constraint tightens the Desrochers-Laporte cuts by explicitly modeling the boundary conditions of the tour. By default, internal nodes $i, j$ (not connected to the depot) have potentials restricted to $[3, n-1]$, reducing the maximum potential difference to $n-4$ (vs $n-2$). The constraint incorporates the depot arcs $x_{i,1}$ and $x_{1,j}$ as slack variables to validate this tighter bound only when nodes are endpoints. This allows reducing the Big-M coefficients on the lifting terms $x_{i,j}$ and $x_{j,i}$ by 2, significantly shrinking the relaxed feasible region for internal subtours."
                    },
                    "fitness": 0.9031322657546172,
                    "solver_reports": [
                        {
                            "gap": 33.591,
                            "total_time": 11.64,
                            "explored_nodes": 470,
                            "simplex_iterations": 10708,
                            "explored_time": 11.62,
                            "work_units": 10.05
                        },
                        {
                            "gap": 25.5389,
                            "total_time": 11.94,
                            "explored_nodes": 1,
                            "simplex_iterations": 2382,
                            "explored_time": 11.84,
                            "work_units": 10.01
                        },
                        {
                            "gap": 15.0465,
                            "total_time": 11.53,
                            "explored_nodes": 143,
                            "simplex_iterations": 5397,
                            "explored_time": 11.52,
                            "work_units": 11.95
                        },
                        {
                            "total_time": 11.42,
                            "explored_nodes": 1,
                            "simplex_iterations": 1987,
                            "explored_time": 11.29,
                            "work_units": 10.0
                        },
                        {
                            "gap": 9.4499,
                            "total_time": 10.06,
                            "explored_nodes": 1205,
                            "simplex_iterations": 23464,
                            "explored_time": 10.05,
                            "work_units": 10.03
                        },
                        {
                            "gap": 29.0264,
                            "total_time": 10.77,
                            "explored_nodes": 1,
                            "simplex_iterations": 1908,
                            "explored_time": 10.7,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.9194,
                            "total_time": 13.28,
                            "explored_nodes": 182537,
                            "simplex_iterations": 1133508,
                            "explored_time": 13.28,
                            "work_units": 10.01
                        },
                        {
                            "gap": 10.4909,
                            "total_time": 11.11,
                            "explored_nodes": 143,
                            "simplex_iterations": 7860,
                            "explored_time": 11.09,
                            "work_units": 10.01
                        },
                        {
                            "gap": 30.3628,
                            "total_time": 11.6,
                            "explored_nodes": 1,
                            "simplex_iterations": 1286,
                            "explored_time": 11.55,
                            "work_units": 10.0
                        },
                        {
                            "gap": 51.4389,
                            "total_time": 12.16,
                            "explored_nodes": 1,
                            "simplex_iterations": 1517,
                            "explored_time": 12.08,
                            "work_units": 10.07
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "eae4d92c-eb47-4bd4-b055-a79beb2778f7",
                        "f21f048b-8c56-4e0e-a346-29a759bc0024"
                    ]
                },
                {
                    "id": "1c319125-c732-44f6-9e45-61e9b87e1700",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Desrochers and Laporte (1991) Strong Lifted MTZ Constraints\n    # This constraint tightens the standard MTZ subtour elimination by lifting the reverse arc x[j,i].\n    # It replaces the standard Big-M coefficient 'n' with 'n-1' and adds '(n-3) * x[j,i]'.\n    \n    def strong_lifted_mtz_rule(model, i, j):\n        # Apply only to distinct pairs of non-depot nodes\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        \n        # Desrochers-Laporte inequality:\n        # u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\n        # Validity Check:\n        # 1. x[i,j]=1 -> u[i] - u[j] <= -1 (Consistent with u[i] < u[j])\n        # 2. x[j,i]=1 -> u[i] - u[j] <= 1  (Consistent with u[i] = u[j] + 1)\n        # 3. Both 0   -> u[i] - u[j] <= n-2 (Consistent with bounds 2..n)\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n    model.strong_lifted_mtz = pyo.Constraint(model.N, model.N, rule=strong_lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Desrochers and Laporte (1991) Strong Lifted MTZ Constraints\n# This constraint tightens the standard MTZ subtour elimination by lifting the reverse arc x[j,i].\n# It replaces the standard Big-M coefficient 'n' with 'n-1' and adds '(n-3) * x[j,i]'.\n\ndef strong_lifted_mtz_rule(model, i, j):\n    # Apply only to distinct pairs of non-depot nodes\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    \n    # Desrochers-Laporte inequality:\n    # u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\n    # Validity Check:\n    # 1. x[i,j]=1 -> u[i] - u[j] <= -1 (Consistent with u[i] < u[j])\n    # 2. x[j,i]=1 -> u[i] - u[j] <= 1  (Consistent with u[i] = u[j] + 1)\n    # 3. Both 0   -> u[i] - u[j] <= n-2 (Consistent with bounds 2..n)\n    return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\nmodel.strong_lifted_mtz = pyo.Constraint(model.N, model.N, rule=strong_lifted_mtz_rule)",
                        "idea": "We implement the Desrochers-Laporte (DL) lifted inequalities. This is a sequential lifting of the standard MTZ constraint. By considering the reverse arc $x_{j,i}$, we can strengthen the right-hand side and the Big-M coefficients. Specifically, if $x_{j,i}=1$, then $u_i - u_j = 1$, allowing the inequality to be tighter ($1 + (n-3) \\le n-2$) than the standard relaxation. This cuts off fractional solutions where $x_{i,j}$ and $x_{j,i}$ might otherwise sum to a value that satisfies the weaker MTZ constraint but violates tour logic."
                    },
                    "fitness": 4.554829604258969,
                    "solver_reports": [
                        {
                            "gap": 11.8089,
                            "total_time": 12.43,
                            "explored_nodes": 495,
                            "simplex_iterations": 10786,
                            "explored_time": 12.41,
                            "work_units": 10.04
                        },
                        {
                            "gap": 11.4825,
                            "total_time": 12.99,
                            "explored_nodes": 1,
                            "simplex_iterations": 2294,
                            "explored_time": 12.91,
                            "work_units": 10.0
                        },
                        {
                            "gap": 12.5166,
                            "total_time": 12.55,
                            "explored_nodes": 201,
                            "simplex_iterations": 8460,
                            "explored_time": 12.53,
                            "work_units": 10.05
                        },
                        {
                            "total_time": 11.71,
                            "explored_nodes": 1,
                            "simplex_iterations": 2125,
                            "explored_time": 11.62,
                            "work_units": 10.01
                        },
                        {
                            "gap": 3.9764,
                            "total_time": 12.96,
                            "explored_nodes": 3851,
                            "simplex_iterations": 48903,
                            "explored_time": 12.93,
                            "work_units": 10.0
                        },
                        {
                            "gap": 33.1642,
                            "total_time": 13.94,
                            "explored_nodes": 1,
                            "simplex_iterations": 1731,
                            "explored_time": 13.87,
                            "work_units": 10.01
                        },
                        {
                            "gap": 3.0372,
                            "total_time": 13.87,
                            "explored_nodes": 683982,
                            "simplex_iterations": 3870269,
                            "explored_time": 13.86,
                            "work_units": 10.01
                        },
                        {
                            "gap": 2.0959,
                            "total_time": 13.85,
                            "explored_nodes": 2784,
                            "simplex_iterations": 58202,
                            "explored_time": 13.81,
                            "work_units": 10.0
                        },
                        {
                            "gap": 27.8274,
                            "total_time": 10.69,
                            "explored_nodes": 59,
                            "simplex_iterations": 3310,
                            "explored_time": 10.66,
                            "work_units": 10.47
                        },
                        {
                            "gap": 22.5364,
                            "total_time": 13.75,
                            "explored_nodes": 1,
                            "simplex_iterations": 1633,
                            "explored_time": 13.68,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Lifted",
                    "parents_id": [
                        "eae4d92c-eb47-4bd4-b055-a79beb2778f7"
                    ]
                },
                {
                    "id": "3a5bd75e-aff3-4803-bf98-208a4433fbcb",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def depot_anchored_bounds_rule(model, i, bound_type):\n        # This constraint tightens the bounds of u[i] based on its connectivity to the depot (node 1).\n        # It complements the internal MTZ cuts by fixing the 'anchors' of the tour.\n        if i == 1:\n            return pyo.Constraint.Skip\n            \n        # Lower Bound Tightening:\n        # If node i is visited immediately after the depot (x[1,i]=1), then u[i] == 2.\n        # If not (x[1,i]=0), then i is at least the 3rd node visited, so u[i] >= 3.\n        # Inequality: u[i] >= 3 - x[1,i]\n        if bound_type == 'LB':\n            return model.u[i] >= 3 - model.x[1, i]\n    \n        # Upper Bound Tightening:\n        # If node i is visited immediately before the depot (x[i,1]=1), then u[i] == n.\n        # If not (x[i,1]=0), then i is at most the (n-1)-th node visited, so u[i] <= n - 1.\n        # Inequality: u[i] <= n - 1 + x[i,1]\n        elif bound_type == 'UB':\n            return model.u[i] <= n - 1 + model.x[i, 1]\n        \n        return pyo.Constraint.Skip\n    \n    model.depot_anchored_bounds = pyo.Constraint(model.N, ['LB', 'UB'], rule=depot_anchored_bounds_rule)\n\n    return model\n",
                        "added_cut": "def depot_anchored_bounds_rule(model, i, bound_type):\n    # This constraint tightens the bounds of u[i] based on its connectivity to the depot (node 1).\n    # It complements the internal MTZ cuts by fixing the 'anchors' of the tour.\n    if i == 1:\n        return pyo.Constraint.Skip\n        \n    # Lower Bound Tightening:\n    # If node i is visited immediately after the depot (x[1,i]=1), then u[i] == 2.\n    # If not (x[1,i]=0), then i is at least the 3rd node visited, so u[i] >= 3.\n    # Inequality: u[i] >= 3 - x[1,i]\n    if bound_type == 'LB':\n        return model.u[i] >= 3 - model.x[1, i]\n\n    # Upper Bound Tightening:\n    # If node i is visited immediately before the depot (x[i,1]=1), then u[i] == n.\n    # If not (x[i,1]=0), then i is at most the (n-1)-th node visited, so u[i] <= n - 1.\n    # Inequality: u[i] <= n - 1 + x[i,1]\n    elif bound_type == 'UB':\n        return model.u[i] <= n - 1 + model.x[i, 1]\n    \n    return pyo.Constraint.Skip\n\nmodel.depot_anchored_bounds = pyo.Constraint(model.N, ['LB', 'UB'], rule=depot_anchored_bounds_rule)",
                        "idea": "This offspring introduces 'Depot-Anchored Bound Tightening', a set of cuts that link the position variables $u_i$ directly to the depot's incident arcs ($x_{1,i}$ and $x_{i,1}$). While Parent 1 focuses on eliminating 2-cycles via arc variables and Parent 2 strengthens the relative ordering between internal nodes ($u_i - u_j$), this constraint tightens the absolute position bounds. Specifically, it enforces that $u_i$ can only reach its extreme values (2 or $n$) if connected directly to the depot; otherwise, the bounds are tightened to $[3, n-1]$. This explicitly removes fractional solutions where nodes 'float' at the tour boundaries without the requisite flow connections to the depot."
                    },
                    "fitness": 5.772899555008657,
                    "solver_reports": [
                        {
                            "gap": 8.5699,
                            "total_time": 12.0,
                            "explored_nodes": 4510,
                            "simplex_iterations": 59028,
                            "explored_time": 11.97,
                            "work_units": 10.0
                        },
                        {
                            "gap": 12.3068,
                            "total_time": 12.29,
                            "explored_nodes": 1,
                            "simplex_iterations": 7687,
                            "explored_time": 12.24,
                            "work_units": 10.0
                        },
                        {
                            "gap": 22.0499,
                            "total_time": 10.95,
                            "explored_nodes": 2820,
                            "simplex_iterations": 46955,
                            "explored_time": 10.94,
                            "work_units": 10.2
                        },
                        {
                            "gap": 52.3094,
                            "total_time": 14.35,
                            "explored_nodes": 1,
                            "simplex_iterations": 3427,
                            "explored_time": 14.29,
                            "work_units": 10.01
                        },
                        {
                            "gap": 7.6487,
                            "total_time": 13.13,
                            "explored_nodes": 5663,
                            "simplex_iterations": 82419,
                            "explored_time": 13.1,
                            "work_units": 10.0
                        },
                        {
                            "gap": 24.8664,
                            "total_time": 12.21,
                            "explored_nodes": 171,
                            "simplex_iterations": 14112,
                            "explored_time": 12.19,
                            "work_units": 10.35
                        },
                        {
                            "gap": 3.8072,
                            "total_time": 12.59,
                            "explored_nodes": 296574,
                            "simplex_iterations": 1959947,
                            "explored_time": 12.58,
                            "work_units": 10.04
                        },
                        {
                            "gap": 5.8906,
                            "total_time": 11.83,
                            "explored_nodes": 2748,
                            "simplex_iterations": 50223,
                            "explored_time": 11.8,
                            "work_units": 10.0
                        },
                        {
                            "gap": 17.643,
                            "total_time": 14.21,
                            "explored_nodes": 171,
                            "simplex_iterations": 10557,
                            "explored_time": 14.17,
                            "work_units": 11.35
                        },
                        {
                            "gap": 7.5398,
                            "total_time": 13.53,
                            "explored_nodes": 87,
                            "simplex_iterations": 6476,
                            "explored_time": 13.5,
                            "work_units": 11.01
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "87ae8b53-905e-4dd7-92d9-52b0979eb9a1"
                    ]
                },
                {
                    "id": "6a4a0da7-e41d-4be6-94df-c398fbf56d5c",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def comprehensive_lifted_mtz_rule(model, i, j):\n        # Unified Lifting Strategy: Covers both internal pairwise ordering and depot-anchored bounds.\n        if i == j:\n            return pyo.Constraint.Skip\n        \n        # Case 1: Internal Nodes (Both i, j != 1)\n        # Adopt Parent 1 & 2's Desrochers & Laporte lifting for relative ordering.\n        # u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} <= n-2\n        if i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n        # Case 2: Depot Outgoing (1 -> j)\n        # Hybrid feature: Tighten upper bound of u[j] using lifting logic on the depot arc.\n        # If x[1,j]=1, u[j] must be 2. (Standard bound is u[j] <= n).\n        # Lifted: u[j] <= n - (n-2)*x[1,j]\n        if i == 1:\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n    \n        # Case 3: Depot Incoming (i -> 1)\n        # Hybrid feature: Tighten lower bound of u[i] using lifting logic on the return arc.\n        # If x[i,1]=1, u[i] must be n. (Standard bound is u[i] >= 2).\n        # Lifted: u[i] >= 2 + (n-2)*x[i,1]\n        if j == 1:\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n            \n        return pyo.Constraint.Skip\n    \n    model.comprehensive_lifted_mtz = pyo.Constraint(model.N, model.N, rule=comprehensive_lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "def comprehensive_lifted_mtz_rule(model, i, j):\n    # Unified Lifting Strategy: Covers both internal pairwise ordering and depot-anchored bounds.\n    if i == j:\n        return pyo.Constraint.Skip\n    \n    # Case 1: Internal Nodes (Both i, j != 1)\n    # Adopt Parent 1 & 2's Desrochers & Laporte lifting for relative ordering.\n    # u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} <= n-2\n    if i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\n    # Case 2: Depot Outgoing (1 -> j)\n    # Hybrid feature: Tighten upper bound of u[j] using lifting logic on the depot arc.\n    # If x[1,j]=1, u[j] must be 2. (Standard bound is u[j] <= n).\n    # Lifted: u[j] <= n - (n-2)*x[1,j]\n    if i == 1:\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n\n    # Case 3: Depot Incoming (i -> 1)\n    # Hybrid feature: Tighten lower bound of u[i] using lifting logic on the return arc.\n    # If x[i,1]=1, u[i] must be n. (Standard bound is u[i] >= 2).\n    # Lifted: u[i] >= 2 + (n-2)*x[i,1]\n    if j == 1:\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n        \n    return pyo.Constraint.Skip\n\nmodel.comprehensive_lifted_mtz = pyo.Constraint(model.N, model.N, rule=comprehensive_lifted_mtz_rule)",
                        "idea": "We synthesize a comprehensive lifting strategy that unifies the internal Desrochers-Laporte cuts with strong depot-anchored bound lifting. While the parents' DL cuts tightly constrain the relative ordering of intermediate nodes ($i,j \\neq 1$), they leave the depot connections implicit. This hybrid explicitly extends the lifting logic to the depot interfaces ($1 \\to j$ and $i \\to 1$), enforcing $u_j=2$ and $u_i=n$ strictly when depot arcs are active via coefficients derived from $n$. This creates a fully tightened 'envelope' for the positional variables $u$ across the entire tour structure, dominating the standard bounds."
                    },
                    "fitness": 1.2598160141331316,
                    "solver_reports": [
                        {
                            "gap": 13.2745,
                            "total_time": 11.36,
                            "explored_nodes": 810,
                            "simplex_iterations": 18790,
                            "explored_time": 11.34,
                            "work_units": 10.03
                        },
                        {
                            "gap": 11.322,
                            "total_time": 14.4,
                            "explored_nodes": 1,
                            "simplex_iterations": 2266,
                            "explored_time": 14.27,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.2456,
                            "total_time": 11.63,
                            "explored_nodes": 456,
                            "simplex_iterations": 17496,
                            "explored_time": 11.61,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 12.71,
                            "explored_nodes": 1,
                            "simplex_iterations": 1615,
                            "explored_time": 12.58,
                            "work_units": 10.02
                        },
                        {
                            "gap": 1.037,
                            "total_time": 12.41,
                            "explored_nodes": 37689,
                            "simplex_iterations": 936834,
                            "explored_time": 12.4,
                            "work_units": 10.06
                        },
                        {
                            "total_time": 12.43,
                            "explored_nodes": 1,
                            "simplex_iterations": 1508,
                            "explored_time": 12.37,
                            "work_units": 10.09
                        },
                        {
                            "gap": 0.0,
                            "total_time": 2.94,
                            "postsolve": 0.01,
                            "explored_nodes": 60465,
                            "simplex_iterations": 375914,
                            "explored_time": 2.94,
                            "work_units": 1.86
                        },
                        {
                            "gap": 1.2806,
                            "total_time": 12.01,
                            "explored_nodes": 13735,
                            "simplex_iterations": 329922,
                            "explored_time": 11.99,
                            "work_units": 10.02
                        },
                        {
                            "gap": 7.5664,
                            "total_time": 13.18,
                            "explored_nodes": 1,
                            "simplex_iterations": 2768,
                            "explored_time": 13.15,
                            "work_units": 10.12
                        },
                        {
                            "gap": 88.2147,
                            "total_time": 13.07,
                            "explored_nodes": 1,
                            "simplex_iterations": 2294,
                            "explored_time": 13.01,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "87ae8b53-905e-4dd7-92d9-52b0979eb9a1",
                        "eae4d92c-eb47-4bd4-b055-a79beb2778f7"
                    ]
                },
                {
                    "id": "7d43389f-4ce9-4410-a379-994fd0320bf9",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def depot_position_lb_rule(model, i):\n        # If node i is not the immediate successor of the depot (x[1,i]=0),\n        # it must be at least the 3rd node in the tour (u[i] >= 3).\n        # Logic: u[i] >= 3 - x[1,i]\n        if i == 1:\n            return pyo.Constraint.Skip\n        return model.u[i] + model.x[1, i] >= 3\n    \n    def depot_position_ub_rule(model, i):\n        # If node i is not the immediate predecessor of the depot (x[i,1]=0),\n        # it cannot be the last node in the tour (u[i] <= n-1).\n        # Logic: u[i] <= (n-1) + x[i,1]\n        if i == 1:\n            return pyo.Constraint.Skip\n        return model.u[i] - model.x[i, 1] <= n - 1\n    \n    model.depot_position_lb = pyo.Constraint(model.N, rule=depot_position_lb_rule)\n    model.depot_position_ub = pyo.Constraint(model.N, rule=depot_position_ub_rule)\n\n    return model\n",
                        "added_cut": "def depot_position_lb_rule(model, i):\n    # If node i is not the immediate successor of the depot (x[1,i]=0),\n    # it must be at least the 3rd node in the tour (u[i] >= 3).\n    # Logic: u[i] >= 3 - x[1,i]\n    if i == 1:\n        return pyo.Constraint.Skip\n    return model.u[i] + model.x[1, i] >= 3\n\ndef depot_position_ub_rule(model, i):\n    # If node i is not the immediate predecessor of the depot (x[i,1]=0),\n    # it cannot be the last node in the tour (u[i] <= n-1).\n    # Logic: u[i] <= (n-1) + x[i,1]\n    if i == 1:\n        return pyo.Constraint.Skip\n    return model.u[i] - model.x[i, 1] <= n - 1\n\nmodel.depot_position_lb = pyo.Constraint(model.N, rule=depot_position_lb_rule)\nmodel.depot_position_ub = pyo.Constraint(model.N, rule=depot_position_ub_rule)",
                        "idea": "We introduce 'Depot-Anchored Position Bounds' that dynamically tighten the valid range of the potential variables $u_i$ based on their connectivity to the depot. Unlike standard MTZ constraints that focus on internal pairwise differences ($u_i - u_j$), these cuts act on the tour's endpoints: they enforce that any node not immediately following the depot must have rank $u_i \\ge 3$, and any node not immediately preceding the depot must have rank $u_i \\le n-1$. This strengthens the linear relaxation by explicitly linking the depot-incident binary variables to the integer potentials."
                    },
                    "fitness": 4.97969605589386,
                    "solver_reports": [
                        {
                            "gap": 9.7803,
                            "total_time": 12.49,
                            "explored_nodes": 3719,
                            "simplex_iterations": 58016,
                            "explored_time": 12.46,
                            "work_units": 10.0
                        },
                        {
                            "gap": 46.1022,
                            "total_time": 13.23,
                            "explored_nodes": 1,
                            "simplex_iterations": 6358,
                            "explored_time": 13.18,
                            "work_units": 10.0
                        },
                        {
                            "gap": 21.3155,
                            "total_time": 11.34,
                            "explored_nodes": 563,
                            "simplex_iterations": 18783,
                            "explored_time": 11.33,
                            "work_units": 11.05
                        },
                        {
                            "gap": 45.3316,
                            "total_time": 14.87,
                            "explored_nodes": 1,
                            "simplex_iterations": 3380,
                            "explored_time": 14.81,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1116,
                            "total_time": 10.51,
                            "explored_nodes": 2835,
                            "simplex_iterations": 62062,
                            "explored_time": 10.49,
                            "work_units": 10.01
                        },
                        {
                            "gap": 28.1667,
                            "total_time": 12.59,
                            "explored_nodes": 114,
                            "simplex_iterations": 9461,
                            "explored_time": 12.56,
                            "work_units": 10.11
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.47,
                            "explored_nodes": 291399,
                            "simplex_iterations": 1867312,
                            "explored_time": 13.47,
                            "work_units": 10.04
                        },
                        {
                            "gap": 7.8072,
                            "total_time": 10.87,
                            "explored_nodes": 4408,
                            "simplex_iterations": 67802,
                            "explored_time": 10.84,
                            "work_units": 10.0
                        },
                        {
                            "gap": 21.5371,
                            "total_time": 12.65,
                            "explored_nodes": 59,
                            "simplex_iterations": 5897,
                            "explored_time": 12.62,
                            "work_units": 11.14
                        },
                        {
                            "gap": 5.387,
                            "total_time": 15.15,
                            "explored_nodes": 87,
                            "simplex_iterations": 8137,
                            "explored_time": 15.12,
                            "work_units": 12.18
                        }
                    ],
                    "generator": "Exploratory",
                    "parents_id": [
                        "87ae8b53-905e-4dd7-92d9-52b0979eb9a1"
                    ]
                },
                {
                    "id": "ab4f89cf-85cb-4e4d-aa82-82d90a8b4fde",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # 1. Desrochers-Laporte (DL) Lifted MTZ\n    # Tightens internal subtour elimination (i,j != 1) by lifting with reverse arcs.\n    # This reduces the Big-M coeff from n to n-1 and penalizes 2-cycles (x_ji).\n    # Formula: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n    def dl_lifting_rule(m, i, j):\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    model.dl_lifting = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)\n    \n    # 2. Depot Start Anchor\n    # Enforces that if the depot connects to node j (x_1j=1), j must be the first visited city (u_j=2).\n    # Bounds logic: u_j <= n - (n-2) * x_1j\n    def start_anchor_rule(m, j):\n        if j == 1: return pyo.Constraint.Skip\n        return m.u[j] <= n - (n - 2) * m.x[1, j]\n    model.start_anchor = pyo.Constraint(model.N, rule=start_anchor_rule)\n    \n    # 3. Depot End Anchor\n    # Enforces that if node i connects to the depot (x_i1=1), i must be the last visited city (u_i=n).\n    # Bounds logic: u_i >= 2 + (n-2) * x_i1\n    def end_anchor_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        return m.u[i] >= 2 + (n - 2) * m.x[i, 1]\n    model.end_anchor = pyo.Constraint(model.N, rule=end_anchor_rule)\n\n    return model\n",
                        "added_cut": "# 1. Desrochers-Laporte (DL) Lifted MTZ\n# Tightens internal subtour elimination (i,j != 1) by lifting with reverse arcs.\n# This reduces the Big-M coeff from n to n-1 and penalizes 2-cycles (x_ji).\n# Formula: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\ndef dl_lifting_rule(m, i, j):\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\nmodel.dl_lifting = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)\n\n# 2. Depot Start Anchor\n# Enforces that if the depot connects to node j (x_1j=1), j must be the first visited city (u_j=2).\n# Bounds logic: u_j <= n - (n-2) * x_1j\ndef start_anchor_rule(m, j):\n    if j == 1: return pyo.Constraint.Skip\n    return m.u[j] <= n - (n - 2) * m.x[1, j]\nmodel.start_anchor = pyo.Constraint(model.N, rule=start_anchor_rule)\n\n# 3. Depot End Anchor\n# Enforces that if node i connects to the depot (x_i1=1), i must be the last visited city (u_i=n).\n# Bounds logic: u_i >= 2 + (n-2) * x_i1\ndef end_anchor_rule(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    return m.u[i] >= 2 + (n - 2) * m.x[i, 1]\nmodel.end_anchor = pyo.Constraint(model.N, rule=end_anchor_rule)",
                        "idea": "This hybrid cut merges 'Desrochers-Laporte Lifting' with 'Depot Anchors' to create a tightly bounded potential tunnel. The DL component strengthens the relative ordering between non-depot nodes by incorporating reverse arcs ($x_{ji}$), effectively removing 2-cycles and tightening the subtour polytope. Simultaneously, the Anchor components explicitly couple the potential variables $u$ to the depot incidence variables ($x_{1j}, x_{i1}$), strictly forcing $u_j=2$ at the start and $u_i=n$ at the end of the tour. This synergy constrains the feasible region from both internal (relative difference) and boundary (absolute value) perspectives."
                    },
                    "fitness": 0.9970115781103867,
                    "solver_reports": [
                        {
                            "gap": 10.0098,
                            "total_time": 11.79,
                            "explored_nodes": 376,
                            "simplex_iterations": 10293,
                            "explored_time": 11.77,
                            "work_units": 10.04
                        },
                        {
                            "gap": 3.119,
                            "total_time": 14.51,
                            "explored_nodes": 1,
                            "simplex_iterations": 2124,
                            "explored_time": 14.41,
                            "work_units": 10.0
                        },
                        {
                            "gap": 12.0657,
                            "total_time": 11.73,
                            "explored_nodes": 199,
                            "simplex_iterations": 11196,
                            "explored_time": 11.71,
                            "work_units": 10.33
                        },
                        {
                            "total_time": 13.05,
                            "explored_nodes": 1,
                            "simplex_iterations": 1775,
                            "explored_time": 12.91,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.2229,
                            "total_time": 10.8,
                            "explored_nodes": 3536,
                            "simplex_iterations": 46234,
                            "explored_time": 10.78,
                            "work_units": 10.0
                        },
                        {
                            "gap": 85.7841,
                            "total_time": 12.45,
                            "explored_nodes": 1,
                            "simplex_iterations": 1446,
                            "explored_time": 12.38,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 2.64,
                            "postsolve": 0.01,
                            "explored_nodes": 30694,
                            "simplex_iterations": 223917,
                            "explored_time": 2.64,
                            "work_units": 1.54
                        },
                        {
                            "gap": 2.8842,
                            "total_time": 10.07,
                            "explored_nodes": 718,
                            "simplex_iterations": 20434,
                            "explored_time": 10.05,
                            "work_units": 10.02
                        },
                        {
                            "gap": 11.5082,
                            "total_time": 11.61,
                            "explored_nodes": 59,
                            "simplex_iterations": 3028,
                            "explored_time": 11.56,
                            "work_units": 11.09
                        },
                        {
                            "gap": 87.8934,
                            "total_time": 14.24,
                            "explored_nodes": 1,
                            "simplex_iterations": 1594,
                            "explored_time": 14.16,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "87ae8b53-905e-4dd7-92d9-52b0979eb9a1",
                        "66f29ae4-6ca9-4d63-9c8e-0aa3cf34e29a"
                    ]
                }
            ],
            10.353038952236112
        ],
        [
            [
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "56480196-edda-4679-a90f-303914ea036f",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def lifted_mtz_rule(model, i, j):\n        # Lifted MTZ subtour elimination (Desrochers & Laporte, 1991)\n        # Applies to all pairs of non-depot nodes\n        if i != j and i != 1 and j != 1:\n            # Standard MTZ: u_i - u_j + n*x_{ij} <= n - 1\n            # Lifted MTZ:   u_i - u_j + (n-1)*x_{ij} + (n-3)*x_{ji} <= n - 2\n            # This constraint tightens the RHS based on the presence of the reverse arc x_{ji}.\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    \n    model.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "def lifted_mtz_rule(model, i, j):\n    # Lifted MTZ subtour elimination (Desrochers & Laporte, 1991)\n    # Applies to all pairs of non-depot nodes\n    if i != j and i != 1 and j != 1:\n        # Standard MTZ: u_i - u_j + n*x_{ij} <= n - 1\n        # Lifted MTZ:   u_i - u_j + (n-1)*x_{ij} + (n-3)*x_{ji} <= n - 2\n        # This constraint tightens the RHS based on the presence of the reverse arc x_{ji}.\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\n\nmodel.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "This offspring implements **Lifted MTZ** constraints. While Parent 1 bounds absolute position variables $u$ relative to the depot and Parent 2 targets 2-cycles ($x_{ij}+x_{ji}\\le 1$) in isolation, this constraint **couples** the relative ordering $u_i - u_j$ with both forward ($x_{ij}$) and reverse ($x_{ji}$) arcs. It strictly dominates standard MTZ by enforcing a tighter potential difference ($n-2$ vs $n-1$) when arcs are absent and ensuring $u_i - u_j \\le 1$ if the reverse arc $x_{ji}$ is active, thereby embedding 2-cycle elimination directly into the sequencing logic."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 12.03,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 12.01,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 12.87,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 12.78,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 12.97,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 12.95,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.83,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.75,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 12.66,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 12.64,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 12.38,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 12.32,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 13.87,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 13.87,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 10.62,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 10.6,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 11.66,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 11.63,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 13.36,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 13.31,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "3a5bd75e-aff3-4803-bf98-208a4433fbcb",
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "9b648fd2-f713-4194-8321-3045d614efb0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def lifted_relative_ordering_rule(model, i, j):\n        # This constraint implements the Desrochers & Laporte lifting for MTZ.\n        # It explores the bidirectional relationship between internal nodes i and j.\n        # While the provided cut anchors nodes to the depot, this strengthens the \n        # relative ordering between any two non-depot nodes by coupling the \n        # forward arc (i, j) with the backward arc (j, i).\n        if i != j and i != 1 and j != 1:\n            # The inequality: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\n            # This reduces the effective Big-M coefficient when x[j,i] is considered.\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    \n    model.lifted_relative_ordering = pyo.Constraint(model.N, model.N, rule=lifted_relative_ordering_rule)\n\n    return model\n",
                        "added_cut": "def lifted_relative_ordering_rule(model, i, j):\n    # This constraint implements the Desrochers & Laporte lifting for MTZ.\n    # It explores the bidirectional relationship between internal nodes i and j.\n    # While the provided cut anchors nodes to the depot, this strengthens the \n    # relative ordering between any two non-depot nodes by coupling the \n    # forward arc (i, j) with the backward arc (j, i).\n    if i != j and i != 1 and j != 1:\n        # The inequality: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\n        # This reduces the effective Big-M coefficient when x[j,i] is considered.\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\n\nmodel.lifted_relative_ordering = pyo.Constraint(model.N, model.N, rule=lifted_relative_ordering_rule)",
                        "idea": "This exploratory mutation introduces **Lifted Relative Ordering Constraints**, a structural tightening of the MTZ formulation. While the parent individual's 'Depot-Anchored' cuts focus on absolute bounds derived from depot connectivity, this constraint targets the **relative distance** between internal node pairs. By simultaneously penalizing the forward arc $x_{i,j}$ and the reverse arc $x_{j,i}$ (with a coefficient of $n-3$), it reduces the slack inherent in the standard 'Big-M' constraints. This strictly dominates the standard MTZ cuts, removing fractional solutions where cycles exist but satisfy weak ordering constraints, effectively probing the subtour elimination polytope's facets more deeply."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 11.46,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 11.44,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.61,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 13.51,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 13.24,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 13.21,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.71,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.62,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 12.57,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 12.54,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 12.36,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 12.29,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 14.87,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 14.86,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 10.99,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 10.97,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 11.7,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 11.67,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 13.1,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 13.05,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Exploratory",
                    "parents_id": [
                        "3a5bd75e-aff3-4803-bf98-208a4433fbcb"
                    ]
                },
                {
                    "id": "4d1cf57a-0a69-49ac-af31-f61b0f5fd8a2",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Single-Commodity Flow (SCF) constraints to strengthen subtour elimination\n    # Complements MTZ by enforcing global connectivity via auxiliary flow variables.\n    # f[i,j] represents the 'load' or 'demand' carried from the depot to customers.\n    \n    model.f = pyo.Var(model.A, domain=pyo.NonNegativeReals)\n    \n    # 1. Capacity Constraint: Flow on arc (i,j) is bounded by (n-1) and requires x[i,j]=1.\n    # This links the flow variables to the binary decision variables.\n    def scf_capacity_rule(model, i, j):\n        return model.f[i, j] <= (n - 1) * model.x[i, j]\n    model.scf_capacity = pyo.Constraint(model.A, rule=scf_capacity_rule)\n    \n    # 2. Flow Conservation: Each customer node j (non-depot) must consume exactly 1 unit of flow.\n    # Inflow - Outflow = 1. This prevents disconnected subtours as they lack a flow source.\n    def scf_conservation_rule(model, j):\n        if j == 1:\n            return pyo.Constraint.Skip\n        inflow = sum(model.f[i, j] for i in model.N if i != j)\n        outflow = sum(model.f[j, k] for k in model.N if k != j)\n        return inflow - outflow == 1\n    model.scf_conservation = pyo.Constraint(model.N, rule=scf_conservation_rule)\n    \n    # 3. Boundary Condition: No flow should return to the depot in this demand-delivery view.\n    # This explicitly cuts cycles that might otherwise circulate flow back to the start.\n    def scf_no_return_rule(model, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        return model.f[i, 1] == 0\n    model.scf_no_return = pyo.Constraint(model.N, rule=scf_no_return_rule)\n\n    return model\n",
                        "added_cut": "# Single-Commodity Flow (SCF) constraints to strengthen subtour elimination\n# Complements MTZ by enforcing global connectivity via auxiliary flow variables.\n# f[i,j] represents the 'load' or 'demand' carried from the depot to customers.\n\nmodel.f = pyo.Var(model.A, domain=pyo.NonNegativeReals)\n\n# 1. Capacity Constraint: Flow on arc (i,j) is bounded by (n-1) and requires x[i,j]=1.\n# This links the flow variables to the binary decision variables.\ndef scf_capacity_rule(model, i, j):\n    return model.f[i, j] <= (n - 1) * model.x[i, j]\nmodel.scf_capacity = pyo.Constraint(model.A, rule=scf_capacity_rule)\n\n# 2. Flow Conservation: Each customer node j (non-depot) must consume exactly 1 unit of flow.\n# Inflow - Outflow = 1. This prevents disconnected subtours as they lack a flow source.\ndef scf_conservation_rule(model, j):\n    if j == 1:\n        return pyo.Constraint.Skip\n    inflow = sum(model.f[i, j] for i in model.N if i != j)\n    outflow = sum(model.f[j, k] for k in model.N if k != j)\n    return inflow - outflow == 1\nmodel.scf_conservation = pyo.Constraint(model.N, rule=scf_conservation_rule)\n\n# 3. Boundary Condition: No flow should return to the depot in this demand-delivery view.\n# This explicitly cuts cycles that might otherwise circulate flow back to the start.\ndef scf_no_return_rule(model, i):\n    if i == 1:\n        return pyo.Constraint.Skip\n    return model.f[i, 1] == 0\nmodel.scf_no_return = pyo.Constraint(model.N, rule=scf_no_return_rule)",
                        "idea": "Parent 1 targets local 2-cycle violations and Parent 2 tightens potential bounds, but both rely on the MTZ 'potential' framework which can be weak in linear relaxation regarding connectivity. This offspring introduces a Single-Commodity Flow (SCF) extended formulation using auxiliary variables. By modeling demand flow from the depot to all customers, it enforces global graph connectivity structurally. Disconnected subtours (even fractional ones valid in MTZ) become infeasible because they lack a connection to the depot source, providing a distinct and strictly stronger relaxation than either parent."
                    },
                    "fitness": 0.22198245844162062,
                    "solver_reports": [
                        {
                            "gap": 29.3904,
                            "total_time": 11.56,
                            "explored_nodes": 1,
                            "simplex_iterations": 17455,
                            "explored_time": 11.46,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 10.61,
                            "explored_nodes": 1,
                            "simplex_iterations": 16838,
                            "explored_time": 10.53,
                            "work_units": 10.0
                        },
                        {
                            "gap": 10.1225,
                            "total_time": 12.04,
                            "explored_nodes": 1,
                            "simplex_iterations": 21902,
                            "explored_time": 12.0,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 11.76,
                            "explored_nodes": 1,
                            "simplex_iterations": 20626,
                            "explored_time": 11.65,
                            "work_units": 10.14
                        },
                        {
                            "gap": 0.0,
                            "total_time": 8.2,
                            "postsolve": 0.08,
                            "explored_nodes": 79,
                            "simplex_iterations": 43473,
                            "explored_time": 8.18,
                            "work_units": 5.69
                        },
                        {
                            "total_time": 9.93,
                            "explored_nodes": 1,
                            "simplex_iterations": 14011,
                            "explored_time": 9.85,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 0.34,
                            "postsolve": 0.01,
                            "explored_nodes": 1,
                            "simplex_iterations": 1441,
                            "explored_time": 0.33,
                            "work_units": 0.14
                        },
                        {
                            "gap": 16.739,
                            "total_time": 10.99,
                            "explored_nodes": 1,
                            "simplex_iterations": 18661,
                            "explored_time": 10.94,
                            "work_units": 10.0
                        },
                        {
                            "gap": 39.6721,
                            "total_time": 12.27,
                            "explored_nodes": 1,
                            "simplex_iterations": 15450,
                            "explored_time": 12.2,
                            "work_units": 10.0
                        },
                        {
                            "gap": 86.4875,
                            "total_time": 11.82,
                            "explored_nodes": 1,
                            "simplex_iterations": 18232,
                            "explored_time": 11.75,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "ad5bb2ca-311b-47df-8dcb-7b810972e6a4"
                    ]
                },
                {
                    "id": "1fcb940b-062c-4293-ac19-330e8b5505b4",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # 1. Internal Desrochers-Laporte Cuts\n    # Applies strong lifting to internal arcs (neither i nor j is depot) to tighten relative ordering.\n    def internal_dl_rule(model, i, j):\n        if i != 1 and j != 1 and i != j:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    model.internal_dl_cuts = pyo.Constraint(model.N, model.N, rule=internal_dl_rule)\n    \n    # 2. Unified Depot-Anchored Lower Bounds\n    # Combines P1 and P2 logic: If i follows depot (x[1,i]=1), u[i]=2. If i precedes depot (x[i,1]=1), u[i]=n.\n    # If neither, forces u[i] >= 3 (P2's strength).\n    # Formula: u[i] >= 3 - x[1,i] + (n-3)*x[i,1]\n    def unified_depot_lb_rule(model, i):\n        if i != 1:\n            return model.u[i] + model.x[1, i] - (n - 3) * model.x[i, 1] >= 3\n        return pyo.Constraint.Skip\n    model.unified_depot_lb = pyo.Constraint(model.N, rule=unified_depot_lb_rule)\n    \n    # 3. Unified Depot-Anchored Upper Bounds\n    # Complementary logic: If i follows depot, u[i]<=2. If i precedes depot, u[i]<=n.\n    # If neither, forces u[i] <= n-1.\n    # Formula: u[i] <= n - 1 - (n-3)*x[1,i] + x[i,1]\n    def unified_depot_ub_rule(model, i):\n        if i != 1:\n            return model.u[i] - model.x[i, 1] + (n - 3) * model.x[1, i] <= n - 1\n        return pyo.Constraint.Skip\n    model.unified_depot_ub = pyo.Constraint(model.N, rule=unified_depot_ub_rule)\n\n    return model\n",
                        "added_cut": "# 1. Internal Desrochers-Laporte Cuts\n# Applies strong lifting to internal arcs (neither i nor j is depot) to tighten relative ordering.\ndef internal_dl_rule(model, i, j):\n    if i != 1 and j != 1 and i != j:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\nmodel.internal_dl_cuts = pyo.Constraint(model.N, model.N, rule=internal_dl_rule)\n\n# 2. Unified Depot-Anchored Lower Bounds\n# Combines P1 and P2 logic: If i follows depot (x[1,i]=1), u[i]=2. If i precedes depot (x[i,1]=1), u[i]=n.\n# If neither, forces u[i] >= 3 (P2's strength).\n# Formula: u[i] >= 3 - x[1,i] + (n-3)*x[i,1]\ndef unified_depot_lb_rule(model, i):\n    if i != 1:\n        return model.u[i] + model.x[1, i] - (n - 3) * model.x[i, 1] >= 3\n    return pyo.Constraint.Skip\nmodel.unified_depot_lb = pyo.Constraint(model.N, rule=unified_depot_lb_rule)\n\n# 3. Unified Depot-Anchored Upper Bounds\n# Complementary logic: If i follows depot, u[i]<=2. If i precedes depot, u[i]<=n.\n# If neither, forces u[i] <= n-1.\n# Formula: u[i] <= n - 1 - (n-3)*x[1,i] + x[i,1]\ndef unified_depot_ub_rule(model, i):\n    if i != 1:\n        return model.u[i] - model.x[i, 1] + (n - 3) * model.x[1, i] <= n - 1\n    return pyo.Constraint.Skip\nmodel.unified_depot_ub = pyo.Constraint(model.N, rule=unified_depot_ub_rule)",
                        "idea": "We construct a 'Unified Strong-Bound MTZ' cut strategy that synthesizes the strongest elements of both parents. For internal arcs ($i,j \\neq 1$), it applies the Desrochers-Laporte lifting, which provides a significantly tighter subtour elimination constraint than standard MTZ. For depot connections, it merges the logic of both parents into two precise linear bounds for every node $i$: $3 - x_{1,i} + (n-3)x_{i,1} \\le u_i \\le (n-1) + x_{i,1} - (n-3)x_{1,i}$. These bounds strictly enforce $u_i=2$ for the tour start, $u_i=n$ for the tour end, and crucially restrict all other nodes to the range $[3, n-1]$, maximizing the LP relaxation tightness."
                    },
                    "fitness": 0.4695458647909325,
                    "solver_reports": [
                        {
                            "gap": 11.7626,
                            "total_time": 11.59,
                            "explored_nodes": 577,
                            "simplex_iterations": 18346,
                            "explored_time": 11.57,
                            "work_units": 10.06
                        },
                        {
                            "total_time": 13.18,
                            "explored_nodes": 1,
                            "simplex_iterations": 2209,
                            "explored_time": 13.07,
                            "work_units": 10.01
                        },
                        {
                            "gap": 11.0216,
                            "total_time": 11.49,
                            "explored_nodes": 1248,
                            "simplex_iterations": 29866,
                            "explored_time": 11.47,
                            "work_units": 10.04
                        },
                        {
                            "total_time": 13.06,
                            "explored_nodes": 1,
                            "simplex_iterations": 1972,
                            "explored_time": 12.95,
                            "work_units": 10.02
                        },
                        {
                            "gap": 4.6512,
                            "total_time": 11.29,
                            "explored_nodes": 3161,
                            "simplex_iterations": 50019,
                            "explored_time": 11.27,
                            "work_units": 10.0
                        },
                        {
                            "gap": 90.3793,
                            "total_time": 13.31,
                            "explored_nodes": 1,
                            "simplex_iterations": 1560,
                            "explored_time": 13.24,
                            "work_units": 10.02
                        },
                        {
                            "gap": 0.0,
                            "total_time": 0.85,
                            "postsolve": 0.0,
                            "explored_nodes": 8790,
                            "simplex_iterations": 55082,
                            "explored_time": 0.85,
                            "work_units": 0.54
                        },
                        {
                            "gap": 6.9425,
                            "total_time": 10.45,
                            "explored_nodes": 499,
                            "simplex_iterations": 17049,
                            "explored_time": 10.43,
                            "work_units": 10.06
                        },
                        {
                            "gap": 25.911,
                            "total_time": 12.77,
                            "explored_nodes": 1,
                            "simplex_iterations": 1140,
                            "explored_time": 12.72,
                            "work_units": 10.0
                        },
                        {
                            "gap": 87.6695,
                            "total_time": 14.05,
                            "explored_nodes": 1,
                            "simplex_iterations": 1559,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "6a4a0da7-e41d-4be6-94df-c398fbf56d5c",
                        "7d43389f-4ce9-4410-a379-994fd0320bf9"
                    ]
                },
                {
                    "id": "0163fb75-7b01-49ad-88cb-5bb0dfec5674",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def lifted_mtz_rule(model, i, j):\n        # This constraint applies to pairs of internal nodes (excluding the depot, node 1).\n        # It implements the Lifted MTZ inequality (Desrochers & Laporte, 1991).\n        if i != j and i != 1 and j != 1:\n            # Standard MTZ: u[i] - u[j] + n*x[i,j] <= n - 1\n            # Lifted MTZ strengthens this by:\n            # 1. Reducing the RHS/Big-M coefficient to (n-2), tightening the bound when x[i,j]=0.\n            # 2. Adding a penalty term (n-3)*x[j,i] for the reverse arc, linking flow direction to order.\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    \n    model.lifted_mtz_sequencing = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "def lifted_mtz_rule(model, i, j):\n    # This constraint applies to pairs of internal nodes (excluding the depot, node 1).\n    # It implements the Lifted MTZ inequality (Desrochers & Laporte, 1991).\n    if i != j and i != 1 and j != 1:\n        # Standard MTZ: u[i] - u[j] + n*x[i,j] <= n - 1\n        # Lifted MTZ strengthens this by:\n        # 1. Reducing the RHS/Big-M coefficient to (n-2), tightening the bound when x[i,j]=0.\n        # 2. Adding a penalty term (n-3)*x[j,i] for the reverse arc, linking flow direction to order.\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\n\nmodel.lifted_mtz_sequencing = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "The 'Lifted MTZ Sequencing' constraint is a complementary hybrid that integrates the strengths of both parents into a single, tighter formulation. While Parent 1 explicitly targets 2-cycles ($x_{i,j}+x_{j,i} \\le 1$) and Parent 2 anchors the position variables $u$ at the tour boundaries, this offspring unifies these concepts by introducing the reverse arc $x_{j,i}$ directly into the potential constraint. By penalizing the reverse flow and reducing the 'Big-M' coefficient from $n-1$ to $n-2$, it mathematically dominates Parent 1 (enforcing the 2-cycle cut implicitly) while propagating the bound-tightening philosophy of Parent 2 to all internal node pairs, significantly reducing the feasible region of the linear relaxation."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 12.09,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 12.07,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 12.61,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 12.53,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 12.91,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 12.89,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.86,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.78,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 12.63,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 12.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 12.44,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 12.36,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 15.53,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 15.53,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 11.05,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 11.03,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 11.51,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 11.47,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 12.99,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 12.93,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "3a5bd75e-aff3-4803-bf98-208a4433fbcb"
                    ]
                },
                {
                    "id": "d92f09d8-2a08-49cf-bebe-82c9f6e2ff4b",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Auxiliary variables to detect 2-hop paths from the depot (1 -> i -> j)\n    # depth_z[i,j] acts as a conjunction: x[1,i] AND x[i,j]\n    model.depth_z = pyo.Var(model.N, model.N, domain=pyo.NonNegativeReals)\n    \n    def depth_z_upper_x_rule(model, i, j):\n        # z[i,j] cannot exceed x[i,j]\n        if i == j or i == 1 or j == 1:\n            return pyo.Constraint.Skip\n        return model.depth_z[i, j] <= model.x[i, j]\n    model.depth_z_upper_x = pyo.Constraint(model.N, model.N, rule=depth_z_upper_x_rule)\n    \n    def depth_z_upper_depot_rule(model, i, j):\n        # z[i,j] cannot exceed x[1,i] (predecessor connected to depot)\n        if i == j or i == 1 or j == 1:\n            return pyo.Constraint.Skip\n        return model.depth_z[i, j] <= model.x[1, i]\n    model.depth_z_upper_depot = pyo.Constraint(model.N, model.N, rule=depth_z_upper_depot_rule)\n    \n    def second_order_depth_lb_rule(model, j):\n        # Tighten Lower Bound based on distance from depot:\n        # 1. Direct connection (dist=1): x[1,j]=1 => u[j] >= 2\n        # 2. 2-hop connection (dist=2): sum(z[i,j])=1 => u[j] >= 3\n        # 3. Deeper connection (dist>=3): both terms 0 => u[j] >= 4\n        if j == 1:\n            return pyo.Constraint.Skip\n        \n        # Sum of z over all potential intermediate nodes i\n        path_from_depot_2hops = sum(model.depth_z[i, j] for i in model.N if i != 1 and i != j)\n        \n        return model.u[j] >= 4 - 2 * model.x[1, j] - path_from_depot_2hops\n    \n    model.second_order_depth_lb = pyo.Constraint(model.N, rule=second_order_depth_lb_rule)\n\n    return model\n",
                        "added_cut": "# Auxiliary variables to detect 2-hop paths from the depot (1 -> i -> j)\n# depth_z[i,j] acts as a conjunction: x[1,i] AND x[i,j]\nmodel.depth_z = pyo.Var(model.N, model.N, domain=pyo.NonNegativeReals)\n\ndef depth_z_upper_x_rule(model, i, j):\n    # z[i,j] cannot exceed x[i,j]\n    if i == j or i == 1 or j == 1:\n        return pyo.Constraint.Skip\n    return model.depth_z[i, j] <= model.x[i, j]\nmodel.depth_z_upper_x = pyo.Constraint(model.N, model.N, rule=depth_z_upper_x_rule)\n\ndef depth_z_upper_depot_rule(model, i, j):\n    # z[i,j] cannot exceed x[1,i] (predecessor connected to depot)\n    if i == j or i == 1 or j == 1:\n        return pyo.Constraint.Skip\n    return model.depth_z[i, j] <= model.x[1, i]\nmodel.depth_z_upper_depot = pyo.Constraint(model.N, model.N, rule=depth_z_upper_depot_rule)\n\ndef second_order_depth_lb_rule(model, j):\n    # Tighten Lower Bound based on distance from depot:\n    # 1. Direct connection (dist=1): x[1,j]=1 => u[j] >= 2\n    # 2. 2-hop connection (dist=2): sum(z[i,j])=1 => u[j] >= 3\n    # 3. Deeper connection (dist>=3): both terms 0 => u[j] >= 4\n    if j == 1:\n        return pyo.Constraint.Skip\n    \n    # Sum of z over all potential intermediate nodes i\n    path_from_depot_2hops = sum(model.depth_z[i, j] for i in model.N if i != 1 and i != j)\n    \n    return model.u[j] >= 4 - 2 * model.x[1, j] - path_from_depot_2hops\n\nmodel.second_order_depth_lb = pyo.Constraint(model.N, rule=second_order_depth_lb_rule)",
                        "idea": "We introduce 'Second-Order Depot-Anchored Bounds' to generalize Parent 2's logic. While Parent 2 enforces $u_j \\ge 3$ for all non-depot-adjacent nodes, this cut identifies nodes at a topological distance of 3 or more and enforces $u_j \\ge 4$. By introducing auxiliary variables $z_{ij}$ (bounded by $x_{ij}$ and $x_{1,i}$) to linearize the 2-hop path detection ($1 \\to i \\to j$), the constraint $u_j \\ge 4 - 2x_{1,j} - \\sum z_{ij}$ creates a tighter, multi-tiered lower bound profile for the positional variables, significantly reducing the feasible region for deep tours compared to standard MTZ or single-tier lifting."
                    },
                    "fitness": 1.9521446885357703,
                    "solver_reports": [
                        {
                            "gap": 10.9811,
                            "total_time": 15.14,
                            "explored_nodes": 115,
                            "simplex_iterations": 25102,
                            "explored_time": 15.12,
                            "work_units": 11.7
                        },
                        {
                            "total_time": 11.93,
                            "explored_nodes": 1,
                            "simplex_iterations": 10768,
                            "explored_time": 11.83,
                            "work_units": 10.01
                        },
                        {
                            "gap": 10.7546,
                            "total_time": 14.61,
                            "explored_nodes": 115,
                            "simplex_iterations": 46177,
                            "explored_time": 14.58,
                            "work_units": 10.43
                        },
                        {
                            "total_time": 13.12,
                            "explored_nodes": 1,
                            "simplex_iterations": 4138,
                            "explored_time": 12.98,
                            "work_units": 10.01
                        },
                        {
                            "gap": 8.0114,
                            "total_time": 13.72,
                            "explored_nodes": 3525,
                            "simplex_iterations": 96637,
                            "explored_time": 13.69,
                            "work_units": 10.4
                        },
                        {
                            "total_time": 15.41,
                            "explored_nodes": 1,
                            "simplex_iterations": 5093,
                            "explored_time": 15.33,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.6752,
                            "total_time": 14.01,
                            "explored_nodes": 86498,
                            "simplex_iterations": 676366,
                            "explored_time": 14.01,
                            "work_units": 10.0
                        },
                        {
                            "gap": 5.6552,
                            "total_time": 15.27,
                            "explored_nodes": 114,
                            "simplex_iterations": 23223,
                            "explored_time": 15.24,
                            "work_units": 10.29
                        },
                        {
                            "gap": 19.2354,
                            "total_time": 14.1,
                            "explored_nodes": 1,
                            "simplex_iterations": 3913,
                            "explored_time": 14.05,
                            "work_units": 10.0
                        },
                        {
                            "gap": 34.2991,
                            "total_time": 15.23,
                            "explored_nodes": 1,
                            "simplex_iterations": 3523,
                            "explored_time": 15.18,
                            "work_units": 10.02
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "6a4a0da7-e41d-4be6-94df-c398fbf56d5c",
                        "7d43389f-4ce9-4410-a379-994fd0320bf9"
                    ]
                },
                {
                    "id": "551ef7d5-c4bb-4490-b6d6-818dbcc33b84",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def lower_envelope_rule(model, i):\n        # Apply only to non-depot nodes\n        if i == 1:\n            return pyo.Constraint.Skip\n        # Logic: If node i is not connected from the depot (x[1,i] == 0), then it cannot be at position 2.\n        # Therefore, u[i] >= 3. This can be linearized as: u[i] >= 3 - x[1,i].\n        # If x[1,i] == 1, u[i] >= 2, which is consistent with the domain.\n        return model.u[i] >= 3 - model.x[1, i]\n    \n    model.lower_envelope_cut = pyo.Constraint(model.N, rule=lower_envelope_rule)\n    \n    def upper_envelope_rule(model, i):\n        # Apply only to non-depot nodes\n        if i == 1:\n            return pyo.Constraint.Skip\n        # Logic: If node i is not connected to the depot (x[i,1] == 0), then it cannot be at position n.\n        # Therefore, u[i] <= n - 1. This can be linearized as: u[i] <= n - 1 + x[i,1].\n        # If x[i,1] == 1, u[i] <= n, which is consistent with the domain.\n        return model.u[i] <= n - 1 + model.x[i, 1]\n    \n    model.upper_envelope_cut = pyo.Constraint(model.N, rule=upper_envelope_rule)\n\n    return model\n",
                        "added_cut": "def lower_envelope_rule(model, i):\n    # Apply only to non-depot nodes\n    if i == 1:\n        return pyo.Constraint.Skip\n    # Logic: If node i is not connected from the depot (x[1,i] == 0), then it cannot be at position 2.\n    # Therefore, u[i] >= 3. This can be linearized as: u[i] >= 3 - x[1,i].\n    # If x[1,i] == 1, u[i] >= 2, which is consistent with the domain.\n    return model.u[i] >= 3 - model.x[1, i]\n\nmodel.lower_envelope_cut = pyo.Constraint(model.N, rule=lower_envelope_rule)\n\ndef upper_envelope_rule(model, i):\n    # Apply only to non-depot nodes\n    if i == 1:\n        return pyo.Constraint.Skip\n    # Logic: If node i is not connected to the depot (x[i,1] == 0), then it cannot be at position n.\n    # Therefore, u[i] <= n - 1. This can be linearized as: u[i] <= n - 1 + x[i,1].\n    # If x[i,1] == 1, u[i] <= n, which is consistent with the domain.\n    return model.u[i] <= n - 1 + model.x[i, 1]\n\nmodel.upper_envelope_cut = pyo.Constraint(model.N, rule=upper_envelope_rule)",
                        "idea": "We introduce 'Complementary Depot-Adjacency Bounds'. While the parent's strategy tightened bounds when depot arcs are *active* (forcing $u_i$ to boundaries 2 or $n$), this strategy tightens bounds when depot arcs are *inactive*. Specifically, if a node is not the first visited ($x_{1,i}=0$), its position $u_i$ must be at least 3. If it is not the last visited ($x_{i,1}=0$), its position must be at most $n-1$. These cuts remove fractional solutions where $u_i$ drifts close to the boundaries (e.g., $u_i=2.1$) without the necessary depot connection, effectively squeezing the feasible polytope from the interior."
                    },
                    "fitness": 3.79078898272111,
                    "solver_reports": [
                        {
                            "gap": 22.0005,
                            "total_time": 12.49,
                            "explored_nodes": 8227,
                            "simplex_iterations": 102073,
                            "explored_time": 12.46,
                            "work_units": 10.06
                        },
                        {
                            "gap": 15.733,
                            "total_time": 12.6,
                            "explored_nodes": 1,
                            "simplex_iterations": 6558,
                            "explored_time": 12.56,
                            "work_units": 10.05
                        },
                        {
                            "gap": 17.7516,
                            "total_time": 11.44,
                            "explored_nodes": 4808,
                            "simplex_iterations": 62266,
                            "explored_time": 11.43,
                            "work_units": 10.04
                        },
                        {
                            "gap": 45.5371,
                            "total_time": 14.72,
                            "explored_nodes": 7,
                            "simplex_iterations": 3116,
                            "explored_time": 14.67,
                            "work_units": 10.03
                        },
                        {
                            "gap": 8.7079,
                            "total_time": 12.65,
                            "explored_nodes": 5119,
                            "simplex_iterations": 73759,
                            "explored_time": 12.62,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.7092,
                            "total_time": 12.58,
                            "explored_nodes": 115,
                            "simplex_iterations": 9731,
                            "explored_time": 12.55,
                            "work_units": 10.05
                        },
                        {
                            "gap": 4.3348,
                            "total_time": 14.09,
                            "explored_nodes": 233118,
                            "simplex_iterations": 1583456,
                            "explored_time": 14.08,
                            "work_units": 10.04
                        },
                        {
                            "gap": 4.5724,
                            "total_time": 13.25,
                            "explored_nodes": 2852,
                            "simplex_iterations": 58567,
                            "explored_time": 13.22,
                            "work_units": 10.02
                        },
                        {
                            "gap": 49.5071,
                            "total_time": 13.59,
                            "explored_nodes": 171,
                            "simplex_iterations": 10385,
                            "explored_time": 13.56,
                            "work_units": 12.12
                        },
                        {
                            "gap": 6.3702,
                            "total_time": 13.92,
                            "explored_nodes": 87,
                            "simplex_iterations": 9900,
                            "explored_time": 13.88,
                            "work_units": 11.31
                        }
                    ],
                    "generator": "Exploratory",
                    "parents_id": [
                        "6a4a0da7-e41d-4be6-94df-c398fbf56d5c"
                    ]
                }
            ],
            10.353038952236112
        ],
        [
            [
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "5a272502-eaad-4d7c-b0fa-fb535f77bc92",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Hybrid Constraint: Lifted MTZ with Depot-Depth Lower Bounds\n    # This hybrid constraint integrates Parent 2's 2-cycle elimination logic directly into Parent 1's\n    # positional variable structure using the Desrochers & Laporte lifting, and adds a simplified\n    # version of Parent 1's topological depth bounds.\n    \n    # 1. Depot-Depth Lower Bound: Enforces u[j] >= 3 if j is not directly connected to the depot.\n    #    This captures Parent 1's idea of layering u-values based on distance from the depot,\n    #    simplified to a linear form (u[j] >= 3 - x[1,j]) that requires no auxiliary variables.\n    def depot_depth_lb_rule(m, j):\n        if j == 1:\n            return pyo.Constraint.Skip\n        # If x[1,j]=1, u[j]>=2 (satisfied by bounds). If x[1,j]=0, u[j] must be >= 3.\n        return m.u[j] >= 3 - m.x[1, j]\n    model.depot_depth_lb = pyo.Constraint(model.N, rule=depot_depth_lb_rule)\n    \n    # 2. Lifted MTZ (Desrochers & Laporte): A stronger subtour elimination constraint that\n    #    synthesizes Parent 2's logic (preventing 2-cycles) with Parent 1's domain (u variables).\n    #    By including the reverse arc term (n-3)*x[j,i], it implicitly enforces x[i,j] + x[j,i] <= 1\n    #    in the linear relaxation and tightens the big-M coefficient from n to (n-1).\n    def lifted_mtz_rule(m, i, j):\n        if i != j and i != 1 and j != 1:\n            # Standard: u_i - u_j + n*x_ij <= n-1\n            # Lifted:   u_i - u_j + (n-1)*x_ij + (n-3)*x_ji <= n-2\n            return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    model.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Hybrid Constraint: Lifted MTZ with Depot-Depth Lower Bounds\n# This hybrid constraint integrates Parent 2's 2-cycle elimination logic directly into Parent 1's\n# positional variable structure using the Desrochers & Laporte lifting, and adds a simplified\n# version of Parent 1's topological depth bounds.\n\n# 1. Depot-Depth Lower Bound: Enforces u[j] >= 3 if j is not directly connected to the depot.\n#    This captures Parent 1's idea of layering u-values based on distance from the depot,\n#    simplified to a linear form (u[j] >= 3 - x[1,j]) that requires no auxiliary variables.\ndef depot_depth_lb_rule(m, j):\n    if j == 1:\n        return pyo.Constraint.Skip\n    # If x[1,j]=1, u[j]>=2 (satisfied by bounds). If x[1,j]=0, u[j] must be >= 3.\n    return m.u[j] >= 3 - m.x[1, j]\nmodel.depot_depth_lb = pyo.Constraint(model.N, rule=depot_depth_lb_rule)\n\n# 2. Lifted MTZ (Desrochers & Laporte): A stronger subtour elimination constraint that\n#    synthesizes Parent 2's logic (preventing 2-cycles) with Parent 1's domain (u variables).\n#    By including the reverse arc term (n-3)*x[j,i], it implicitly enforces x[i,j] + x[j,i] <= 1\n#    in the linear relaxation and tightens the big-M coefficient from n to (n-1).\ndef lifted_mtz_rule(m, i, j):\n    if i != j and i != 1 and j != 1:\n        # Standard: u_i - u_j + n*x_ij <= n-1\n        # Lifted:   u_i - u_j + (n-1)*x_ij + (n-3)*x_ji <= n-2\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\nmodel.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "We combine Parent 2's high-fitness 2-cycle elimination logic with Parent 1's positional bounding strategy. We implement the Desrochers & Laporte 'Lifted MTZ' constraints, which incorporate the reverse arc $x_{ji}$ into the potential constraint; this mathematically implies $x_{ij} + x_{ji} \\le 1$ in the relaxation (Parent 2's goal) while significantly tightening the coefficients governing $u$ (Parent 1's domain). We augment this with 'Depot-Depth' cuts ($u_j \\ge 3 - x_{1,j}$), a simplified, variable-free realization of Parent 1's topological depth logic, ensuring that any node not immediately following the depot is pushed deeper into the tour order."
                    },
                    "fitness": 0.36619060368435147,
                    "solver_reports": [
                        {
                            "gap": 10.4875,
                            "total_time": 11.65,
                            "explored_nodes": 828,
                            "simplex_iterations": 12469,
                            "explored_time": 11.63,
                            "work_units": 10.16
                        },
                        {
                            "gap": 19.938,
                            "total_time": 14.03,
                            "explored_nodes": 1,
                            "simplex_iterations": 2242,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 23.8764,
                            "total_time": 12.52,
                            "explored_nodes": 59,
                            "simplex_iterations": 4742,
                            "explored_time": 12.5,
                            "work_units": 10.5
                        },
                        {
                            "total_time": 12.77,
                            "explored_nodes": 1,
                            "simplex_iterations": 2292,
                            "explored_time": 12.67,
                            "work_units": 10.01
                        },
                        {
                            "gap": 7.5823,
                            "total_time": 11.75,
                            "explored_nodes": 3232,
                            "simplex_iterations": 44226,
                            "explored_time": 11.72,
                            "work_units": 10.0
                        },
                        {
                            "gap": 18.7123,
                            "total_time": 12.6,
                            "explored_nodes": 1,
                            "simplex_iterations": 1601,
                            "explored_time": 12.52,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.8785,
                            "total_time": 13.44,
                            "explored_nodes": 315643,
                            "simplex_iterations": 2033032,
                            "explored_time": 13.43,
                            "work_units": 10.01
                        },
                        {
                            "gap": 7.6828,
                            "total_time": 12.43,
                            "explored_nodes": 1,
                            "simplex_iterations": 2636,
                            "explored_time": 12.4,
                            "work_units": 10.0
                        },
                        {
                            "gap": 58.4423,
                            "total_time": 12.36,
                            "explored_nodes": 59,
                            "simplex_iterations": 4369,
                            "explored_time": 12.32,
                            "work_units": 10.25
                        },
                        {
                            "gap": 87.3304,
                            "total_time": 12.77,
                            "explored_nodes": 1,
                            "simplex_iterations": 2369,
                            "explored_time": 12.69,
                            "work_units": 10.04
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "d92f09d8-2a08-49cf-bebe-82c9f6e2ff4b",
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "0314d3ee-e1a8-497c-9e95-0011eaf94de2",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Hybrid Constraint: Symmetric Depot-Depth Bounds\n    # This combines the auxiliary variable structure of Parent 2 with the bidirectional\n    # logic of Parent 1. We introduce 'depth_z' for forward 2-hop paths (1 -> i -> j)\n    # and 'depth_y' for backward 2-hop paths (j -> i -> 1).\n    # This allows us to tighten both the Lower Bound and Upper Bound of u[j] simultaneously.\n    \n    # 1. Forward Auxiliary Variables (from Parent 2): Detect 1 -> i -> j\n    model.depth_z = pyo.Var(model.N, model.N, domain=pyo.NonNegativeReals)\n    \n    def depth_z_upper_x_rule(model, i, j):\n        if i == j or i == 1 or j == 1:\n            return pyo.Constraint.Skip\n        return model.depth_z[i, j] <= model.x[i, j]\n    model.depth_z_upper_x = pyo.Constraint(model.N, model.N, rule=depth_z_upper_x_rule)\n    \n    def depth_z_upper_depot_rule(model, i, j):\n        if i == j or i == 1 or j == 1:\n            return pyo.Constraint.Skip\n        return model.depth_z[i, j] <= model.x[1, i]\n    model.depth_z_upper_depot = pyo.Constraint(model.N, model.N, rule=depth_z_upper_depot_rule)\n    \n    # 2. Backward Auxiliary Variables (Novel, inspired by Parent 1): Detect j -> i -> 1\n    model.depth_y = pyo.Var(model.N, model.N, domain=pyo.NonNegativeReals)\n    \n    def depth_y_upper_x_rule(model, j, i):\n        if i == j or i == 1 or j == 1:\n            return pyo.Constraint.Skip\n        return model.depth_y[j, i] <= model.x[j, i]\n    model.depth_y_upper_x = pyo.Constraint(model.N, model.N, rule=depth_y_upper_x_rule)\n    \n    def depth_y_upper_depot_rule(model, j, i):\n        if i == j or i == 1 or j == 1:\n            return pyo.Constraint.Skip\n        return model.depth_y[j, i] <= model.x[i, 1]\n    model.depth_y_upper_depot = pyo.Constraint(model.N, model.N, rule=depth_y_upper_depot_rule)\n    \n    # 3. Symmetric Bounds Rules\n    def symmetric_depth_lb_rule(model, j):\n        # Tighten LB: u[j] >= 4 if j is deep (dist >= 3)\n        # Logic: Start with 4. Reduce if 1->j (dist 1) or 1->i->j (dist 2).\n        # Lift: If j->1 (last node), increase bound to n via (n-4)*x[j,1].\n        if j == 1 or n < 4:\n            return pyo.Constraint.Skip\n        \n        path_from_depot_2hops = sum(model.depth_z[i, j] for i in model.N if i != 1 and i != j)\n        return model.u[j] >= 4 - 2 * model.x[1, j] - path_from_depot_2hops + (n - 4) * model.x[j, 1]\n    \n    model.symmetric_depth_lb = pyo.Constraint(model.N, rule=symmetric_depth_lb_rule)\n    \n    def symmetric_depth_ub_rule(model, j):\n        # Tighten UB: u[j] <= n-2 if j is shallow from end (dist_from_end >= 3)\n        # Logic: Start with n-2. Increase if j->1 (last, +2) or j->i->1 (2nd last, +1).\n        if j == 1 or n < 4:\n            return pyo.Constraint.Skip\n    \n        path_to_depot_2hops = sum(model.depth_y[j, i] for i in model.N if i != 1 and i != j)\n        return model.u[j] <= (n - 2) + 2 * model.x[j, 1] + path_to_depot_2hops\n    \n    model.symmetric_depth_ub = pyo.Constraint(model.N, rule=symmetric_depth_ub_rule)\n\n    return model\n",
                        "added_cut": "# Hybrid Constraint: Symmetric Depot-Depth Bounds\n# This combines the auxiliary variable structure of Parent 2 with the bidirectional\n# logic of Parent 1. We introduce 'depth_z' for forward 2-hop paths (1 -> i -> j)\n# and 'depth_y' for backward 2-hop paths (j -> i -> 1).\n# This allows us to tighten both the Lower Bound and Upper Bound of u[j] simultaneously.\n\n# 1. Forward Auxiliary Variables (from Parent 2): Detect 1 -> i -> j\nmodel.depth_z = pyo.Var(model.N, model.N, domain=pyo.NonNegativeReals)\n\ndef depth_z_upper_x_rule(model, i, j):\n    if i == j or i == 1 or j == 1:\n        return pyo.Constraint.Skip\n    return model.depth_z[i, j] <= model.x[i, j]\nmodel.depth_z_upper_x = pyo.Constraint(model.N, model.N, rule=depth_z_upper_x_rule)\n\ndef depth_z_upper_depot_rule(model, i, j):\n    if i == j or i == 1 or j == 1:\n        return pyo.Constraint.Skip\n    return model.depth_z[i, j] <= model.x[1, i]\nmodel.depth_z_upper_depot = pyo.Constraint(model.N, model.N, rule=depth_z_upper_depot_rule)\n\n# 2. Backward Auxiliary Variables (Novel, inspired by Parent 1): Detect j -> i -> 1\nmodel.depth_y = pyo.Var(model.N, model.N, domain=pyo.NonNegativeReals)\n\ndef depth_y_upper_x_rule(model, j, i):\n    if i == j or i == 1 or j == 1:\n        return pyo.Constraint.Skip\n    return model.depth_y[j, i] <= model.x[j, i]\nmodel.depth_y_upper_x = pyo.Constraint(model.N, model.N, rule=depth_y_upper_x_rule)\n\ndef depth_y_upper_depot_rule(model, j, i):\n    if i == j or i == 1 or j == 1:\n        return pyo.Constraint.Skip\n    return model.depth_y[j, i] <= model.x[i, 1]\nmodel.depth_y_upper_depot = pyo.Constraint(model.N, model.N, rule=depth_y_upper_depot_rule)\n\n# 3. Symmetric Bounds Rules\ndef symmetric_depth_lb_rule(model, j):\n    # Tighten LB: u[j] >= 4 if j is deep (dist >= 3)\n    # Logic: Start with 4. Reduce if 1->j (dist 1) or 1->i->j (dist 2).\n    # Lift: If j->1 (last node), increase bound to n via (n-4)*x[j,1].\n    if j == 1 or n < 4:\n        return pyo.Constraint.Skip\n    \n    path_from_depot_2hops = sum(model.depth_z[i, j] for i in model.N if i != 1 and i != j)\n    return model.u[j] >= 4 - 2 * model.x[1, j] - path_from_depot_2hops + (n - 4) * model.x[j, 1]\n\nmodel.symmetric_depth_lb = pyo.Constraint(model.N, rule=symmetric_depth_lb_rule)\n\ndef symmetric_depth_ub_rule(model, j):\n    # Tighten UB: u[j] <= n-2 if j is shallow from end (dist_from_end >= 3)\n    # Logic: Start with n-2. Increase if j->1 (last, +2) or j->i->1 (2nd last, +1).\n    if j == 1 or n < 4:\n        return pyo.Constraint.Skip\n\n    path_to_depot_2hops = sum(model.depth_y[j, i] for i in model.N if i != 1 and i != j)\n    return model.u[j] <= (n - 2) + 2 * model.x[j, 1] + path_to_depot_2hops\n\nmodel.symmetric_depth_ub = pyo.Constraint(model.N, rule=symmetric_depth_ub_rule)",
                        "idea": "This hybrid constraint implements 'Symmetric Depot-Depth Bounds', effectively fusing Parent 2's auxiliary variable depth-detection with Parent 1's philosophy of bidirectional constraint tightening. By introducing explicit variables for both forward 2-hop paths ($1 \\to i \\to j$) and backward 2-hop paths ($j \\to i \\to 1$), we construct a structural tunnel for the positional variables $u_j$. The Lower Bound constraint pushes $u_j$ up based on distance from the start, while the Upper Bound constraint pushes $u_j$ down based on distance to the end. This symmetric squeezing strictly dominates standard MTZ bounds and leverages the high-fitness logic of Parent 2 to probe facets on both ends of the tour."
                    },
                    "fitness": 0.594229401061928,
                    "solver_reports": [
                        {
                            "gap": 37.3771,
                            "total_time": 15.61,
                            "explored_nodes": 1,
                            "simplex_iterations": 14210,
                            "explored_time": 15.58,
                            "work_units": 10.0
                        },
                        {
                            "gap": 58.562,
                            "total_time": 11.76,
                            "explored_nodes": 1,
                            "simplex_iterations": 16784,
                            "explored_time": 11.57,
                            "work_units": 10.11
                        },
                        {
                            "gap": 17.9405,
                            "total_time": 14.69,
                            "explored_nodes": 5,
                            "simplex_iterations": 19384,
                            "explored_time": 14.63,
                            "work_units": 10.05
                        },
                        {
                            "total_time": 11.81,
                            "explored_nodes": 1,
                            "simplex_iterations": 22295,
                            "explored_time": 11.61,
                            "work_units": 10.02
                        },
                        {
                            "gap": 6.4327,
                            "total_time": 12.35,
                            "explored_nodes": 942,
                            "simplex_iterations": 78836,
                            "explored_time": 12.33,
                            "work_units": 10.03
                        },
                        {
                            "total_time": 11.56,
                            "explored_nodes": 1,
                            "simplex_iterations": 20126,
                            "explored_time": 11.43,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.6343,
                            "total_time": 14.58,
                            "explored_nodes": 57045,
                            "simplex_iterations": 484327,
                            "explored_time": 14.58,
                            "work_units": 10.01
                        },
                        {
                            "gap": 14.5009,
                            "total_time": 16.08,
                            "explored_nodes": 1,
                            "simplex_iterations": 18222,
                            "explored_time": 16.04,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 13.3,
                            "explored_nodes": 1,
                            "simplex_iterations": 19551,
                            "explored_time": 13.22,
                            "work_units": 10.01
                        },
                        {
                            "gap": 44.3429,
                            "total_time": 14.03,
                            "explored_nodes": 1,
                            "simplex_iterations": 16484,
                            "explored_time": 13.89,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "9b648fd2-f713-4194-8321-3045d614efb0",
                        "d92f09d8-2a08-49cf-bebe-82c9f6e2ff4b"
                    ]
                },
                {
                    "id": "9e3332ae-38e4-4511-bfc9-4df633734c13",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Strengthened bounds on position variables u based on depot connectivity\n    # Inherits positional logic from Parent 1 and structural binary logic from Parent 2\n    \n    def depot_strong_lb_rule(model, i):\n        # Lower Bound Tightening:\n        # If arc (i, 1) is used (return to depot), node i is last, so u[i] must be n.\n        # Inequality: u[i] >= 2 + (n - 2) * x[i, 1]\n        if i != 1:\n            return model.u[i] >= 2 + (n - 2) * model.x[i, 1]\n        return pyo.Constraint.Skip\n    model.depot_strong_lb = pyo.Constraint(model.N, rule=depot_strong_lb_rule)\n    \n    def depot_strong_ub_rule(model, i):\n        # Upper Bound Tightening:\n        # If arc (1, i) is used (leave depot), node i is first, so u[i] must be 2.\n        # Inequality: u[i] <= n - (n - 2) * x[1, i]\n        if i != 1:\n            return model.u[i] <= n - (n - 2) * model.x[1, i]\n        return pyo.Constraint.Skip\n    model.depot_strong_ub = pyo.Constraint(model.N, rule=depot_strong_ub_rule)\n\n    return model\n",
                        "added_cut": "# Strengthened bounds on position variables u based on depot connectivity\n# Inherits positional logic from Parent 1 and structural binary logic from Parent 2\n\ndef depot_strong_lb_rule(model, i):\n    # Lower Bound Tightening:\n    # If arc (i, 1) is used (return to depot), node i is last, so u[i] must be n.\n    # Inequality: u[i] >= 2 + (n - 2) * x[i, 1]\n    if i != 1:\n        return model.u[i] >= 2 + (n - 2) * model.x[i, 1]\n    return pyo.Constraint.Skip\nmodel.depot_strong_lb = pyo.Constraint(model.N, rule=depot_strong_lb_rule)\n\ndef depot_strong_ub_rule(model, i):\n    # Upper Bound Tightening:\n    # If arc (1, i) is used (leave depot), node i is first, so u[i] must be 2.\n    # Inequality: u[i] <= n - (n - 2) * x[1, i]\n    if i != 1:\n        return model.u[i] <= n - (n - 2) * model.x[1, i]\n    return pyo.Constraint.Skip\nmodel.depot_strong_ub = pyo.Constraint(model.N, rule=depot_strong_ub_rule)",
                        "idea": "This offspring implements **Depot-Position Tightening**, a constraint set that fuses the variable-ordering concept of Parent 1 with the binary structural enforcement of Parent 2. By explicitly coupling the continuous position variables $u_i$ with the depot-incident arcs ($x_{1,i}$ and $x_{i,1}$), it replaces the loose generic bounds of the MTZ formulation with tight conditional limits ($x_{1,i}=1 \\implies u_i=2$ and $x_{i,1}=1 \\implies u_i=n$). This significantly restricts the linear relaxation space, preventing fractional solutions that exploit floating $u$ values, thus acting as a robust structural stabilizer derived from the logic of both parents."
                    },
                    "fitness": 7.574143807819105,
                    "solver_reports": [
                        {
                            "gap": 9.2893,
                            "total_time": 12.7,
                            "explored_nodes": 4200,
                            "simplex_iterations": 57100,
                            "explored_time": 12.67,
                            "work_units": 10.0
                        },
                        {
                            "gap": 2.3443,
                            "total_time": 14.0,
                            "explored_nodes": 102,
                            "simplex_iterations": 9188,
                            "explored_time": 13.96,
                            "work_units": 10.03
                        },
                        {
                            "gap": 8.8891,
                            "total_time": 11.55,
                            "explored_nodes": 882,
                            "simplex_iterations": 19372,
                            "explored_time": 11.54,
                            "work_units": 10.04
                        },
                        {
                            "gap": 92.2872,
                            "total_time": 15.64,
                            "explored_nodes": 1,
                            "simplex_iterations": 3502,
                            "explored_time": 15.56,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.0747,
                            "total_time": 12.92,
                            "explored_nodes": 3741,
                            "simplex_iterations": 64275,
                            "explored_time": 12.91,
                            "work_units": 10.01
                        },
                        {
                            "gap": 22.1117,
                            "total_time": 14.91,
                            "explored_nodes": 165,
                            "simplex_iterations": 8769,
                            "explored_time": 14.88,
                            "work_units": 11.25
                        },
                        {
                            "gap": 4.7055,
                            "total_time": 13.62,
                            "explored_nodes": 212017,
                            "simplex_iterations": 1572997,
                            "explored_time": 13.61,
                            "work_units": 10.03
                        },
                        {
                            "gap": 3.2445,
                            "total_time": 12.85,
                            "explored_nodes": 2854,
                            "simplex_iterations": 66244,
                            "explored_time": 12.82,
                            "work_units": 10.0
                        },
                        {
                            "gap": 24.8031,
                            "total_time": 11.82,
                            "explored_nodes": 87,
                            "simplex_iterations": 7265,
                            "explored_time": 11.8,
                            "work_units": 10.64
                        },
                        {
                            "gap": 9.7595,
                            "total_time": 14.07,
                            "explored_nodes": 255,
                            "simplex_iterations": 11500,
                            "explored_time": 14.05,
                            "work_units": 11.42
                        }
                    ],
                    "generator": "Min_Violation",
                    "parents_id": [
                        "56480196-edda-4679-a90f-303914ea036f",
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "a3ca7110-6fe6-4524-803f-98f276760182",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def depot_position_bounds_rule(model, i):\n        # Applies to all non-depot nodes\n        if i != 1:\n            # Constraint 1: Lower Bound Strengthening\n            # If node i is not the immediate successor of the depot (x[1,i]=0), \n            # it cannot be at position 2, so u[i] >= 3.\n            model.u_lower_tight = pyo.Constraint(expr=model.u[i] >= 3 - model.x[1, i])\n            \n            # Constraint 2: Upper Bound Strengthening\n            # If node i is not the immediate predecessor of the depot (x[i,1]=0), \n            # it cannot be at position n, so u[i] <= n - 1.\n            model.u_upper_tight = pyo.Constraint(expr=model.u[i] <= (n - 1) + model.x[i, 1])\n            \n            # Returning a list or block is possible, but here we define specific \n            # indexed constraints attached to the model outside the rule for clarity, \n            # or return a conjunction if supported. \n            # Best practice for single rule injection: return a list of constraints for this index.\n            return [model.u_lower_tight, model.u_upper_tight]\n        return pyo.Constraint.Skip\n    \n    # To ensure compatibility with standard Pyomo rule structures (which expect one expression),\n    # we split this into two explicit constraint definitions.\n    \n    def pos_lb_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        return m.u[i] >= 3 - m.x[1, i]\n    \n    def pos_ub_rule(m, i):\n        if i == 1: return pyo.Constraint.Skip\n        return m.u[i] <= (n - 1) + m.x[i, 1]\n    \n    model.depot_pos_lb = pyo.Constraint(model.N, rule=pos_lb_rule)\n    model.depot_pos_ub = pyo.Constraint(model.N, rule=pos_ub_rule)\n\n    return model\n",
                        "added_cut": "def depot_position_bounds_rule(model, i):\n    # Applies to all non-depot nodes\n    if i != 1:\n        # Constraint 1: Lower Bound Strengthening\n        # If node i is not the immediate successor of the depot (x[1,i]=0), \n        # it cannot be at position 2, so u[i] >= 3.\n        model.u_lower_tight = pyo.Constraint(expr=model.u[i] >= 3 - model.x[1, i])\n        \n        # Constraint 2: Upper Bound Strengthening\n        # If node i is not the immediate predecessor of the depot (x[i,1]=0), \n        # it cannot be at position n, so u[i] <= n - 1.\n        model.u_upper_tight = pyo.Constraint(expr=model.u[i] <= (n - 1) + model.x[i, 1])\n        \n        # Returning a list or block is possible, but here we define specific \n        # indexed constraints attached to the model outside the rule for clarity, \n        # or return a conjunction if supported. \n        # Best practice for single rule injection: return a list of constraints for this index.\n        return [model.u_lower_tight, model.u_upper_tight]\n    return pyo.Constraint.Skip\n\n# To ensure compatibility with standard Pyomo rule structures (which expect one expression),\n# we split this into two explicit constraint definitions.\n\ndef pos_lb_rule(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    return m.u[i] >= 3 - m.x[1, i]\n\ndef pos_ub_rule(m, i):\n    if i == 1: return pyo.Constraint.Skip\n    return m.u[i] <= (n - 1) + m.x[i, 1]\n\nmodel.depot_pos_lb = pyo.Constraint(model.N, rule=pos_lb_rule)\nmodel.depot_pos_ub = pyo.Constraint(model.N, rule=pos_ub_rule)",
                        "idea": "This exploratory cut implements **Depot-Dependent Position Bounding**, shifting focus from the relative ordering between pairs of nodes (as in MTZ and Lifted MTZ) to the **absolute** feasible domain of the position variables $u_i$. In the standard relaxation, $u_i$ is loosely bounded in $[2, n]$. These constraints strictly enforce that if a node $i$ is not directly connected to the depot (i.e., $x_{1,i}=0$ or $x_{i,1}=0$), its position must be restricted to $[3, n-1]$. This dynamically tightens the feasible region for $u$, strengthening the Big-M implications in the MTZ constraints and pruning fractional solutions where position values do not align with depot connectivity."
                    },
                    "fitness": 4.97969605589386,
                    "solver_reports": [
                        {
                            "gap": 9.7803,
                            "total_time": 12.66,
                            "explored_nodes": 3719,
                            "simplex_iterations": 58016,
                            "explored_time": 12.62,
                            "work_units": 10.0
                        },
                        {
                            "gap": 46.1022,
                            "total_time": 12.39,
                            "explored_nodes": 1,
                            "simplex_iterations": 6358,
                            "explored_time": 12.35,
                            "work_units": 10.0
                        },
                        {
                            "gap": 21.3155,
                            "total_time": 12.41,
                            "explored_nodes": 563,
                            "simplex_iterations": 18783,
                            "explored_time": 12.4,
                            "work_units": 11.05
                        },
                        {
                            "gap": 45.3316,
                            "total_time": 14.7,
                            "explored_nodes": 1,
                            "simplex_iterations": 3380,
                            "explored_time": 14.64,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1116,
                            "total_time": 11.47,
                            "explored_nodes": 2835,
                            "simplex_iterations": 62062,
                            "explored_time": 11.45,
                            "work_units": 10.01
                        },
                        {
                            "gap": 28.1667,
                            "total_time": 13.76,
                            "explored_nodes": 114,
                            "simplex_iterations": 9461,
                            "explored_time": 13.73,
                            "work_units": 10.11
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.74,
                            "explored_nodes": 291399,
                            "simplex_iterations": 1867312,
                            "explored_time": 13.73,
                            "work_units": 10.04
                        },
                        {
                            "gap": 7.8072,
                            "total_time": 11.35,
                            "explored_nodes": 4408,
                            "simplex_iterations": 67802,
                            "explored_time": 11.32,
                            "work_units": 10.0
                        },
                        {
                            "gap": 21.5371,
                            "total_time": 12.34,
                            "explored_nodes": 59,
                            "simplex_iterations": 5897,
                            "explored_time": 12.31,
                            "work_units": 11.14
                        },
                        {
                            "gap": 5.387,
                            "total_time": 14.91,
                            "explored_nodes": 87,
                            "simplex_iterations": 8137,
                            "explored_time": 14.88,
                            "work_units": 12.18
                        }
                    ],
                    "generator": "Exploratory",
                    "parents_id": [
                        "56480196-edda-4679-a90f-303914ea036f"
                    ]
                },
                {
                    "id": "6aa0b41b-381c-477c-b814-228795b92302",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Combined Cut: Integrates Explicit 2-Cycle Elimination (Parent 2) and Lifted MTZ (Parent 1)\n    model.combined_cuts = pyo.ConstraintList()\n    for i in model.N:\n        for j in model.N:\n            # 1. Explicit 2-Cycle Cuts (derived from Parent 2)\n            # High fitness indicates strong performance in cutting fractional 2-loops (x_ij = x_ji = 0.5).\n            if i < j:\n                model.combined_cuts.add(model.x[i, j] + model.x[j, i] <= 1)\n            \n            # 2. Lifted MTZ Constraints (derived from Parent 1)\n            # Tightens the standard MTZ relaxation by coupling the potential difference (u_i - u_j)\n            # with the reverse arc x_ji. This reduces the effective Big-M coefficient.\n            if i != j and i != 1 and j != 1:\n                model.combined_cuts.add(\n                    model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n                )\n\n    return model\n",
                        "added_cut": "# Combined Cut: Integrates Explicit 2-Cycle Elimination (Parent 2) and Lifted MTZ (Parent 1)\nmodel.combined_cuts = pyo.ConstraintList()\nfor i in model.N:\n    for j in model.N:\n        # 1. Explicit 2-Cycle Cuts (derived from Parent 2)\n        # High fitness indicates strong performance in cutting fractional 2-loops (x_ij = x_ji = 0.5).\n        if i < j:\n            model.combined_cuts.add(model.x[i, j] + model.x[j, i] <= 1)\n        \n        # 2. Lifted MTZ Constraints (derived from Parent 1)\n        # Tightens the standard MTZ relaxation by coupling the potential difference (u_i - u_j)\n        # with the reverse arc x_ji. This reduces the effective Big-M coefficient.\n        if i != j and i != 1 and j != 1:\n            model.combined_cuts.add(\n                model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n            )",
                        "idea": "This hybrid constraint merges the high-fitness structural pruning of Parent 2 with the tighter relaxation of Parent 1. While Standard MTZ is weak against fractional 2-cycles, Parent 2's explicit cuts ($x_{ij} + x_{ji} \\le 1$) directly remove these infeasible points from the LP polytope. Simultaneously, Parent 1's 'Lifted' logic is applied to non-depot nodes to strictly dominate the standard MTZ constraints: it lowers the Big-M coefficient from $n$ to $n-1$ and incorporates the reverse arc ($x_{ji}$) to bound the potential difference $u_i - u_j$ more aggressively ($n-2$ vs $n-1$). This combination ensures both structural feasibility (binary cuts) and tighter sequencing bounds (continuous cuts)."
                    },
                    "fitness": 2.5516122789515943,
                    "solver_reports": [
                        {
                            "gap": 20.0463,
                            "total_time": 12.39,
                            "explored_nodes": 31,
                            "simplex_iterations": 2978,
                            "explored_time": 12.36,
                            "work_units": 10.13
                        },
                        {
                            "total_time": 10.51,
                            "explored_nodes": 1,
                            "simplex_iterations": 2758,
                            "explored_time": 10.44,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4378,
                            "total_time": 11.72,
                            "explored_nodes": 929,
                            "simplex_iterations": 19759,
                            "explored_time": 11.7,
                            "work_units": 10.02
                        },
                        {
                            "total_time": 10.61,
                            "explored_nodes": 1,
                            "simplex_iterations": 2059,
                            "explored_time": 10.52,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.1724,
                            "total_time": 14.09,
                            "explored_nodes": 4059,
                            "simplex_iterations": 55301,
                            "explored_time": 14.07,
                            "work_units": 10.0
                        },
                        {
                            "gap": 49.7412,
                            "total_time": 11.89,
                            "explored_nodes": 1,
                            "simplex_iterations": 3192,
                            "explored_time": 11.82,
                            "work_units": 10.01
                        },
                        {
                            "gap": 3.6646,
                            "total_time": 14.38,
                            "explored_nodes": 296512,
                            "simplex_iterations": 1993238,
                            "explored_time": 14.37,
                            "work_units": 10.0
                        },
                        {
                            "gap": 11.3763,
                            "total_time": 11.58,
                            "explored_nodes": 13,
                            "simplex_iterations": 2755,
                            "explored_time": 11.56,
                            "work_units": 10.06
                        },
                        {
                            "gap": 38.1936,
                            "total_time": 11.44,
                            "explored_nodes": 1,
                            "simplex_iterations": 1781,
                            "explored_time": 11.39,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 12.19,
                            "explored_nodes": 1,
                            "simplex_iterations": 2173,
                            "explored_time": 12.12,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "56480196-edda-4679-a90f-303914ea036f",
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "3b555aa5-9e8e-46a5-bfe1-7019011a441f",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def depot_aware_bounds_rule(model):\n        # Depot-Aware Position Bounds\n        # Tightens the domain of u[i] based on connectivity to the depot (node 1).\n        model.depot_bounds = pyo.ConstraintList()\n        for i in model.N:\n            if i == 1:\n                continue\n            # Lower Bound Tightening:\n            # If x[1,i]=1 (first node), RHS = 3 - 1 + 0 = 2 -> u[i] >= 2\n            # If x[i,1]=1 (last node), RHS = 3 - 0 + n - 3 = n -> u[i] >= n\n            # If neither (intermediate), RHS = 3 -> u[i] >= 3\n            model.depot_bounds.add(model.u[i] >= 3 - model.x[1, i] + (n - 3) * model.x[i, 1])\n            \n            # Upper Bound Tightening:\n            # If x[1,i]=1 (first node), RHS = n - 1 - (n-3) + 0 = 2 -> u[i] <= 2\n            # If x[i,1]=1 (last node), RHS = n - 1 - 0 + 1 = n -> u[i] <= n\n            # If neither (intermediate), RHS = n - 1 -> u[i] <= n - 1\n            model.depot_bounds.add(model.u[i] <= n - 1 - (n - 3) * model.x[1, i] + model.x[i, 1])\n    \n    depot_aware_bounds_rule(model)\n\n    return model\n",
                        "added_cut": "def depot_aware_bounds_rule(model):\n    # Depot-Aware Position Bounds\n    # Tightens the domain of u[i] based on connectivity to the depot (node 1).\n    model.depot_bounds = pyo.ConstraintList()\n    for i in model.N:\n        if i == 1:\n            continue\n        # Lower Bound Tightening:\n        # If x[1,i]=1 (first node), RHS = 3 - 1 + 0 = 2 -> u[i] >= 2\n        # If x[i,1]=1 (last node), RHS = 3 - 0 + n - 3 = n -> u[i] >= n\n        # If neither (intermediate), RHS = 3 -> u[i] >= 3\n        model.depot_bounds.add(model.u[i] >= 3 - model.x[1, i] + (n - 3) * model.x[i, 1])\n        \n        # Upper Bound Tightening:\n        # If x[1,i]=1 (first node), RHS = n - 1 - (n-3) + 0 = 2 -> u[i] <= 2\n        # If x[i,1]=1 (last node), RHS = n - 1 - 0 + 1 = n -> u[i] <= n\n        # If neither (intermediate), RHS = n - 1 -> u[i] <= n - 1\n        model.depot_bounds.add(model.u[i] <= n - 1 - (n - 3) * model.x[1, i] + model.x[i, 1])\n\ndepot_aware_bounds_rule(model)",
                        "idea": "This exploratory mutation implements **Depot-Aware Position Bounds**. Unlike the parent's Lifted MTZ, which refines the relative slope ($u_i - u_j$) between node pairs, this constraint tightens the **absolute** bounds of position variables $u_i$ conditioned on their connection to the depot. It partitions the feasible region of $u_i$ into exact values for start/end nodes ($2$ and $n$) and a tighter range $[3, n-1]$ for intermediate nodes. This removes fractional solutions where flow variables suggest a node is intermediate but its position variable is at an extreme bound."
                    },
                    "fitness": 6.492218850891548,
                    "solver_reports": [
                        {
                            "gap": 11.6874,
                            "total_time": 11.65,
                            "explored_nodes": 6603,
                            "simplex_iterations": 76613,
                            "explored_time": 11.62,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1746,
                            "total_time": 13.41,
                            "explored_nodes": 1,
                            "simplex_iterations": 5093,
                            "explored_time": 13.37,
                            "work_units": 10.0
                        },
                        {
                            "gap": 11.869,
                            "total_time": 11.98,
                            "explored_nodes": 2830,
                            "simplex_iterations": 44076,
                            "explored_time": 11.97,
                            "work_units": 10.01
                        },
                        {
                            "gap": 49.4884,
                            "total_time": 16.5,
                            "explored_nodes": 1,
                            "simplex_iterations": 3674,
                            "explored_time": 16.46,
                            "work_units": 10.0
                        },
                        {
                            "gap": 2.5111,
                            "total_time": 11.6,
                            "explored_nodes": 2843,
                            "simplex_iterations": 44840,
                            "explored_time": 11.58,
                            "work_units": 10.0
                        },
                        {
                            "gap": 42.0924,
                            "total_time": 13.7,
                            "explored_nodes": 87,
                            "simplex_iterations": 6494,
                            "explored_time": 13.67,
                            "work_units": 11.21
                        },
                        {
                            "gap": 4.563,
                            "total_time": 12.98,
                            "explored_nodes": 281947,
                            "simplex_iterations": 1851693,
                            "explored_time": 12.97,
                            "work_units": 10.0
                        },
                        {
                            "gap": 8.0331,
                            "total_time": 11.42,
                            "explored_nodes": 3928,
                            "simplex_iterations": 58504,
                            "explored_time": 11.39,
                            "work_units": 10.0
                        },
                        {
                            "gap": 24.8424,
                            "total_time": 11.32,
                            "explored_nodes": 87,
                            "simplex_iterations": 6799,
                            "explored_time": 11.3,
                            "work_units": 10.18
                        },
                        {
                            "gap": 5.5235,
                            "total_time": 15.3,
                            "explored_nodes": 87,
                            "simplex_iterations": 8319,
                            "explored_time": 15.27,
                            "work_units": 12.2
                        }
                    ],
                    "generator": "Exploratory",
                    "parents_id": [
                        "56480196-edda-4679-a90f-303914ea036f"
                    ]
                },
                {
                    "id": "f5384453-f50b-4e93-8190-99db5b863847",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Depot-Anchored Positioning Constraints\n    # Explicitly link the depot's incident arcs to the boundary values of the position variables.\n    \n    def depot_out_rule(model, j):\n        # If arc (1, j) is selected, node j is the second visited node, so u[j] must be 2.\n        # Linearization: u[j] <= n - (n - 2) * x[1, j]\n        if j != 1:\n            return model.u[j] + (n - 2) * model.x[1, j] <= n\n        return pyo.Constraint.Skip\n    model.depot_out_anchoring = pyo.Constraint(model.N, rule=depot_out_rule)\n    \n    def depot_in_rule(model, i):\n        # If arc (i, 1) is selected, node i is the last visited node, so u[i] must be n.\n        # Linearization: u[i] >= 2 + (n - 2) * x[i, 1]\n        if i != 1:\n            return model.u[i] - (n - 2) * model.x[i, 1] >= 2\n        return pyo.Constraint.Skip\n    model.depot_in_anchoring = pyo.Constraint(model.N, rule=depot_in_rule)\n\n    return model\n",
                        "added_cut": "# Depot-Anchored Positioning Constraints\n# Explicitly link the depot's incident arcs to the boundary values of the position variables.\n\ndef depot_out_rule(model, j):\n    # If arc (1, j) is selected, node j is the second visited node, so u[j] must be 2.\n    # Linearization: u[j] <= n - (n - 2) * x[1, j]\n    if j != 1:\n        return model.u[j] + (n - 2) * model.x[1, j] <= n\n    return pyo.Constraint.Skip\nmodel.depot_out_anchoring = pyo.Constraint(model.N, rule=depot_out_rule)\n\ndef depot_in_rule(model, i):\n    # If arc (i, 1) is selected, node i is the last visited node, so u[i] must be n.\n    # Linearization: u[i] >= 2 + (n - 2) * x[i, 1]\n    if i != 1:\n        return model.u[i] - (n - 2) * model.x[i, 1] >= 2\n    return pyo.Constraint.Skip\nmodel.depot_in_anchoring = pyo.Constraint(model.N, rule=depot_in_rule)",
                        "idea": "This 'Depot-Anchored Positioning' logic is structurally complementary to both parents. While Parent 1 targets local 2-cycles (using only $x$) and Parent 2 strengthens sequencing between internal nodes (using $u, x$ for $i,j \\neq 1$), this offspring specifically targets the 'floating' boundary conditions at the depot. By enforcing $u_j=2$ for the first node and $u_i=n$ for the last node, it rigidly anchors the sequencing variables $u$ to the flow variables $x$ at the tour's start and end, tightening the relaxation where standard MTZ is weakest and implicitly preventing 2-cycles involving the depot."
                    },
                    "fitness": 7.574143807819105,
                    "solver_reports": [
                        {
                            "gap": 9.2893,
                            "total_time": 12.9,
                            "explored_nodes": 4200,
                            "simplex_iterations": 57100,
                            "explored_time": 12.87,
                            "work_units": 10.0
                        },
                        {
                            "gap": 2.3443,
                            "total_time": 13.19,
                            "explored_nodes": 102,
                            "simplex_iterations": 9188,
                            "explored_time": 13.16,
                            "work_units": 10.03
                        },
                        {
                            "gap": 8.8891,
                            "total_time": 12.0,
                            "explored_nodes": 882,
                            "simplex_iterations": 19372,
                            "explored_time": 11.98,
                            "work_units": 10.04
                        },
                        {
                            "gap": 92.2872,
                            "total_time": 14.39,
                            "explored_nodes": 1,
                            "simplex_iterations": 3502,
                            "explored_time": 14.33,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.0747,
                            "total_time": 13.92,
                            "explored_nodes": 3741,
                            "simplex_iterations": 64275,
                            "explored_time": 13.91,
                            "work_units": 10.01
                        },
                        {
                            "gap": 22.1117,
                            "total_time": 14.11,
                            "explored_nodes": 165,
                            "simplex_iterations": 8769,
                            "explored_time": 14.08,
                            "work_units": 11.25
                        },
                        {
                            "gap": 4.7055,
                            "total_time": 13.66,
                            "explored_nodes": 212017,
                            "simplex_iterations": 1572997,
                            "explored_time": 13.66,
                            "work_units": 10.03
                        },
                        {
                            "gap": 3.2445,
                            "total_time": 12.75,
                            "explored_nodes": 2854,
                            "simplex_iterations": 66244,
                            "explored_time": 12.72,
                            "work_units": 10.0
                        },
                        {
                            "gap": 24.8031,
                            "total_time": 12.1,
                            "explored_nodes": 87,
                            "simplex_iterations": 7265,
                            "explored_time": 12.08,
                            "work_units": 10.64
                        },
                        {
                            "gap": 9.7595,
                            "total_time": 14.59,
                            "explored_nodes": 255,
                            "simplex_iterations": 11500,
                            "explored_time": 14.56,
                            "work_units": 11.42
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "0163fb75-7b01-49ad-88cb-5bb0dfec5674"
                    ]
                }
            ],
            10.353038952236112
        ],
        [
            [
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "0ba0053e-1625-4075-b1c8-dd0458b0ed68",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def depot_position_hull_rule(model):\n        # Tightened Depot-Anchored Position Bounds\n        # This constraint set integrates the 'Anchoring' logic of Parent 2 with the 'Depot-Aware' \n        # precision of Parent 1. It enforces the convex hull of the position variable u[i] \n        # projected onto the subspace of depot-connected arcs (x[1,i] and x[i,1]).\n    \n        # Lower Bound Logic:\n        # 1. If i is first (x[1,i]=1): u[i] >= 3 - 1 + 0 = 2 (Anchored start)\n        # 2. If i is last (x[i,1]=1):  u[i] >= 3 - 0 + n - 3 = n (Anchored end)\n        # 3. If intermediate:          u[i] >= 3 (Tightened range)\n        def lb_rule(m, i):\n            if i == 1:\n                return pyo.Constraint.Skip\n            return m.u[i] + m.x[1, i] - (n - 3) * m.x[i, 1] >= 3\n        model.depot_pos_lb = pyo.Constraint(model.N, rule=lb_rule)\n    \n        # Upper Bound Logic:\n        # 1. If i is first (x[1,i]=1): u[i] <= (n-1) - (n-3) = 2 (Anchored start)\n        # 2. If i is last (x[i,1]=1):  u[i] <= (n-1) + 1 = n (Anchored end)\n        # 3. If intermediate:          u[i] <= n - 1 (Tightened range)\n        def ub_rule(m, i):\n            if i == 1:\n                return pyo.Constraint.Skip\n            return m.u[i] + (n - 3) * m.x[1, i] - m.x[i, 1] <= n - 1\n        model.depot_pos_ub = pyo.Constraint(model.N, rule=ub_rule)\n    \n    depot_position_hull_rule(model)\n\n    return model\n",
                        "added_cut": "def depot_position_hull_rule(model):\n    # Tightened Depot-Anchored Position Bounds\n    # This constraint set integrates the 'Anchoring' logic of Parent 2 with the 'Depot-Aware' \n    # precision of Parent 1. It enforces the convex hull of the position variable u[i] \n    # projected onto the subspace of depot-connected arcs (x[1,i] and x[i,1]).\n\n    # Lower Bound Logic:\n    # 1. If i is first (x[1,i]=1): u[i] >= 3 - 1 + 0 = 2 (Anchored start)\n    # 2. If i is last (x[i,1]=1):  u[i] >= 3 - 0 + n - 3 = n (Anchored end)\n    # 3. If intermediate:          u[i] >= 3 (Tightened range)\n    def lb_rule(m, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        return m.u[i] + m.x[1, i] - (n - 3) * m.x[i, 1] >= 3\n    model.depot_pos_lb = pyo.Constraint(model.N, rule=lb_rule)\n\n    # Upper Bound Logic:\n    # 1. If i is first (x[1,i]=1): u[i] <= (n-1) - (n-3) = 2 (Anchored start)\n    # 2. If i is last (x[i,1]=1):  u[i] <= (n-1) + 1 = n (Anchored end)\n    # 3. If intermediate:          u[i] <= n - 1 (Tightened range)\n    def ub_rule(m, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        return m.u[i] + (n - 3) * m.x[1, i] - m.x[i, 1] <= n - 1\n    model.depot_pos_ub = pyo.Constraint(model.N, rule=ub_rule)\n\ndepot_position_hull_rule(model)",
                        "idea": "This cut constructs the convex hull for the position variables $u_i$ conditioned on their connectivity to the depot. It unifies Parent 2's strong 'anchoring' (fixing $u_i=2$ for the first node and $u_i=n$ for the last) with Parent 1's tighter bounds for intermediate nodes ($3 \\le u_i \\le n-1$). By explicitly linking $u_i$ to $x_{1,i}$ and $x_{i,1}$, it eliminates fractional solutions where a node serves as an intermediate stop in the flow but takes extreme position values in the relaxation."
                    },
                    "fitness": 1.7028451877265267,
                    "solver_reports": [
                        {
                            "gap": 7.9012,
                            "total_time": 12.7,
                            "explored_nodes": 3520,
                            "simplex_iterations": 60486,
                            "explored_time": 12.67,
                            "work_units": 10.0
                        },
                        {
                            "gap": 55.9895,
                            "total_time": 11.39,
                            "explored_nodes": 1,
                            "simplex_iterations": 6973,
                            "explored_time": 11.36,
                            "work_units": 10.0
                        },
                        {
                            "gap": 22.0816,
                            "total_time": 11.65,
                            "explored_nodes": 1994,
                            "simplex_iterations": 37402,
                            "explored_time": 11.64,
                            "work_units": 10.04
                        },
                        {
                            "gap": 91.9378,
                            "total_time": 14.07,
                            "explored_nodes": 1,
                            "simplex_iterations": 3945,
                            "explored_time": 14.02,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.9062,
                            "total_time": 13.61,
                            "explored_nodes": 8804,
                            "simplex_iterations": 92126,
                            "explored_time": 13.58,
                            "work_units": 10.0
                        },
                        {
                            "gap": 37.375,
                            "total_time": 11.53,
                            "explored_nodes": 59,
                            "simplex_iterations": 5763,
                            "explored_time": 11.49,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.8481,
                            "total_time": 13.76,
                            "explored_nodes": 168310,
                            "simplex_iterations": 1101069,
                            "explored_time": 13.76,
                            "work_units": 10.05
                        },
                        {
                            "gap": 8.9884,
                            "total_time": 11.32,
                            "explored_nodes": 4131,
                            "simplex_iterations": 60158,
                            "explored_time": 11.28,
                            "work_units": 10.0
                        },
                        {
                            "gap": 42.3823,
                            "total_time": 13.65,
                            "explored_nodes": 171,
                            "simplex_iterations": 8366,
                            "explored_time": 13.62,
                            "work_units": 12.11
                        },
                        {
                            "gap": 32.2994,
                            "total_time": 13.1,
                            "explored_nodes": 14,
                            "simplex_iterations": 5778,
                            "explored_time": 13.06,
                            "work_units": 10.07
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "3b555aa5-9e8e-46a5-bfe1-7019011a441f",
                        "f5384453-f50b-4e93-8190-99db5b863847"
                    ]
                },
                {
                    "id": "ea7ddb2c-ee51-480d-bc6a-0606eed013d8",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def depot_aware_position_bounds(model):\n        # This constraint tightens the domain of the position variables u[i] based on \n        # their connectivity to the depot (node 1). It integrates the logic from both parents\n        # to enforce exact positions for the first and last nodes of the tour.\n        \n        # We use a ConstraintList to iterate over non-depot nodes\n        model.depot_pos_cuts = pyo.ConstraintList()\n        \n        for i in model.N:\n            if i == 1:\n                continue\n                \n            # Lower Bound Logic:\n            # - If x[1,i]=1 (i is first), u[i] must be 2.\n            # - If x[i,1]=1 (i is last), u[i] must be n.\n            # - Otherwise, u[i] >= 3.\n            # Formula: u[i] >= 3 - x[1,i] + (n - 3)*x[i,1]\n            model.depot_pos_cuts.add(\n                model.u[i] >= 3 - model.x[1, i] + (n - 3) * model.x[i, 1]\n            )\n            \n            # Upper Bound Logic:\n            # - If x[1,i]=1 (i is first), u[i] must be 2.\n            # - If x[i,1]=1 (i is last), u[i] must be n.\n            # - Otherwise, u[i] <= n - 1.\n            # Formula: u[i] <= (n - 1) - (n - 3)*x[1,i] + x[i,1]\n            model.depot_pos_cuts.add(\n                model.u[i] <= (n - 1) - (n - 3) * model.x[1, i] + model.x[i, 1]\n            )\n    \n    depot_aware_position_bounds(model)\n\n    return model\n",
                        "added_cut": "def depot_aware_position_bounds(model):\n    # This constraint tightens the domain of the position variables u[i] based on \n    # their connectivity to the depot (node 1). It integrates the logic from both parents\n    # to enforce exact positions for the first and last nodes of the tour.\n    \n    # We use a ConstraintList to iterate over non-depot nodes\n    model.depot_pos_cuts = pyo.ConstraintList()\n    \n    for i in model.N:\n        if i == 1:\n            continue\n            \n        # Lower Bound Logic:\n        # - If x[1,i]=1 (i is first), u[i] must be 2.\n        # - If x[i,1]=1 (i is last), u[i] must be n.\n        # - Otherwise, u[i] >= 3.\n        # Formula: u[i] >= 3 - x[1,i] + (n - 3)*x[i,1]\n        model.depot_pos_cuts.add(\n            model.u[i] >= 3 - model.x[1, i] + (n - 3) * model.x[i, 1]\n        )\n        \n        # Upper Bound Logic:\n        # - If x[1,i]=1 (i is first), u[i] must be 2.\n        # - If x[i,1]=1 (i is last), u[i] must be n.\n        # - Otherwise, u[i] <= n - 1.\n        # Formula: u[i] <= (n - 1) - (n - 3)*x[1,i] + x[i,1]\n        model.depot_pos_cuts.add(\n            model.u[i] <= (n - 1) - (n - 3) * model.x[1, i] + model.x[i, 1]\n        )\n\ndepot_aware_position_bounds(model)",
                        "idea": "This cut implements **Depot-Dependent Interval Bounding**, a strict strengthening of standard MTZ bounds. It unifies the logic of both parents by partitioning the feasible region of $u_i$ based on depot connectivity: forcing $u_i=2$ if connected from the depot, $u_i=n$ if connected to the depot, and restricting $u_i \\in [3, n-1]$ otherwise. This creates a tight valid corridor for position variables that prunes fractional solutions where variable values contradict the tour's start/end structure."
                    },
                    "fitness": 6.492218850891548,
                    "solver_reports": [
                        {
                            "gap": 11.6874,
                            "total_time": 11.37,
                            "explored_nodes": 6603,
                            "simplex_iterations": 76613,
                            "explored_time": 11.35,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1746,
                            "total_time": 13.26,
                            "explored_nodes": 1,
                            "simplex_iterations": 5093,
                            "explored_time": 13.21,
                            "work_units": 10.0
                        },
                        {
                            "gap": 11.869,
                            "total_time": 12.21,
                            "explored_nodes": 2830,
                            "simplex_iterations": 44076,
                            "explored_time": 12.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 49.4884,
                            "total_time": 14.94,
                            "explored_nodes": 1,
                            "simplex_iterations": 3674,
                            "explored_time": 14.88,
                            "work_units": 10.0
                        },
                        {
                            "gap": 2.5111,
                            "total_time": 11.58,
                            "explored_nodes": 2843,
                            "simplex_iterations": 44840,
                            "explored_time": 11.55,
                            "work_units": 10.0
                        },
                        {
                            "gap": 42.0924,
                            "total_time": 13.96,
                            "explored_nodes": 87,
                            "simplex_iterations": 6494,
                            "explored_time": 13.93,
                            "work_units": 11.21
                        },
                        {
                            "gap": 4.563,
                            "total_time": 13.26,
                            "explored_nodes": 281947,
                            "simplex_iterations": 1851693,
                            "explored_time": 13.26,
                            "work_units": 10.0
                        },
                        {
                            "gap": 8.0331,
                            "total_time": 11.15,
                            "explored_nodes": 3928,
                            "simplex_iterations": 58504,
                            "explored_time": 11.13,
                            "work_units": 10.0
                        },
                        {
                            "gap": 24.8424,
                            "total_time": 11.67,
                            "explored_nodes": 87,
                            "simplex_iterations": 6799,
                            "explored_time": 11.65,
                            "work_units": 10.18
                        },
                        {
                            "gap": 5.5235,
                            "total_time": 14.4,
                            "explored_nodes": 87,
                            "simplex_iterations": 8319,
                            "explored_time": 14.36,
                            "work_units": 12.2
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "a3ca7110-6fe6-4524-803f-98f276760182",
                        "3b555aa5-9e8e-46a5-bfe1-7019011a441f"
                    ]
                },
                {
                    "id": "904ca3df-d8a4-4849-b3f1-38c356f325f3",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def lifted_mtz_rule(model, i, j):\n        # Apply only to distinct non-depot nodes (i, j in 2..n)\n        if i != 1 and j != 1 and i != j:\n            # Desrochers and Laporte (1991) Lifted MTZ constraint.\n            # This strengthens the relationship between position variables u and binary variables x\n            # by considering the reverse arc (j, i) and tightening the Big-M coefficients.\n            # Validity:\n            # 1. If x[i,j]=1, x[j,i]=0: u[i]-u[j] + (n-1) <= n-2 => u[j] >= u[i] + 1 (Correct)\n            # 2. If x[i,j]=0, x[j,i]=1: u[i]-u[j] + (n-3) <= n-2 => u[i] - u[j] <= 1 (Correct, as u[i]=u[j]+1)\n            # 3. If x[i,j]=0, x[j,i]=0: u[i]-u[j] <= n-2 (Correct, max diff is n-2)\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    \n    model.lifted_mtz_cuts = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "def lifted_mtz_rule(model, i, j):\n    # Apply only to distinct non-depot nodes (i, j in 2..n)\n    if i != 1 and j != 1 and i != j:\n        # Desrochers and Laporte (1991) Lifted MTZ constraint.\n        # This strengthens the relationship between position variables u and binary variables x\n        # by considering the reverse arc (j, i) and tightening the Big-M coefficients.\n        # Validity:\n        # 1. If x[i,j]=1, x[j,i]=0: u[i]-u[j] + (n-1) <= n-2 => u[j] >= u[i] + 1 (Correct)\n        # 2. If x[i,j]=0, x[j,i]=1: u[i]-u[j] + (n-3) <= n-2 => u[i] - u[j] <= 1 (Correct, as u[i]=u[j]+1)\n        # 3. If x[i,j]=0, x[j,i]=0: u[i]-u[j] <= n-2 (Correct, max diff is n-2)\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\n\nmodel.lifted_mtz_cuts = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "This exploratory mutation implements **Lifted MTZ Subtour Elimination Constraints** (Desrochers & Laporte, 1991). While the provided individual's cut focused on 'unary' bounds relative to the depot, this cut strengthens the 'binary' relative ordering between arbitrary node pairs. By explicitly incorporating the reverse arc variable $x_{ji}$ into the constraint relating $u_i$ and $u_j$, it reduces the effective Big-M coefficient from $n$ to $n-1$ (and further to $n-3$ for the reverse term). This strictly dominates the standard MTZ constraints by enforcing tighter bounds on the difference $u_i - u_j$ both when arcs are present and absent, thereby pruning fractional solutions that exploit the weaker relaxation."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 11.01,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 10.99,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 12.64,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 12.56,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 13.09,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 13.07,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.72,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.62,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 12.02,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 11.99,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 13.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 13.06,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 14.84,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 14.84,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 10.95,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 10.93,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 11.72,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 11.68,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 13.3,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 13.24,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Exploratory",
                    "parents_id": [
                        "a3ca7110-6fe6-4524-803f-98f276760182"
                    ]
                },
                {
                    "id": "c14e387d-2b67-410c-93a0-07597ec5c87a",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Hybrid Depot-Position Bounds\n    # Combines Parent 1's exact assignment logic (x=1 => u fixed) with Parent 2's \n    # domain restriction logic (x=0 => u tighter) into a single lifted formulation.\n    \n    def hybrid_lb_rule(model, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        # Lower Bound Logic:\n        # 1. If x[1,i]=1 (start), u[i] >= 3 - 1 + 0 = 2. (Matches Parent 1)\n        # 2. If x[i,1]=1 (end),   u[i] >= 3 - 0 + n - 3 = n. (Matches Parent 1)\n        # 3. If neither,          u[i] >= 3. (Matches Parent 2, stricter than P1)\n        # Valid for n >= 3.\n        return model.u[i] >= 3 - model.x[1, i] + (n - 3) * model.x[i, 1]\n    \n    model.hybrid_depot_lb = pyo.Constraint(model.N, rule=hybrid_lb_rule)\n    \n    def hybrid_ub_rule(model, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        # Upper Bound Logic:\n        # 1. If x[1,i]=1 (start), u[i] <= (n-1) + 0 - (n-3) = 2. (Matches Parent 1)\n        # 2. If x[i,1]=1 (end),   u[i] <= (n-1) + 1 - 0 = n. (Matches Parent 1)\n        # 3. If neither,          u[i] <= n - 1. (Matches Parent 2, stricter than P1)\n        return model.u[i] <= (n - 1) + model.x[i, 1] - (n - 3) * model.x[1, i]\n    \n    model.hybrid_depot_ub = pyo.Constraint(model.N, rule=hybrid_ub_rule)\n\n    return model\n",
                        "added_cut": "# Hybrid Depot-Position Bounds\n# Combines Parent 1's exact assignment logic (x=1 => u fixed) with Parent 2's \n# domain restriction logic (x=0 => u tighter) into a single lifted formulation.\n\ndef hybrid_lb_rule(model, i):\n    if i == 1:\n        return pyo.Constraint.Skip\n    # Lower Bound Logic:\n    # 1. If x[1,i]=1 (start), u[i] >= 3 - 1 + 0 = 2. (Matches Parent 1)\n    # 2. If x[i,1]=1 (end),   u[i] >= 3 - 0 + n - 3 = n. (Matches Parent 1)\n    # 3. If neither,          u[i] >= 3. (Matches Parent 2, stricter than P1)\n    # Valid for n >= 3.\n    return model.u[i] >= 3 - model.x[1, i] + (n - 3) * model.x[i, 1]\n\nmodel.hybrid_depot_lb = pyo.Constraint(model.N, rule=hybrid_lb_rule)\n\ndef hybrid_ub_rule(model, i):\n    if i == 1:\n        return pyo.Constraint.Skip\n    # Upper Bound Logic:\n    # 1. If x[1,i]=1 (start), u[i] <= (n-1) + 0 - (n-3) = 2. (Matches Parent 1)\n    # 2. If x[i,1]=1 (end),   u[i] <= (n-1) + 1 - 0 = n. (Matches Parent 1)\n    # 3. If neither,          u[i] <= n - 1. (Matches Parent 2, stricter than P1)\n    return model.u[i] <= (n - 1) + model.x[i, 1] - (n - 3) * model.x[1, i]\n\nmodel.hybrid_depot_ub = pyo.Constraint(model.N, rule=hybrid_ub_rule)",
                        "idea": "This hybrid constraint set implements **Lifted Depot-Position Bounding**, strictly dominating both parents by merging their logic into a comprehensive conditional bound. While Parent 1 fixes $u_i$ when a depot arc is active ($x=1$), and Parent 2 restricts the range when inactive ($x=0$), this formulation uses coefficients $(n-3)$ to simultaneously enforce $u_i=2$ for start nodes, $u_i=n$ for end nodes, and a tighter domain $u_i \\in [3, n-1]$ for intermediate nodes. This effectively tightens the Big-M relaxation on the MTZ constraints for all non-depot adjacent nodes."
                    },
                    "fitness": 1.7028451877265267,
                    "solver_reports": [
                        {
                            "gap": 7.9012,
                            "total_time": 12.91,
                            "explored_nodes": 3520,
                            "simplex_iterations": 60486,
                            "explored_time": 12.88,
                            "work_units": 10.0
                        },
                        {
                            "gap": 55.9895,
                            "total_time": 12.54,
                            "explored_nodes": 1,
                            "simplex_iterations": 6973,
                            "explored_time": 12.49,
                            "work_units": 10.0
                        },
                        {
                            "gap": 22.0816,
                            "total_time": 11.39,
                            "explored_nodes": 1994,
                            "simplex_iterations": 37402,
                            "explored_time": 11.38,
                            "work_units": 10.04
                        },
                        {
                            "gap": 91.9378,
                            "total_time": 14.68,
                            "explored_nodes": 1,
                            "simplex_iterations": 3945,
                            "explored_time": 14.61,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.9062,
                            "total_time": 13.78,
                            "explored_nodes": 8804,
                            "simplex_iterations": 92126,
                            "explored_time": 13.75,
                            "work_units": 10.0
                        },
                        {
                            "gap": 37.375,
                            "total_time": 12.05,
                            "explored_nodes": 59,
                            "simplex_iterations": 5763,
                            "explored_time": 12.02,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.8481,
                            "total_time": 13.63,
                            "explored_nodes": 168310,
                            "simplex_iterations": 1101069,
                            "explored_time": 13.62,
                            "work_units": 10.05
                        },
                        {
                            "gap": 8.9884,
                            "total_time": 11.17,
                            "explored_nodes": 4131,
                            "simplex_iterations": 60158,
                            "explored_time": 11.14,
                            "work_units": 10.0
                        },
                        {
                            "gap": 42.3823,
                            "total_time": 13.43,
                            "explored_nodes": 171,
                            "simplex_iterations": 8366,
                            "explored_time": 13.4,
                            "work_units": 12.11
                        },
                        {
                            "gap": 32.2994,
                            "total_time": 13.57,
                            "explored_nodes": 14,
                            "simplex_iterations": 5778,
                            "explored_time": 13.52,
                            "work_units": 10.07
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "9e3332ae-38e4-4511-bfc9-4df633734c13",
                        "a3ca7110-6fe6-4524-803f-98f276760182"
                    ]
                },
                {
                    "id": "4cbad8f0-dae4-4373-868e-d18ff9814f46",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def lifted_mtz_cut_rule(model, i, j):\n        # Desrochers & Laporte (1991) Lifted MTZ constraints\n        # Applies to pairs of non-depot nodes to tighten the subtour elimination logic.\n        # It incorporates the reverse arc (j, i) and tightens the Big-M coefficient.\n        if i != j and i != 1 and j != 1:\n            # Formula: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    \n    model.lifted_mtz_cut = pyo.Constraint(model.N, model.N, rule=lifted_mtz_cut_rule)\n\n    return model\n",
                        "added_cut": "def lifted_mtz_cut_rule(model, i, j):\n    # Desrochers & Laporte (1991) Lifted MTZ constraints\n    # Applies to pairs of non-depot nodes to tighten the subtour elimination logic.\n    # It incorporates the reverse arc (j, i) and tightens the Big-M coefficient.\n    if i != j and i != 1 and j != 1:\n        # Formula: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\n\nmodel.lifted_mtz_cut = pyo.Constraint(model.N, model.N, rule=lifted_mtz_cut_rule)",
                        "idea": "This mutation implements **Desrochers-Laporte Lifted MTZ** constraints, acting as an 'internal structural stiffener' that complements the input's 'boundary anchoring'. While the input cut fixes $u$ values based on depot adjacency, this exploratory cut tightens the relative difference between internal position variables $u_i$ and $u_j$ by incorporating the reverse arc $x_{j,i}$ and reducing the Big-M coefficient from $n$ to $n-1$. This creates a conceptually distinct restriction that prunes fractional cycles in the tour's interior, providing a tighter approximation of the convex hull."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 10.92,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 10.9,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.65,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 13.56,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 13.24,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 13.21,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.83,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.76,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 12.4,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 12.37,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 12.41,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 12.34,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 15.07,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 15.07,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 10.74,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 10.72,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 11.41,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 11.37,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 13.54,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 13.49,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Exploratory",
                    "parents_id": [
                        "9e3332ae-38e4-4511-bfc9-4df633734c13"
                    ]
                },
                {
                    "id": "c6ef55da-3980-4fbe-9df5-0ad4aef65ce6",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Bi-Directional Depot Squeezing\n    # Tightens the domain of u[i] by recognizing that nodes NOT adjacent to the depot\n    # must strictly reside in the range [3, n-1], creating a tighter envelope than standard MTZ [2, n].\n    \n    def depot_squeeze_lb_rule(model, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        # If x[1,i]=1 (first), u[i] >= 2. If x[i,1]=1 (last), u[i] >= n. \n        # If neither, u[i] >= 3 (strictly stronger than Parent 2).\n        return model.u[i] >= 3 - model.x[1, i] + (n - 3) * model.x[i, 1]\n    model.depot_squeeze_lb = pyo.Constraint(model.N, rule=depot_squeeze_lb_rule)\n    \n    def depot_squeeze_ub_rule(model, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        # If x[1,i]=1 (first), u[i] <= 2. If x[i,1]=1 (last), u[i] <= n.\n        # If neither, u[i] <= n-1 (strictly stronger than Parent 2).\n        return model.u[i] <= (n - 1) - (n - 3) * model.x[1, i] + model.x[i, 1]\n    model.depot_squeeze_ub = pyo.Constraint(model.N, rule=depot_squeeze_ub_rule)\n\n    return model\n",
                        "added_cut": "# Bi-Directional Depot Squeezing\n# Tightens the domain of u[i] by recognizing that nodes NOT adjacent to the depot\n# must strictly reside in the range [3, n-1], creating a tighter envelope than standard MTZ [2, n].\n\ndef depot_squeeze_lb_rule(model, i):\n    if i == 1:\n        return pyo.Constraint.Skip\n    # If x[1,i]=1 (first), u[i] >= 2. If x[i,1]=1 (last), u[i] >= n. \n    # If neither, u[i] >= 3 (strictly stronger than Parent 2).\n    return model.u[i] >= 3 - model.x[1, i] + (n - 3) * model.x[i, 1]\nmodel.depot_squeeze_lb = pyo.Constraint(model.N, rule=depot_squeeze_lb_rule)\n\ndef depot_squeeze_ub_rule(model, i):\n    if i == 1:\n        return pyo.Constraint.Skip\n    # If x[1,i]=1 (first), u[i] <= 2. If x[i,1]=1 (last), u[i] <= n.\n    # If neither, u[i] <= n-1 (strictly stronger than Parent 2).\n    return model.u[i] <= (n - 1) - (n - 3) * model.x[1, i] + model.x[i, 1]\nmodel.depot_squeeze_ub = pyo.Constraint(model.N, rule=depot_squeeze_ub_rule)",
                        "idea": "This 'Bi-Directional Depot Squeezing' constraint evolves the parents' anchoring logic by strictly compressing the variable domains for internal nodes. While the parents fix $u_i=2$ or $u_i=n$ only when explicitly connected to the depot, this hybrid recognizes that any node *not* connected to the depot must lie strictly between positions $3$ and $n-1$. By lifting the coefficients, it tightens the relaxation for the majority of nodes (those in the middle of the tour) while maintaining the exact boundary anchors, thus strengthening the convex hull approximation beyond what either parent achieved."
                    },
                    "fitness": 1.7028451877265267,
                    "solver_reports": [
                        {
                            "gap": 7.9012,
                            "total_time": 12.34,
                            "explored_nodes": 3520,
                            "simplex_iterations": 60486,
                            "explored_time": 12.31,
                            "work_units": 10.0
                        },
                        {
                            "gap": 55.9895,
                            "total_time": 12.36,
                            "explored_nodes": 1,
                            "simplex_iterations": 6973,
                            "explored_time": 12.31,
                            "work_units": 10.0
                        },
                        {
                            "gap": 22.0816,
                            "total_time": 10.89,
                            "explored_nodes": 1994,
                            "simplex_iterations": 37402,
                            "explored_time": 10.87,
                            "work_units": 10.04
                        },
                        {
                            "gap": 91.9378,
                            "total_time": 15.12,
                            "explored_nodes": 1,
                            "simplex_iterations": 3945,
                            "explored_time": 15.07,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.9062,
                            "total_time": 13.42,
                            "explored_nodes": 8804,
                            "simplex_iterations": 92126,
                            "explored_time": 13.38,
                            "work_units": 10.0
                        },
                        {
                            "gap": 37.375,
                            "total_time": 12.01,
                            "explored_nodes": 59,
                            "simplex_iterations": 5763,
                            "explored_time": 11.98,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.8481,
                            "total_time": 13.62,
                            "explored_nodes": 168310,
                            "simplex_iterations": 1101069,
                            "explored_time": 13.62,
                            "work_units": 10.05
                        },
                        {
                            "gap": 8.9884,
                            "total_time": 11.47,
                            "explored_nodes": 4131,
                            "simplex_iterations": 60158,
                            "explored_time": 11.44,
                            "work_units": 10.0
                        },
                        {
                            "gap": 42.3823,
                            "total_time": 13.09,
                            "explored_nodes": 171,
                            "simplex_iterations": 8366,
                            "explored_time": 13.06,
                            "work_units": 12.11
                        },
                        {
                            "gap": 32.2994,
                            "total_time": 13.02,
                            "explored_nodes": 14,
                            "simplex_iterations": 5778,
                            "explored_time": 12.97,
                            "work_units": 10.07
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "f5384453-f50b-4e93-8190-99db5b863847",
                        "9e3332ae-38e4-4511-bfc9-4df633734c13"
                    ]
                },
                {
                    "id": "a43e934e-0276-467b-aaec-920752c3f33f",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Bi-Directional Depot Bounding Constraints\n    # This constraint set strictly dominates both parents by simultaneously utilizing \n    # incoming and outgoing depot arcs to tighten position bounds for ALL nodes.\n    # It enforces: \n    # 1. If start node (x[1,i]=1) -> u[i] = 2\n    # 2. If end node (x[i,1]=1)   -> u[i] = n\n    # 3. If internal node (neither) -> u[i] in [3, n-1] (Tighter than standard [2, n])\n    \n    def depot_bi_lb_rule(model, i):\n        if i != 1:\n            # Lower Bound: u[i] >= 3 - x[1,i] + (n-3)*x[i,1]\n            # Analysis: \n            #   If x[1,i]=1 -> u >= 3-1+0 = 2 (Consistent)\n            #   If x[i,1]=1 -> u >= 3-0+n-3 = n (Forces u=n)\n            #   If Both=0   -> u >= 3 (Tighter than MTZ default of 2)\n            return model.u[i] >= 3 - model.x[1, i] + (n - 3) * model.x[i, 1]\n        return pyo.Constraint.Skip\n    model.depot_bi_lb = pyo.Constraint(model.N, rule=depot_bi_lb_rule)\n    \n    def depot_bi_ub_rule(model, i):\n        if i != 1:\n            # Upper Bound: u[i] <= (n-1) + x[i,1] - (n-3)*x[1,i]\n            # Analysis:\n            #   If x[1,i]=1 -> u <= n-1+0-(n-3) = 2 (Forces u=2)\n            #   If x[i,1]=1 -> u <= n-1+1-0 = n (Consistent)\n            #   If Both=0   -> u <= n-1 (Tighter than MTZ default of n)\n            return model.u[i] <= (n - 1) + model.x[i, 1] - (n - 3) * model.x[1, i]\n        return pyo.Constraint.Skip\n    model.depot_bi_ub = pyo.Constraint(model.N, rule=depot_bi_ub_rule)\n\n    return model\n",
                        "added_cut": "# Bi-Directional Depot Bounding Constraints\n# This constraint set strictly dominates both parents by simultaneously utilizing \n# incoming and outgoing depot arcs to tighten position bounds for ALL nodes.\n# It enforces: \n# 1. If start node (x[1,i]=1) -> u[i] = 2\n# 2. If end node (x[i,1]=1)   -> u[i] = n\n# 3. If internal node (neither) -> u[i] in [3, n-1] (Tighter than standard [2, n])\n\ndef depot_bi_lb_rule(model, i):\n    if i != 1:\n        # Lower Bound: u[i] >= 3 - x[1,i] + (n-3)*x[i,1]\n        # Analysis: \n        #   If x[1,i]=1 -> u >= 3-1+0 = 2 (Consistent)\n        #   If x[i,1]=1 -> u >= 3-0+n-3 = n (Forces u=n)\n        #   If Both=0   -> u >= 3 (Tighter than MTZ default of 2)\n        return model.u[i] >= 3 - model.x[1, i] + (n - 3) * model.x[i, 1]\n    return pyo.Constraint.Skip\nmodel.depot_bi_lb = pyo.Constraint(model.N, rule=depot_bi_lb_rule)\n\ndef depot_bi_ub_rule(model, i):\n    if i != 1:\n        # Upper Bound: u[i] <= (n-1) + x[i,1] - (n-3)*x[1,i]\n        # Analysis:\n        #   If x[1,i]=1 -> u <= n-1+0-(n-3) = 2 (Forces u=2)\n        #   If x[i,1]=1 -> u <= n-1+1-0 = n (Consistent)\n        #   If Both=0   -> u <= n-1 (Tighter than MTZ default of n)\n        return model.u[i] <= (n - 1) + model.x[i, 1] - (n - 3) * model.x[1, i]\n    return pyo.Constraint.Skip\nmodel.depot_bi_ub = pyo.Constraint(model.N, rule=depot_bi_ub_rule)",
                        "idea": "The 'Bi-Directional Depot Bounding' constraint fuses the logic of both parents into a stronger, unified form. While the parents only anchored $u_i$ when a depot connection existed ($x_{1,i}=1$ or $x_{i,1}=1$), this offspring explicitly leverages the *absence* of such connections to tighten the bounds for internal nodes. By mathematically deriving that any node not connected to the depot must lie in positions $[3, n-1]$, it cuts off fractional solutions where internal nodes hover near the boundary values 2 or $n$. This effectively partitions the solution space into strict segments based on depot adjacency."
                    },
                    "fitness": 1.7028451877265267,
                    "solver_reports": [
                        {
                            "gap": 7.9012,
                            "total_time": 12.89,
                            "explored_nodes": 3520,
                            "simplex_iterations": 60486,
                            "explored_time": 12.86,
                            "work_units": 10.0
                        },
                        {
                            "gap": 55.9895,
                            "total_time": 12.14,
                            "explored_nodes": 1,
                            "simplex_iterations": 6973,
                            "explored_time": 12.09,
                            "work_units": 10.0
                        },
                        {
                            "gap": 22.0816,
                            "total_time": 11.11,
                            "explored_nodes": 1994,
                            "simplex_iterations": 37402,
                            "explored_time": 11.1,
                            "work_units": 10.04
                        },
                        {
                            "gap": 91.9378,
                            "total_time": 15.86,
                            "explored_nodes": 1,
                            "simplex_iterations": 3945,
                            "explored_time": 15.79,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.9062,
                            "total_time": 13.25,
                            "explored_nodes": 8804,
                            "simplex_iterations": 92126,
                            "explored_time": 13.22,
                            "work_units": 10.0
                        },
                        {
                            "gap": 37.375,
                            "total_time": 12.44,
                            "explored_nodes": 59,
                            "simplex_iterations": 5763,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.8481,
                            "total_time": 13.72,
                            "explored_nodes": 168310,
                            "simplex_iterations": 1101069,
                            "explored_time": 13.72,
                            "work_units": 10.05
                        },
                        {
                            "gap": 8.9884,
                            "total_time": 11.36,
                            "explored_nodes": 4131,
                            "simplex_iterations": 60158,
                            "explored_time": 11.34,
                            "work_units": 10.0
                        },
                        {
                            "gap": 42.3823,
                            "total_time": 13.37,
                            "explored_nodes": 171,
                            "simplex_iterations": 8366,
                            "explored_time": 13.34,
                            "work_units": 12.11
                        },
                        {
                            "gap": 32.2994,
                            "total_time": 12.41,
                            "explored_nodes": 14,
                            "simplex_iterations": 5778,
                            "explored_time": 12.36,
                            "work_units": 10.07
                        }
                    ],
                    "generator": "Min_Violation",
                    "parents_id": [
                        "f5384453-f50b-4e93-8190-99db5b863847",
                        "9e3332ae-38e4-4511-bfc9-4df633734c13"
                    ]
                }
            ],
            10.353038952236112
        ],
        [
            [
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "767a8055-2320-475c-ba59-7fed4e475237",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Combined Lifted MTZ and Depot 2-Cycle Elimination Constraint\n    # This constraint set integrates the strong subtour elimination of Parent 1\n    # with the variable-coupling logic of Parent 2 using 'Lifted MTZ' inequalities.\n    \n    def lifted_mtz_rule(model, i, j):\n        # Skip diagonal entries\n        if i == j:\n            return pyo.Constraint.Skip\n    \n        # Case 1: Internal Nodes (Neither i nor j is the depot)\n        # Apply Desrochers & Laporte 'Lifted MTZ' inequalities.\n        # This tightens the standard MTZ constraint by lifting it with the reverse arc variable x[j,i].\n        # Inequality: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\n        # Validity: If x[j,i]=1, forces u[i]-u[j] <= 1 (tighter than n-1). \n        # Impact: implies x[i,j] + x[j,i] <= 1 for internal pairs, satisfying Parent 1's goal.\n        if i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n        # Case 2: Depot Connections (i is depot)\n        # Explicitly enforce 2-cycle elimination for arcs connected to the depot.\n        # The standard MTZ relaxation allows fractional loops (e.g., x[1,j]=0.5, x[j,1]=0.5).\n        # We apply this only when i=1 to generate exactly one constraint per depot-connected pair.\n        if i == 1:\n            return model.x[i, j] + model.x[j, i] <= 1\n    \n        return pyo.Constraint.Skip\n    \n    model.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Combined Lifted MTZ and Depot 2-Cycle Elimination Constraint\n# This constraint set integrates the strong subtour elimination of Parent 1\n# with the variable-coupling logic of Parent 2 using 'Lifted MTZ' inequalities.\n\ndef lifted_mtz_rule(model, i, j):\n    # Skip diagonal entries\n    if i == j:\n        return pyo.Constraint.Skip\n\n    # Case 1: Internal Nodes (Neither i nor j is the depot)\n    # Apply Desrochers & Laporte 'Lifted MTZ' inequalities.\n    # This tightens the standard MTZ constraint by lifting it with the reverse arc variable x[j,i].\n    # Inequality: u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2\n    # Validity: If x[j,i]=1, forces u[i]-u[j] <= 1 (tighter than n-1). \n    # Impact: implies x[i,j] + x[j,i] <= 1 for internal pairs, satisfying Parent 1's goal.\n    if i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\n    # Case 2: Depot Connections (i is depot)\n    # Explicitly enforce 2-cycle elimination for arcs connected to the depot.\n    # The standard MTZ relaxation allows fractional loops (e.g., x[1,j]=0.5, x[j,1]=0.5).\n    # We apply this only when i=1 to generate exactly one constraint per depot-connected pair.\n    if i == 1:\n        return model.x[i, j] + model.x[j, i] <= 1\n\n    return pyo.Constraint.Skip\n\nmodel.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "This constraint integrates Parent 1's explicit 2-cycle elimination with Parent 2's variable bounding logic by implementing Desrochers & Laporte's 'Lifted MTZ' inequalities. For internal nodes, the lifted inequality $u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} \\le n-2$ uses reverse-arc information (Parent 2's insight) to tighten the feasible region, analytically implying $x_{ij} + x_{ji} \\le 1$. For depot connections, explicit 2-cycle cuts are retained to prevent fractional loops at the tour boundaries, strictly strengthening the standard formulation."
                    },
                    "fitness": 0.6769446635331395,
                    "solver_reports": [
                        {
                            "gap": 25.1773,
                            "total_time": 13.24,
                            "explored_nodes": 203,
                            "simplex_iterations": 6851,
                            "explored_time": 13.22,
                            "work_units": 10.28
                        },
                        {
                            "total_time": 12.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 4242,
                            "explored_time": 12.61,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.7313,
                            "total_time": 13.56,
                            "explored_nodes": 3185,
                            "simplex_iterations": 50490,
                            "explored_time": 13.55,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 13.05,
                            "explored_nodes": 1,
                            "simplex_iterations": 1881,
                            "explored_time": 12.95,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.3796,
                            "total_time": 12.65,
                            "explored_nodes": 3330,
                            "simplex_iterations": 49141,
                            "explored_time": 12.62,
                            "work_units": 10.0
                        },
                        {
                            "gap": 31.1829,
                            "total_time": 13.38,
                            "explored_nodes": 1,
                            "simplex_iterations": 2527,
                            "explored_time": 13.32,
                            "work_units": 10.02
                        },
                        {
                            "gap": 3.4507,
                            "total_time": 13.98,
                            "explored_nodes": 334765,
                            "simplex_iterations": 2195347,
                            "explored_time": 13.97,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.9227,
                            "total_time": 12.59,
                            "explored_nodes": 3079,
                            "simplex_iterations": 53730,
                            "explored_time": 12.56,
                            "work_units": 10.0
                        },
                        {
                            "gap": 21.8221,
                            "total_time": 12.55,
                            "explored_nodes": 1,
                            "simplex_iterations": 1285,
                            "explored_time": 12.51,
                            "work_units": 10.07
                        },
                        {
                            "gap": 87.6646,
                            "total_time": 13.0,
                            "explored_nodes": 1,
                            "simplex_iterations": 1924,
                            "explored_time": 12.94,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "a43e934e-0276-467b-aaec-920752c3f33f"
                    ]
                },
                {
                    "id": "276069fa-eba9-45f5-b2e4-258b128a72d4",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Desrochers & Laporte (1991) Lifted MTZ Constraints\n    # This formulation strengthens the standard MTZ constraints by including the reverse arc term x[j,i].\n    # It dominates the standard MTZ cuts and explicitly forbids 2-cycles for internal nodes.\n    \n    def lifted_mtz_rule(model, i, j):\n        # Apply lifted MTZ logic for non-depot nodes (i, j > 1)\n        # The inequality u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2 tightens the feasible region\n        # and implies x[i,j] + x[j,i] <= 1 when summed with the symmetric constraint.\n        if i > 1 and j > 1 and i != j:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        \n        # For the depot (node 1), we enforce explicit 2-cycle elimination\n        # because the u-variable lifting is not applicable to the fixed depot node.\n        elif i == 1 and j > 1:\n            return model.x[i, j] + model.x[j, i] <= 1\n            \n        return pyo.Constraint.Skip\n    \n    model.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Desrochers & Laporte (1991) Lifted MTZ Constraints\n# This formulation strengthens the standard MTZ constraints by including the reverse arc term x[j,i].\n# It dominates the standard MTZ cuts and explicitly forbids 2-cycles for internal nodes.\n\ndef lifted_mtz_rule(model, i, j):\n    # Apply lifted MTZ logic for non-depot nodes (i, j > 1)\n    # The inequality u[i] - u[j] + (n-1)x[i,j] + (n-3)x[j,i] <= n-2 tightens the feasible region\n    # and implies x[i,j] + x[j,i] <= 1 when summed with the symmetric constraint.\n    if i > 1 and j > 1 and i != j:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n    # For the depot (node 1), we enforce explicit 2-cycle elimination\n    # because the u-variable lifting is not applicable to the fixed depot node.\n    elif i == 1 and j > 1:\n        return model.x[i, j] + model.x[j, i] <= 1\n        \n    return pyo.Constraint.Skip\n\nmodel.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "Mutates the simple 2-cycle cut into the stronger Desrochers & Laporte Lifted MTZ constraint. For non-depot nodes, the inequality u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} <= n-2 strictly tightens the linear relaxation compared to standard MTZ, forcing x_{ij} + x_{ji} <= 1 implicitly while improving bounds on 'u'. Explicit 2-cycle cuts are retained for depot connections to ensure global validity."
                    },
                    "fitness": 0.6769446635331395,
                    "solver_reports": [
                        {
                            "gap": 25.1773,
                            "total_time": 13.3,
                            "explored_nodes": 203,
                            "simplex_iterations": 6851,
                            "explored_time": 13.28,
                            "work_units": 10.28
                        },
                        {
                            "total_time": 12.75,
                            "explored_nodes": 1,
                            "simplex_iterations": 4242,
                            "explored_time": 12.67,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.7313,
                            "total_time": 13.51,
                            "explored_nodes": 3185,
                            "simplex_iterations": 50490,
                            "explored_time": 13.49,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 12.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 1881,
                            "explored_time": 12.61,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.3796,
                            "total_time": 13.1,
                            "explored_nodes": 3330,
                            "simplex_iterations": 49141,
                            "explored_time": 13.07,
                            "work_units": 10.0
                        },
                        {
                            "gap": 31.1829,
                            "total_time": 13.13,
                            "explored_nodes": 1,
                            "simplex_iterations": 2527,
                            "explored_time": 13.07,
                            "work_units": 10.02
                        },
                        {
                            "gap": 3.4507,
                            "total_time": 13.33,
                            "explored_nodes": 334765,
                            "simplex_iterations": 2195347,
                            "explored_time": 13.33,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.9227,
                            "total_time": 13.16,
                            "explored_nodes": 3079,
                            "simplex_iterations": 53730,
                            "explored_time": 13.12,
                            "work_units": 10.0
                        },
                        {
                            "gap": 21.8221,
                            "total_time": 12.77,
                            "explored_nodes": 1,
                            "simplex_iterations": 1285,
                            "explored_time": 12.72,
                            "work_units": 10.07
                        },
                        {
                            "gap": 87.6646,
                            "total_time": 12.9,
                            "explored_nodes": 1,
                            "simplex_iterations": 1924,
                            "explored_time": 12.82,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "General",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "6432f306-5d6d-4b4c-b62c-577e3fa14cdc",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Hybrid Subtour Elimination: Desrochers-Laporte (Internal) + Explicit Depot Cuts\n    # This constraint set strengthens the formulation by applying lifted MTZ logic to internal nodes\n    # and explicit cycle breaking to depot edges, addressing weaknesses in the standard MTZ relaxation.\n    \n    def hybrid_sec_rule(model, i, j):\n        if i == j:\n            return pyo.Constraint.Skip\n        \n        # 1. Internal Nodes (i, j != 1): Apply Desrochers & Laporte (1991) Lifting\n        # The standard MTZ constraint is u_i - u_j + n*x_ij <= n-1.\n        # The lifted version is u_i - u_j + (n-1)*x_ij + (n-3)*x_ji <= n-2.\n        # This strictly tightens the relaxation by including the reverse arc term, implicitly preventing 2-cycles.\n        if i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n        # 2. Depot Edges (i = 1 or j = 1): Apply Explicit 2-Cycle Elimination\n        # Standard MTZ does not constrain arcs connected to the depot regarding subtours.\n        # We enforce x_1j + x_j1 <= 1 to cut trivial subtours involving the depot.\n        # Applied only when i=1 to avoid duplication for the pair {1, j}.\n        if i == 1:\n            return model.x[i, j] + model.x[j, i] <= 1\n            \n        return pyo.Constraint.Skip\n    \n    model.hybrid_sec = pyo.Constraint(model.N, model.N, rule=hybrid_sec_rule)\n\n    return model\n",
                        "added_cut": "# Hybrid Subtour Elimination: Desrochers-Laporte (Internal) + Explicit Depot Cuts\n# This constraint set strengthens the formulation by applying lifted MTZ logic to internal nodes\n# and explicit cycle breaking to depot edges, addressing weaknesses in the standard MTZ relaxation.\n\ndef hybrid_sec_rule(model, i, j):\n    if i == j:\n        return pyo.Constraint.Skip\n    \n    # 1. Internal Nodes (i, j != 1): Apply Desrochers & Laporte (1991) Lifting\n    # The standard MTZ constraint is u_i - u_j + n*x_ij <= n-1.\n    # The lifted version is u_i - u_j + (n-1)*x_ij + (n-3)*x_ji <= n-2.\n    # This strictly tightens the relaxation by including the reverse arc term, implicitly preventing 2-cycles.\n    if i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\n    # 2. Depot Edges (i = 1 or j = 1): Apply Explicit 2-Cycle Elimination\n    # Standard MTZ does not constrain arcs connected to the depot regarding subtours.\n    # We enforce x_1j + x_j1 <= 1 to cut trivial subtours involving the depot.\n    # Applied only when i=1 to avoid duplication for the pair {1, j}.\n    if i == 1:\n        return model.x[i, j] + model.x[j, i] <= 1\n        \n    return pyo.Constraint.Skip\n\nmodel.hybrid_sec = pyo.Constraint(model.N, model.N, rule=hybrid_sec_rule)",
                        "idea": "This formulation fuses Parent 1's cycle-breaking logic with a lifted variation of the MTZ constraints (Desrochers-Laporte). For internal nodes (i,j > 1), it replaces the weaker standard MTZ inequality with the lifted version: u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} <= n-2. This term (n-3)x_{ji} tightens the Big-M coefficient and penalizes 2-cycles directly within the potential formulation. For the depot (node 1), where potential variables u are less effective or fixed, it adopts Parent 1's approach by explicitly enforcing x_{1,j} + x_{j,1} <= 1, preventing the 2-cycle integrality gaps common in MTZ formulations."
                    },
                    "fitness": 0.8521388181680725,
                    "solver_reports": [
                        {
                            "gap": 18.83,
                            "total_time": 12.41,
                            "explored_nodes": 308,
                            "simplex_iterations": 7893,
                            "explored_time": 12.38,
                            "work_units": 10.02
                        },
                        {
                            "total_time": 12.99,
                            "explored_nodes": 1,
                            "simplex_iterations": 2245,
                            "explored_time": 12.93,
                            "work_units": 10.0
                        },
                        {
                            "gap": 11.9186,
                            "total_time": 10.43,
                            "explored_nodes": 1563,
                            "simplex_iterations": 30925,
                            "explored_time": 10.41,
                            "work_units": 10.02
                        },
                        {
                            "total_time": 12.61,
                            "explored_nodes": 1,
                            "simplex_iterations": 3532,
                            "explored_time": 12.51,
                            "work_units": 10.02
                        },
                        {
                            "gap": 2.0741,
                            "total_time": 12.52,
                            "explored_nodes": 7369,
                            "simplex_iterations": 130483,
                            "explored_time": 12.51,
                            "work_units": 10.01
                        },
                        {
                            "gap": 36.4435,
                            "total_time": 13.2,
                            "explored_nodes": 1,
                            "simplex_iterations": 1592,
                            "explored_time": 13.13,
                            "work_units": 10.01
                        },
                        {
                            "gap": 0.0,
                            "total_time": 7.83,
                            "postsolve": 0.01,
                            "explored_nodes": 135618,
                            "simplex_iterations": 991600,
                            "explored_time": 7.83,
                            "work_units": 5.07
                        },
                        {
                            "gap": 2.0177,
                            "total_time": 13.17,
                            "explored_nodes": 2855,
                            "simplex_iterations": 51676,
                            "explored_time": 13.15,
                            "work_units": 10.01
                        },
                        {
                            "gap": 18.9712,
                            "total_time": 11.91,
                            "explored_nodes": 1,
                            "simplex_iterations": 1805,
                            "explored_time": 11.85,
                            "work_units": 10.0
                        },
                        {
                            "gap": 87.6995,
                            "total_time": 13.25,
                            "explored_nodes": 1,
                            "simplex_iterations": 2133,
                            "explored_time": 13.2,
                            "work_units": 10.01
                        }
                    ],
                    "generator": "Min_Violation",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "c14e387d-2b67-410c-93a0-07597ec5c87a"
                    ]
                },
                {
                    "id": "4219409c-63d8-4d59-a41b-68893bae294b",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Desrochers & Laporte (1991) Lifted MTZ Subtour Elimination Constraints\n    # This mutation strengthens the original MTZ and the 2-cycle cut simultaneously.\n    def dl_lifted_mtz_rule(model, i, j):\n        # Apply to all pairs of non-depot nodes (nodes 2 to n)\n        if i != j and i != 1 and j != 1:\n            # The constraint: u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} <= n-2\n            # This formulation dominates the standard MTZ constraints and explicitly forbids 2-cycles.\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    \n    model.dl_lifted_mtz = pyo.Constraint(model.N, model.N, rule=dl_lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Desrochers & Laporte (1991) Lifted MTZ Subtour Elimination Constraints\n# This mutation strengthens the original MTZ and the 2-cycle cut simultaneously.\ndef dl_lifted_mtz_rule(model, i, j):\n    # Apply to all pairs of non-depot nodes (nodes 2 to n)\n    if i != j and i != 1 and j != 1:\n        # The constraint: u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} <= n-2\n        # This formulation dominates the standard MTZ constraints and explicitly forbids 2-cycles.\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\n\nmodel.dl_lifted_mtz = pyo.Constraint(model.N, model.N, rule=dl_lifted_mtz_rule)",
                        "idea": "I mutated the explicit 2-cycle cut into the Desrochers-Laporte lifted MTZ constraints. While the original cut separately enforced x[i,j] + x[j,i] <= 1, this lifted formulation embeds that logic directly into the subtour elimination constraints by adding the reverse arc term (n-3)*x[j,i] and tightening the RHS to n-2. This is strictly stronger than the standard MTZ plus isolated 2-cycle cuts because it tightens the feasible region of the continuous u variables (reducing the slack when arcs are unused) while implicitly preventing 2-cycles, yielding a much tighter linear relaxation."
                    },
                    "fitness": 5.749458180182717,
                    "solver_reports": [
                        {
                            "gap": 11.7846,
                            "total_time": 12.68,
                            "explored_nodes": 543,
                            "simplex_iterations": 11251,
                            "explored_time": 12.66,
                            "work_units": 10.09
                        },
                        {
                            "gap": 14.9279,
                            "total_time": 14.76,
                            "explored_nodes": 1,
                            "simplex_iterations": 2078,
                            "explored_time": 14.69,
                            "work_units": 10.01
                        },
                        {
                            "gap": 15.1493,
                            "total_time": 12.67,
                            "explored_nodes": 87,
                            "simplex_iterations": 5248,
                            "explored_time": 12.65,
                            "work_units": 10.07
                        },
                        {
                            "total_time": 11.18,
                            "explored_nodes": 1,
                            "simplex_iterations": 2040,
                            "explored_time": 11.09,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.4378,
                            "total_time": 12.79,
                            "explored_nodes": 3526,
                            "simplex_iterations": 55582,
                            "explored_time": 12.78,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.5036,
                            "total_time": 12.99,
                            "explored_nodes": 1,
                            "simplex_iterations": 1759,
                            "explored_time": 12.91,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.9213,
                            "total_time": 14.16,
                            "explored_nodes": 384194,
                            "simplex_iterations": 2350050,
                            "explored_time": 14.16,
                            "work_units": 10.02
                        },
                        {
                            "gap": 2.6982,
                            "total_time": 13.32,
                            "explored_nodes": 2998,
                            "simplex_iterations": 53069,
                            "explored_time": 13.28,
                            "work_units": 10.01
                        },
                        {
                            "gap": 24.2041,
                            "total_time": 11.55,
                            "explored_nodes": 15,
                            "simplex_iterations": 2460,
                            "explored_time": 11.51,
                            "work_units": 10.12
                        },
                        {
                            "gap": 10.4753,
                            "total_time": 13.11,
                            "explored_nodes": 1,
                            "simplex_iterations": 1944,
                            "explored_time": 13.05,
                            "work_units": 10.1
                        }
                    ],
                    "generator": "General",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "a8f1b38d-185b-4dac-901f-3c85bb6d9c72",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Depot-Tightened MTZ Lifting\n    # Incorporates the tightened position logic from Parents 1 & 2 directly into the \n    # subtour elimination constraints. By dynamically adjusting the RHS based on \n    # depot connectivity variables x[i,1] and x[1,j], this constraint strictly \n    # dominates the standard MTZ formulation for all inactive arcs.\n    \n    def depot_tightened_mtz_rule(model, i, j):\n        # Apply only to non-depot nodes and distinct pairs\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        \n        # Standard MTZ: u[i] - u[j] + n*x[i,j] <= n - 1\n        # New Cut: u[i] - u[j] + (n-3)*x[i,j] - x[i,1] - x[1,j] <= n - 4\n        # \n        # Validity Check:\n        # 1. Active arc (x[i,j]=1): Implies x[i,1]=0, x[1,j]=0.\n        #    LHS: u[i] - u[j] + n - 3. RHS: n - 4. \n        #    Result: u[i] - u[j] <= -1. (Matches logic u[j] >= u[i] + 1)\n        # 2. Inactive arc (x[i,j]=0): LHS reduces to u[i] - u[j] - x[i,1] - x[1,j].\n        #    - Internal nodes (x[i,1]=0, x[1,j]=0): Max diff is (n-1)-3 = n-4. Valid.\n        #    - End-Start (x[i,1]=1, x[1,j]=1): Max diff is n - 2. \n        #      LHS: n - 2 - 1 - 1 = n - 4. RHS: n - 4. Valid.\n        \n        return model.u[i] - model.u[j] + (n - 3) * model.x[i, j] - model.x[i, 1] - model.x[1, j] <= n - 4\n    \n    model.depot_tightened_mtz = pyo.Constraint(model.N, model.N, rule=depot_tightened_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Depot-Tightened MTZ Lifting\n# Incorporates the tightened position logic from Parents 1 & 2 directly into the \n# subtour elimination constraints. By dynamically adjusting the RHS based on \n# depot connectivity variables x[i,1] and x[1,j], this constraint strictly \n# dominates the standard MTZ formulation for all inactive arcs.\n\ndef depot_tightened_mtz_rule(model, i, j):\n    # Apply only to non-depot nodes and distinct pairs\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    \n    # Standard MTZ: u[i] - u[j] + n*x[i,j] <= n - 1\n    # New Cut: u[i] - u[j] + (n-3)*x[i,j] - x[i,1] - x[1,j] <= n - 4\n    # \n    # Validity Check:\n    # 1. Active arc (x[i,j]=1): Implies x[i,1]=0, x[1,j]=0.\n    #    LHS: u[i] - u[j] + n - 3. RHS: n - 4. \n    #    Result: u[i] - u[j] <= -1. (Matches logic u[j] >= u[i] + 1)\n    # 2. Inactive arc (x[i,j]=0): LHS reduces to u[i] - u[j] - x[i,1] - x[1,j].\n    #    - Internal nodes (x[i,1]=0, x[1,j]=0): Max diff is (n-1)-3 = n-4. Valid.\n    #    - End-Start (x[i,1]=1, x[1,j]=1): Max diff is n - 2. \n    #      LHS: n - 2 - 1 - 1 = n - 4. RHS: n - 4. Valid.\n    \n    return model.u[i] - model.u[j] + (n - 3) * model.x[i, j] - model.x[i, 1] - model.x[1, j] <= n - 4\n\nmodel.depot_tightened_mtz = pyo.Constraint(model.N, model.N, rule=depot_tightened_mtz_rule)",
                        "idea": "The 'Depot-Tightened MTZ Lifting' constraint evolves the parents' domain-squeezing logic by injecting it directly into the pairwise subtour elimination structure. By recognizing that nodes not connected to the depot have a strictly smaller position range ($[3, n-1]$), we can reduce the Big-M coefficient from $n$ to $n-3$. The constraint compensates for the tighter bound by subtracting the depot-connection variables $x_{i,1}$ and $x_{1,j}$ from the LHS, ensuring validity for start/end nodes while strictly tightening the relaxation for all internal arcs."
                    },
                    "fitness": 0.5165020937036413,
                    "solver_reports": [
                        {
                            "gap": 17.279,
                            "total_time": 14.34,
                            "explored_nodes": 59,
                            "simplex_iterations": 5658,
                            "explored_time": 14.31,
                            "work_units": 14.57
                        },
                        {
                            "total_time": 14.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 4021,
                            "explored_time": 14.37,
                            "work_units": 10.01
                        },
                        {
                            "gap": 25.5025,
                            "total_time": 12.16,
                            "explored_nodes": 1,
                            "simplex_iterations": 3476,
                            "explored_time": 12.14,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 12.6,
                            "explored_nodes": 1,
                            "simplex_iterations": 2692,
                            "explored_time": 12.51,
                            "work_units": 10.01
                        },
                        {
                            "gap": 8.6083,
                            "total_time": 9.3,
                            "explored_nodes": 639,
                            "simplex_iterations": 20573,
                            "explored_time": 9.29,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 12.94,
                            "explored_nodes": 1,
                            "simplex_iterations": 3871,
                            "explored_time": 12.87,
                            "work_units": 10.0
                        },
                        {
                            "gap": 5.775,
                            "total_time": 12.99,
                            "explored_nodes": 120641,
                            "simplex_iterations": 747414,
                            "explored_time": 12.99,
                            "work_units": 10.02
                        },
                        {
                            "gap": 10.5057,
                            "total_time": 11.54,
                            "explored_nodes": 352,
                            "simplex_iterations": 24919,
                            "explored_time": 11.52,
                            "work_units": 11.19
                        },
                        {
                            "gap": 82.5009,
                            "total_time": 13.05,
                            "explored_nodes": 1,
                            "simplex_iterations": 3499,
                            "explored_time": 13.0,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 12.9,
                            "explored_nodes": 1,
                            "simplex_iterations": 3622,
                            "explored_time": 12.83,
                            "work_units": 10.01
                        }
                    ],
                    "generator": "Min_Violation",
                    "parents_id": [
                        "c6ef55da-3980-4fbe-9df5-0ad4aef65ce6",
                        "c14e387d-2b67-410c-93a0-07597ec5c87a"
                    ]
                },
                {
                    "id": "8aa0ae44-b5c2-4445-925d-6cf9abb0ce2a",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Lifted MTZ Subtour Elimination Constraints (Desrochers & Laporte)\n    # This constraint integrates Parent 1's 2-cycle elimination directly into the MTZ framework\n    # and tightens the relaxation coefficients similar to Parent 2's bounding strategy.\n    \n    def lifted_mtz_rule(model, i, j):\n        # Apply only to non-depot nodes pair (i, j)\n        if i != j and i != 1 and j != 1:\n            # The constraint: u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} <= n-2\n            # This is strictly tighter than the standard MTZ constraint.\n            # It explicitly prevents 2-cycles (x_ij + x_ji <= 1) and lifts the bounds.\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    \n    model.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Lifted MTZ Subtour Elimination Constraints (Desrochers & Laporte)\n# This constraint integrates Parent 1's 2-cycle elimination directly into the MTZ framework\n# and tightens the relaxation coefficients similar to Parent 2's bounding strategy.\n\ndef lifted_mtz_rule(model, i, j):\n    # Apply only to non-depot nodes pair (i, j)\n    if i != j and i != 1 and j != 1:\n        # The constraint: u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} <= n-2\n        # This is strictly tighter than the standard MTZ constraint.\n        # It explicitly prevents 2-cycles (x_ij + x_ji <= 1) and lifts the bounds.\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\n\nmodel.lifted_mtz = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "This constraint implements the Lifted MTZ inequalities (Desrochers & Laporte, 1991). It effectively synthesizes the parents by: 1) Incorporating the backward arc term (n-3)x_{j,i} which mathematically enforces the 2-cycle elimination of Parent 1 (summing symmetric constraints implies x_{i,j} + x_{j,i} <= 1), and 2) Tightening the Big-M coefficients and RHS bounds to strictly reduce the feasible region of the linear relaxation, achieving the bound-tightening objective of Parent 2. This creates a valid, unified cut that dominates the standard MTZ formulation."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 11.93,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 11.91,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.62,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 13.55,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 12.86,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 12.84,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.81,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.71,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 12.47,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 12.45,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 12.29,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 12.21,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 14.51,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 14.5,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 10.88,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 10.87,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 11.59,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 11.56,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 13.19,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 13.12,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "a43e934e-0276-467b-aaec-920752c3f33f"
                    ]
                },
                {
                    "id": "f4cf01aa-4ee6-4023-9c36-2fa17ced1441",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Lifted MTZ Subtour Elimination (Desrochers & Laporte)\n    # This constraint acts as a strengthened bridge between position variables and arc selection,\n    # integrating the reverse-arc logic from Parent 2 directly into the position formulation of Parent 1.\n    def lifted_mtz_rule(model, i, j):\n        # Apply to all pairs of distinct non-depot nodes\n        if i == 1 or j == 1 or i == j:\n            return pyo.Constraint.Skip\n        \n        # The standard MTZ constraint is: u[i] - u[j] + n*x[i,j] <= n - 1\n        # The lifted version adds the (n-3)*x[j,i] term and tightens the RHS/coefficients.\n        # Formula: u[i] - u[j] + (n-1)*x[i,j] + (n-3)*x[j,i] <= n - 2\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n    model.lifted_mtz_cuts = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Lifted MTZ Subtour Elimination (Desrochers & Laporte)\n# This constraint acts as a strengthened bridge between position variables and arc selection,\n# integrating the reverse-arc logic from Parent 2 directly into the position formulation of Parent 1.\ndef lifted_mtz_rule(model, i, j):\n    # Apply to all pairs of distinct non-depot nodes\n    if i == 1 or j == 1 or i == j:\n        return pyo.Constraint.Skip\n    \n    # The standard MTZ constraint is: u[i] - u[j] + n*x[i,j] <= n - 1\n    # The lifted version adds the (n-3)*x[j,i] term and tightens the RHS/coefficients.\n    # Formula: u[i] - u[j] + (n-1)*x[i,j] + (n-3)*x[j,i] <= n - 2\n    return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\nmodel.lifted_mtz_cuts = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "This cut implements the **Lifted Desrochers-Laporte inequality**, which provides a complementary structural unification of the parents. While Parent 1 restricts absolute position bounds and Parent 2 explicitly prevents binary 2-cycles, this offspring constraint tightens the relative position difference between nodes i and j by incorporating a penalty for the reverse arc x(j,i). It creates a distinct, tighter polyhedral face that simultaneously enforces order restrictions and prunes fractional 2-cycles that standard MTZ formulations fail to catch."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 11.84,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 11.82,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.42,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 13.35,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 12.82,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 12.78,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.74,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.65,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 12.95,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 12.93,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 12.4,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 12.32,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 15.1,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 15.09,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 10.66,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 10.64,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 11.48,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 11.45,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 13.01,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 12.96,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "ea7ddb2c-ee51-480d-bc6a-0606eed013d8",
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                }
            ],
            10.353038952236112
        ],
        [
            [
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "af1495e1-5fc4-49ff-a8e4-c09b3c01a782",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Strengthened Lifted MTZ Cuts\n    # This constraint set combines Desrochers-Laporte lifting for internal nodes with \n    # tight variable-fixing bounds for arcs connected to the depot.\n    \n    def strengthened_mtz_rule(model, i, j):\n        if i == j:\n            return pyo.Constraint.Skip\n    \n        # 1. Internal Nodes (i, j != 1): Desrochers-Laporte Lifting\n        # Strengthens standard MTZ by lifting with the reverse arc term.\n        # Valid inequality: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n        if i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n        # 2. Depot Outgoing (1 -> j): Sequential Bound Tightening\n        # If arc (1, j) is selected, node j must be the second node in the tour (u_j = 2).\n        # This constraint tightens the upper bound of u_j based on x_1j.\n        # u_j + (n-2)x_1j <= n  =>  If x_1j=1, u_j <= 2 (forces u_j=2)\n        if i == 1:\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n    \n        # 3. Depot Incoming (i -> 1): Sequential Bound Tightening\n        # If arc (i, 1) is selected, node i must be the last node in the tour (u_i = n).\n        # This constraint tightens the lower bound of u_i based on x_i1.\n        # u_i - (n-2)x_i1 >= 2  =>  If x_i1=1, u_i >= n (forces u_i=n)\n        if j == 1:\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n    \n        return pyo.Constraint.Skip\n    \n    model.strengthened_mtz = pyo.Constraint(model.N, model.N, rule=strengthened_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Strengthened Lifted MTZ Cuts\n# This constraint set combines Desrochers-Laporte lifting for internal nodes with \n# tight variable-fixing bounds for arcs connected to the depot.\n\ndef strengthened_mtz_rule(model, i, j):\n    if i == j:\n        return pyo.Constraint.Skip\n\n    # 1. Internal Nodes (i, j != 1): Desrochers-Laporte Lifting\n    # Strengthens standard MTZ by lifting with the reverse arc term.\n    # Valid inequality: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n    if i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\n    # 2. Depot Outgoing (1 -> j): Sequential Bound Tightening\n    # If arc (1, j) is selected, node j must be the second node in the tour (u_j = 2).\n    # This constraint tightens the upper bound of u_j based on x_1j.\n    # u_j + (n-2)x_1j <= n  =>  If x_1j=1, u_j <= 2 (forces u_j=2)\n    if i == 1:\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n\n    # 3. Depot Incoming (i -> 1): Sequential Bound Tightening\n    # If arc (i, 1) is selected, node i must be the last node in the tour (u_i = n).\n    # This constraint tightens the lower bound of u_i based on x_i1.\n    # u_i - (n-2)x_i1 >= 2  =>  If x_i1=1, u_i >= n (forces u_i=n)\n    if j == 1:\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n\n    return pyo.Constraint.Skip\n\nmodel.strengthened_mtz = pyo.Constraint(model.N, model.N, rule=strengthened_mtz_rule)",
                        "idea": "This mutation preserves the Desrochers-Laporte lifting for internal nodes (which effectively suppresses 2-cycles and tightens the big-M coefficient) but significantly strengthens the handling of the depot. Instead of a simple cycle-breaking inequality (x_1j + x_j1 <= 1), it introduces 'Arc-Based Bound Tightening' constraints. These constraints strictly enforce the sequential logic of the tour: if a node is connected from the depot, its potential u must be 2, and if it connects to the depot, its potential must be n. This implicitly prevents subtours involving the depot (as u=2 and u=n are incompatible for the same node in a short cycle) and aggressively reduces the search space of the continuous relaxation."
                    },
                    "fitness": 2.5204461850752082,
                    "solver_reports": [
                        {
                            "gap": 11.8692,
                            "total_time": 11.54,
                            "explored_nodes": 1027,
                            "simplex_iterations": 22192,
                            "explored_time": 11.52,
                            "work_units": 10.04
                        },
                        {
                            "gap": 10.0546,
                            "total_time": 14.33,
                            "explored_nodes": 1,
                            "simplex_iterations": 1607,
                            "explored_time": 14.22,
                            "work_units": 10.0
                        },
                        {
                            "gap": 10.4024,
                            "total_time": 11.75,
                            "explored_nodes": 898,
                            "simplex_iterations": 16728,
                            "explored_time": 11.73,
                            "work_units": 10.02
                        },
                        {
                            "total_time": 12.74,
                            "explored_nodes": 1,
                            "simplex_iterations": 1982,
                            "explored_time": 12.65,
                            "work_units": 10.01
                        },
                        {
                            "gap": 3.3824,
                            "total_time": 12.58,
                            "explored_nodes": 2865,
                            "simplex_iterations": 48636,
                            "explored_time": 12.55,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.206,
                            "total_time": 12.45,
                            "explored_nodes": 1,
                            "simplex_iterations": 2801,
                            "explored_time": 12.4,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 2.79,
                            "postsolve": 0.01,
                            "explored_nodes": 73338,
                            "simplex_iterations": 432235,
                            "explored_time": 2.79,
                            "work_units": 1.8
                        },
                        {
                            "gap": 1.751,
                            "total_time": 14.25,
                            "explored_nodes": 3089,
                            "simplex_iterations": 51190,
                            "explored_time": 14.23,
                            "work_units": 10.24
                        },
                        {
                            "gap": 13.0466,
                            "total_time": 12.49,
                            "explored_nodes": 59,
                            "simplex_iterations": 3572,
                            "explored_time": 12.46,
                            "work_units": 11.33
                        },
                        {
                            "gap": 67.7228,
                            "total_time": 14.0,
                            "explored_nodes": 1,
                            "simplex_iterations": 1719,
                            "explored_time": 13.9,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "General",
                    "parents_id": [
                        "6432f306-5d6d-4b4c-b62c-577e3fa14cdc"
                    ]
                },
                {
                    "id": "099c4272-6b64-4d86-889b-c00f7e3852af",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # 1. Explicit 2-cycle elimination (from Parent 1)\n    # Standard MTZ allows fractional 2-cycles (e.g., x_ij=x_ji=0.9). \n    # Explicitly cutting these is highly effective (High Fitness).\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n    \n    # 2. Depot-based U-variable Lifting (Parent 2 optimized)\n    # Instead of the computationally expensive full Lifted MTZ (Parent 2), \n    # we apply lifting only to the bounds of u using depot connections.\n    # This tightens the relaxation with only O(n) sparse constraints.\n    \n    # If node i is visited immediately after the depot (1 -> i), u[i] must be 2.\n    # Logic: u[i] <= n - (n-2)*1 = 2. If x[1,i]=0, u[i] <= n (redundant but valid).\n    def u_lift_upper_rule(model, i):\n        if i != 1:\n            return model.u[i] <= n - (n - 2) * model.x[1, i]\n        return pyo.Constraint.Skip\n    model.u_lift_upper = pyo.Constraint(model.N, rule=u_lift_upper_rule)\n    \n    # If node i is visited immediately before the depot (i -> 1), u[i] must be n.\n    # Logic: u[i] >= 2 + (n-2)*1 = n. If x[i,1]=0, u[i] >= 2 (redundant but valid).\n    def u_lift_lower_rule(model, i):\n        if i != 1:\n            return model.u[i] >= 2 + (n - 2) * model.x[i, 1]\n        return pyo.Constraint.Skip\n    model.u_lift_lower = pyo.Constraint(model.N, rule=u_lift_lower_rule)\n\n    return model\n",
                        "added_cut": "# 1. Explicit 2-cycle elimination (from Parent 1)\n# Standard MTZ allows fractional 2-cycles (e.g., x_ij=x_ji=0.9). \n# Explicitly cutting these is highly effective (High Fitness).\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n# 2. Depot-based U-variable Lifting (Parent 2 optimized)\n# Instead of the computationally expensive full Lifted MTZ (Parent 2), \n# we apply lifting only to the bounds of u using depot connections.\n# This tightens the relaxation with only O(n) sparse constraints.\n\n# If node i is visited immediately after the depot (1 -> i), u[i] must be 2.\n# Logic: u[i] <= n - (n-2)*1 = 2. If x[1,i]=0, u[i] <= n (redundant but valid).\ndef u_lift_upper_rule(model, i):\n    if i != 1:\n        return model.u[i] <= n - (n - 2) * model.x[1, i]\n    return pyo.Constraint.Skip\nmodel.u_lift_upper = pyo.Constraint(model.N, rule=u_lift_upper_rule)\n\n# If node i is visited immediately before the depot (i -> 1), u[i] must be n.\n# Logic: u[i] >= 2 + (n-2)*1 = n. If x[i,1]=0, u[i] >= 2 (redundant but valid).\ndef u_lift_lower_rule(model, i):\n    if i != 1:\n        return model.u[i] >= 2 + (n - 2) * model.x[i, 1]\n    return pyo.Constraint.Skip\nmodel.u_lift_lower = pyo.Constraint(model.N, rule=u_lift_lower_rule)",
                        "idea": "Combines the most effective components of both parents. From Parent 1, it retains the explicit 2-cycle cuts ($x_{ij} + x_{ji} \\le 1$) which are crucial for cutting fractional subtours that the standard MTZ formulation misses. From Parent 2, it distills the 'lifting' conceptlinking $u$ and $x$ variablesinto a simplified, sparse form ($O(n)$ vs $O(n^2)$) that tightens the bounds on $u_i$ based specifically on depot connections (forcing $u_i=2$ if $x_{1,i}=1$ and $u_i=n$ if $x_{i,1}=1$). This creates a tighter relaxation than Parent 1 alone while avoiding the computational overhead that penalized Parent 2."
                    },
                    "fitness": 2.008793581579639,
                    "solver_reports": [
                        {
                            "gap": 12.0009,
                            "total_time": 13.95,
                            "explored_nodes": 3451,
                            "simplex_iterations": 50307,
                            "explored_time": 13.94,
                            "work_units": 10.02
                        },
                        {
                            "total_time": 12.18,
                            "explored_nodes": 1,
                            "simplex_iterations": 5387,
                            "explored_time": 12.12,
                            "work_units": 10.0
                        },
                        {
                            "gap": 8.5121,
                            "total_time": 13.15,
                            "explored_nodes": 171,
                            "simplex_iterations": 12014,
                            "explored_time": 13.14,
                            "work_units": 10.13
                        },
                        {
                            "total_time": 14.45,
                            "explored_nodes": 1,
                            "simplex_iterations": 3391,
                            "explored_time": 14.37,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.6377,
                            "total_time": 12.8,
                            "explored_nodes": 3498,
                            "simplex_iterations": 89001,
                            "explored_time": 12.79,
                            "work_units": 10.01
                        },
                        {
                            "gap": 44.411,
                            "total_time": 14.41,
                            "explored_nodes": 59,
                            "simplex_iterations": 6228,
                            "explored_time": 14.36,
                            "work_units": 10.27
                        },
                        {
                            "gap": 3.5078,
                            "total_time": 14.06,
                            "explored_nodes": 328880,
                            "simplex_iterations": 2248789,
                            "explored_time": 14.05,
                            "work_units": 10.12
                        },
                        {
                            "gap": 2.2673,
                            "total_time": 14.03,
                            "explored_nodes": 2794,
                            "simplex_iterations": 81079,
                            "explored_time": 14.01,
                            "work_units": 10.0
                        },
                        {
                            "gap": 21.6381,
                            "total_time": 13.33,
                            "explored_nodes": 59,
                            "simplex_iterations": 7532,
                            "explored_time": 13.3,
                            "work_units": 10.86
                        },
                        {
                            "gap": 49.6698,
                            "total_time": 12.32,
                            "explored_nodes": 15,
                            "simplex_iterations": 5351,
                            "explored_time": 12.27,
                            "work_units": 10.01
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "276069fa-eba9-45f5-b2e4-258b128a72d4"
                    ]
                },
                {
                    "id": "fadbcc15-6ad6-48d6-8b82-910d79189cd1",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Depot-Anchored Position Bounds\n    # These constraints tighten the domain of u[i] based on arcs connected to the depot.\n    # While Parent 1 strengthens the internal relative ordering, these cuts fix the \n    # absolute positions at the start and end of the tour.\n    def depot_lower_bound_rule(model, i):\n        # If arc (i, 1) is used, i is the last node in the tour -> u[i] must be n.\n        # Otherwise, u[i] >= 2 holds naturally.\n        if i != 1:\n            return model.u[i] >= 2 + (n - 2) * model.x[i, 1]\n        return pyo.Constraint.Skip\n    model.depot_lower_bound = pyo.Constraint(model.N, rule=depot_lower_bound_rule)\n    \n    def depot_upper_bound_rule(model, i):\n        # If arc (1, i) is used, i is the first node after depot -> u[i] must be 2.\n        # Otherwise, u[i] <= n holds naturally.\n        if i != 1:\n            return model.u[i] <= n - (n - 2) * model.x[1, i]\n        return pyo.Constraint.Skip\n    model.depot_upper_bound = pyo.Constraint(model.N, rule=depot_upper_bound_rule)\n\n    return model\n",
                        "added_cut": "# Depot-Anchored Position Bounds\n# These constraints tighten the domain of u[i] based on arcs connected to the depot.\n# While Parent 1 strengthens the internal relative ordering, these cuts fix the \n# absolute positions at the start and end of the tour.\ndef depot_lower_bound_rule(model, i):\n    # If arc (i, 1) is used, i is the last node in the tour -> u[i] must be n.\n    # Otherwise, u[i] >= 2 holds naturally.\n    if i != 1:\n        return model.u[i] >= 2 + (n - 2) * model.x[i, 1]\n    return pyo.Constraint.Skip\nmodel.depot_lower_bound = pyo.Constraint(model.N, rule=depot_lower_bound_rule)\n\ndef depot_upper_bound_rule(model, i):\n    # If arc (1, i) is used, i is the first node after depot -> u[i] must be 2.\n    # Otherwise, u[i] <= n holds naturally.\n    if i != 1:\n        return model.u[i] <= n - (n - 2) * model.x[1, i]\n    return pyo.Constraint.Skip\nmodel.depot_upper_bound = pyo.Constraint(model.N, rule=depot_upper_bound_rule)",
                        "idea": "I introduced Depot-Anchored Position Bounds. While Parent 1 (Desrochers-Laporte) strengthens the relative ordering between non-depot nodes and Parent 2 explicitly prevents binary 2-cycles, neither enforces the strict implications of connecting to the depot on the continuous variables u. These cuts complement the parents by handling the 'boundary conditions' of the tour: they force u_i to 2 if connected from the depot, and u_i to n if connected to the depot, significantly tightening the linear relaxation for arcs adjacent to the start/end."
                    },
                    "fitness": 7.574143807819105,
                    "solver_reports": [
                        {
                            "gap": 9.2893,
                            "total_time": 12.32,
                            "explored_nodes": 4200,
                            "simplex_iterations": 57100,
                            "explored_time": 12.29,
                            "work_units": 10.0
                        },
                        {
                            "gap": 2.3443,
                            "total_time": 13.61,
                            "explored_nodes": 102,
                            "simplex_iterations": 9188,
                            "explored_time": 13.57,
                            "work_units": 10.03
                        },
                        {
                            "gap": 8.8891,
                            "total_time": 11.17,
                            "explored_nodes": 882,
                            "simplex_iterations": 19372,
                            "explored_time": 11.15,
                            "work_units": 10.04
                        },
                        {
                            "gap": 92.2872,
                            "total_time": 14.35,
                            "explored_nodes": 1,
                            "simplex_iterations": 3502,
                            "explored_time": 14.28,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.0747,
                            "total_time": 13.72,
                            "explored_nodes": 3741,
                            "simplex_iterations": 64275,
                            "explored_time": 13.71,
                            "work_units": 10.01
                        },
                        {
                            "gap": 22.1117,
                            "total_time": 13.87,
                            "explored_nodes": 165,
                            "simplex_iterations": 8769,
                            "explored_time": 13.84,
                            "work_units": 11.25
                        },
                        {
                            "gap": 4.7055,
                            "total_time": 13.73,
                            "explored_nodes": 212017,
                            "simplex_iterations": 1572997,
                            "explored_time": 13.72,
                            "work_units": 10.03
                        },
                        {
                            "gap": 3.2445,
                            "total_time": 12.55,
                            "explored_nodes": 2854,
                            "simplex_iterations": 66244,
                            "explored_time": 12.53,
                            "work_units": 10.0
                        },
                        {
                            "gap": 24.8031,
                            "total_time": 11.21,
                            "explored_nodes": 87,
                            "simplex_iterations": 7265,
                            "explored_time": 11.19,
                            "work_units": 10.64
                        },
                        {
                            "gap": 9.7595,
                            "total_time": 14.41,
                            "explored_nodes": 255,
                            "simplex_iterations": 11500,
                            "explored_time": 14.38,
                            "work_units": 11.42
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "4219409c-63d8-4d59-a41b-68893bae294b",
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "7f8c5801-0e91-4e60-bc1b-85e77644b6cb",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Hybrid Constraint: Desrochers-Laporte Internal Lifting + Depot-Lifted Bounds\n    # Integrates Parent 1's lifted MTZ structure for internal nodes and extends the \n    # 2-cycle prevention logic (Parent 2) to the depot via strengthened variable bounds.\n    \n    # 1. Desrochers-Laporte constraints for internal pairs (i, j != 1)\n    # This strengthens the subtour elimination by lifting with the reverse arc x[j,i].\n    # It implicitly prevents 2-cycles between internal nodes i and j.\n    def dl_internal_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    model.dl_internal = pyo.Constraint(model.N, model.N, rule=dl_internal_rule)\n    \n    # 2. Lifted Variable Bounds relative to the Depot\n    # These constraints hybridize Parent 2's explicit cut logic into the u-variables.\n    # They enforce that if connected to the depot, the node position u[i] is fixed to 2 or n,\n    # which strictly dominates standard bounds and prevents 2-cycles involving the depot.\n    \n    def depot_lifted_lb_rule(model, i):\n        # If i -> 1, i must be the last node (u=n). Implies u[i] >= 2 + (n-2)*x[i,1]\n        return model.u[i] >= 2 + (n - 2) * model.x[i, 1] if i != 1 else pyo.Constraint.Skip\n    model.depot_lifted_lb = pyo.Constraint(model.N, rule=depot_lifted_lb_rule)\n    \n    def depot_lifted_ub_rule(model, i):\n        # If 1 -> i, i must be the first node (u=2). Implies u[i] <= n - (n-2)*x[1,i]\n        return model.u[i] <= n - (n - 2) * model.x[1, i] if i != 1 else pyo.Constraint.Skip\n    model.depot_lifted_ub = pyo.Constraint(model.N, rule=depot_lifted_ub_rule)\n\n    return model\n",
                        "added_cut": "# Hybrid Constraint: Desrochers-Laporte Internal Lifting + Depot-Lifted Bounds\n# Integrates Parent 1's lifted MTZ structure for internal nodes and extends the \n# 2-cycle prevention logic (Parent 2) to the depot via strengthened variable bounds.\n\n# 1. Desrochers-Laporte constraints for internal pairs (i, j != 1)\n# This strengthens the subtour elimination by lifting with the reverse arc x[j,i].\n# It implicitly prevents 2-cycles between internal nodes i and j.\ndef dl_internal_rule(model, i, j):\n    if i != j and i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\nmodel.dl_internal = pyo.Constraint(model.N, model.N, rule=dl_internal_rule)\n\n# 2. Lifted Variable Bounds relative to the Depot\n# These constraints hybridize Parent 2's explicit cut logic into the u-variables.\n# They enforce that if connected to the depot, the node position u[i] is fixed to 2 or n,\n# which strictly dominates standard bounds and prevents 2-cycles involving the depot.\n\ndef depot_lifted_lb_rule(model, i):\n    # If i -> 1, i must be the last node (u=n). Implies u[i] >= 2 + (n-2)*x[i,1]\n    return model.u[i] >= 2 + (n - 2) * model.x[i, 1] if i != 1 else pyo.Constraint.Skip\nmodel.depot_lifted_lb = pyo.Constraint(model.N, rule=depot_lifted_lb_rule)\n\ndef depot_lifted_ub_rule(model, i):\n    # If 1 -> i, i must be the first node (u=2). Implies u[i] <= n - (n-2)*x[1,i]\n    return model.u[i] <= n - (n - 2) * model.x[1, i] if i != 1 else pyo.Constraint.Skip\nmodel.depot_lifted_ub = pyo.Constraint(model.N, rule=depot_lifted_ub_rule)",
                        "idea": "The hybrid strategy merges the Desrochers-Laporte lifting (Parent 1) with the explicit cycle-breaking logic of Parent 2. While Parent 1 efficiently tightens internal subtours, it leaves depot connections governed by weaker standard bounds. This offspring introduces 'lifted depot bounds' that link the position variables $u_i$ directly to depot arcs $x_{1,i}$ and $x_{i,1}$. These bounds mathematically imply the explicit 2-cycle cuts ($x_{1,i} + x_{i,1} \\le 1$) for the depot pairs and significantly tighten the linear relaxation by forcing $u$ to the extremes of its domain when connected to the depot, creating a fully strengthened MTZ formulation."
                    },
                    "fitness": 8.36156699066786,
                    "solver_reports": [
                        {
                            "gap": 15.3233,
                            "total_time": 11.7,
                            "explored_nodes": 772,
                            "simplex_iterations": 22493,
                            "explored_time": 11.68,
                            "work_units": 10.27
                        },
                        {
                            "gap": 8.7487,
                            "total_time": 14.99,
                            "explored_nodes": 1,
                            "simplex_iterations": 2038,
                            "explored_time": 14.86,
                            "work_units": 10.01
                        },
                        {
                            "gap": 8.5312,
                            "total_time": 11.35,
                            "explored_nodes": 1110,
                            "simplex_iterations": 28097,
                            "explored_time": 11.33,
                            "work_units": 10.02
                        },
                        {
                            "total_time": 12.79,
                            "explored_nodes": 1,
                            "simplex_iterations": 1611,
                            "explored_time": 12.68,
                            "work_units": 10.01
                        },
                        {
                            "gap": 2.3704,
                            "total_time": 14.2,
                            "explored_nodes": 3390,
                            "simplex_iterations": 71570,
                            "explored_time": 14.19,
                            "work_units": 10.02
                        },
                        {
                            "gap": 10.4932,
                            "total_time": 12.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 1615,
                            "explored_time": 12.08,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 1.23,
                            "postsolve": 0.0,
                            "explored_nodes": 10661,
                            "simplex_iterations": 75528,
                            "explored_time": 1.22,
                            "work_units": 0.69
                        },
                        {
                            "gap": 8.7137,
                            "total_time": 12.31,
                            "explored_nodes": 59,
                            "simplex_iterations": 6141,
                            "explored_time": 12.29,
                            "work_units": 10.1
                        },
                        {
                            "gap": 17.4047,
                            "total_time": 10.8,
                            "explored_nodes": 15,
                            "simplex_iterations": 2317,
                            "explored_time": 10.77,
                            "work_units": 10.11
                        },
                        {
                            "total_time": 13.4,
                            "explored_nodes": 1,
                            "simplex_iterations": 2088,
                            "explored_time": 13.32,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "4219409c-63d8-4d59-a41b-68893bae294b",
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "edde8a4d-8aff-4a9f-8cc2-6fe807c39516",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Depot-Lifted Desrochers & Laporte MTZ Constraints\n    # This mutation sequentially lifts the DL constraint using depot-connection variables x[1,j] and x[i,1].\n    def depot_lifted_mtz_rule(model, i, j):\n        # Apply to all pairs of non-depot nodes\n        if i != j and i != 1 and j != 1:\n            # Original DL bound is n-2. \n            # If x[1,j]=0, node j is not 2nd, so u[j] >= 3.\n            # If x[i,1]=0, node i is not last, so u[i] <= n-1.\n            # Thus, if unconnected to depot, u[i] - u[j] <= n-4.\n            # We lift this tighter bound (n-4) by adding terms for the arcs x[i,j], x[j,i], x[1,j], and x[i,1].\n            return (model.u[i] - model.u[j] + \n                    (n - 3) * model.x[i, j] + \n                    (n - 5) * model.x[j, i] - \n                    model.x[1, j] - model.x[i, 1] <= n - 4)\n        return pyo.Constraint.Skip\n    \n    model.depot_lifted_mtz = pyo.Constraint(model.N, model.N, rule=depot_lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Depot-Lifted Desrochers & Laporte MTZ Constraints\n# This mutation sequentially lifts the DL constraint using depot-connection variables x[1,j] and x[i,1].\ndef depot_lifted_mtz_rule(model, i, j):\n    # Apply to all pairs of non-depot nodes\n    if i != j and i != 1 and j != 1:\n        # Original DL bound is n-2. \n        # If x[1,j]=0, node j is not 2nd, so u[j] >= 3.\n        # If x[i,1]=0, node i is not last, so u[i] <= n-1.\n        # Thus, if unconnected to depot, u[i] - u[j] <= n-4.\n        # We lift this tighter bound (n-4) by adding terms for the arcs x[i,j], x[j,i], x[1,j], and x[i,1].\n        return (model.u[i] - model.u[j] + \n                (n - 3) * model.x[i, j] + \n                (n - 5) * model.x[j, i] - \n                model.x[1, j] - model.x[i, 1] <= n - 4)\n    return pyo.Constraint.Skip\n\nmodel.depot_lifted_mtz = pyo.Constraint(model.N, model.N, rule=depot_lifted_mtz_rule)",
                        "idea": "I strengthened the Desrochers-Laporte cut by performing sequential lifting on the depot-incident arcs ($x_{1j}$ and $x_{i1}$). Recognizing that if node $j$ is not visited immediately after the depot and node $i$ is not visited immediately before the depot, the feasible range of position differences $u_i - u_j$ shrinks from $n-2$ to $n-4$. I incorporated this logic by reducing the RHS to $n-4$ and adding the lifting terms $-x_{1j}$ and $-x_{i1}$ to the LHS. To maintain validity when the direct arcs are used, the coefficients for $x_{ij}$ and $x_{ji}$ were adjusted to $n-3$ and $n-5$ respectively. This formulation dominates the original DL cut by strictly tightening the relaxation for all internal paths not directly connected to the depot."
                    },
                    "fitness": 0.9031322657546172,
                    "solver_reports": [
                        {
                            "gap": 33.591,
                            "total_time": 11.65,
                            "explored_nodes": 470,
                            "simplex_iterations": 10708,
                            "explored_time": 11.63,
                            "work_units": 10.05
                        },
                        {
                            "gap": 25.5389,
                            "total_time": 11.73,
                            "explored_nodes": 1,
                            "simplex_iterations": 2382,
                            "explored_time": 11.64,
                            "work_units": 10.01
                        },
                        {
                            "gap": 15.0465,
                            "total_time": 11.85,
                            "explored_nodes": 143,
                            "simplex_iterations": 5397,
                            "explored_time": 11.83,
                            "work_units": 11.95
                        },
                        {
                            "total_time": 11.53,
                            "explored_nodes": 1,
                            "simplex_iterations": 1987,
                            "explored_time": 11.44,
                            "work_units": 10.0
                        },
                        {
                            "gap": 9.4499,
                            "total_time": 10.52,
                            "explored_nodes": 1205,
                            "simplex_iterations": 23464,
                            "explored_time": 10.51,
                            "work_units": 10.03
                        },
                        {
                            "gap": 29.0264,
                            "total_time": 10.75,
                            "explored_nodes": 1,
                            "simplex_iterations": 1908,
                            "explored_time": 10.68,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.9194,
                            "total_time": 13.11,
                            "explored_nodes": 182537,
                            "simplex_iterations": 1133508,
                            "explored_time": 13.11,
                            "work_units": 10.01
                        },
                        {
                            "gap": 10.4909,
                            "total_time": 10.8,
                            "explored_nodes": 143,
                            "simplex_iterations": 7860,
                            "explored_time": 10.78,
                            "work_units": 10.01
                        },
                        {
                            "gap": 30.3628,
                            "total_time": 12.54,
                            "explored_nodes": 1,
                            "simplex_iterations": 1286,
                            "explored_time": 12.49,
                            "work_units": 10.0
                        },
                        {
                            "gap": 51.4389,
                            "total_time": 12.08,
                            "explored_nodes": 1,
                            "simplex_iterations": 1517,
                            "explored_time": 12.02,
                            "work_units": 10.07
                        }
                    ],
                    "generator": "Lifted",
                    "parents_id": [
                        "4219409c-63d8-4d59-a41b-68893bae294b"
                    ]
                },
                {
                    "id": "46e59429-4c1f-466a-a42c-b58f5066131e",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Depot-Position Tightening Constraints\n    # These constraints anchor the potential variables u[i] based on depot adjacency,\n    # creating a tighter 'frame' for the subtour elimination constraints to operate within.\n    \n    def depot_position_lb_rule(model, i):\n        # Tightened Lower Bound for non-depot nodes:\n        # 1. If i is the first node (x[1,i]=1), u[i] must be 2.\n        # 2. If i is the last node (x[i,1]=1), u[i] must be n.\n        # 3. If i is an internal node (neither first nor last), it must be at least step 3.\n        # Inequality: u[i] >= 3 - x[1,i] + (n-3)*x[i,1]\n        if i != 1:\n            return model.u[i] + model.x[1, i] - (n - 3) * model.x[i, 1] >= 3\n        return pyo.Constraint.Skip\n    \n    model.depot_position_lb = pyo.Constraint(model.N, rule=depot_position_lb_rule)\n    \n    def depot_position_ub_rule(model, i):\n        # Tightened Upper Bound for non-depot nodes:\n        # 1. If i is the first node (x[1,i]=1), u[i] must be 2.\n        # 2. If i is the last node (x[i,1]=1), u[i] must be n.\n        # 3. If i is an internal node, it cannot be later than step n-1.\n        # Inequality: u[i] <= (n-1) + x[i,1] - (n-3)*x[1,i]\n        if i != 1:\n            return model.u[i] - model.x[i, 1] + (n - 3) * model.x[1, i] <= n - 1\n        return pyo.Constraint.Skip\n    \n    model.depot_position_ub = pyo.Constraint(model.N, rule=depot_position_ub_rule)\n\n    return model\n",
                        "added_cut": "# Depot-Position Tightening Constraints\n# These constraints anchor the potential variables u[i] based on depot adjacency,\n# creating a tighter 'frame' for the subtour elimination constraints to operate within.\n\ndef depot_position_lb_rule(model, i):\n    # Tightened Lower Bound for non-depot nodes:\n    # 1. If i is the first node (x[1,i]=1), u[i] must be 2.\n    # 2. If i is the last node (x[i,1]=1), u[i] must be n.\n    # 3. If i is an internal node (neither first nor last), it must be at least step 3.\n    # Inequality: u[i] >= 3 - x[1,i] + (n-3)*x[i,1]\n    if i != 1:\n        return model.u[i] + model.x[1, i] - (n - 3) * model.x[i, 1] >= 3\n    return pyo.Constraint.Skip\n\nmodel.depot_position_lb = pyo.Constraint(model.N, rule=depot_position_lb_rule)\n\ndef depot_position_ub_rule(model, i):\n    # Tightened Upper Bound for non-depot nodes:\n    # 1. If i is the first node (x[1,i]=1), u[i] must be 2.\n    # 2. If i is the last node (x[i,1]=1), u[i] must be n.\n    # 3. If i is an internal node, it cannot be later than step n-1.\n    # Inequality: u[i] <= (n-1) + x[i,1] - (n-3)*x[1,i]\n    if i != 1:\n        return model.u[i] - model.x[i, 1] + (n - 3) * model.x[1, i] <= n - 1\n    return pyo.Constraint.Skip\n\nmodel.depot_position_ub = pyo.Constraint(model.N, rule=depot_position_ub_rule)",
                        "idea": "While both parents focus on strengthening the *relative* differences between node potentials ($u_i - u_j$) via lifted MTZ cuts, this offspring implements **Lifted Position Bounds** that tighten the *absolute* domains of $u_i$ based on depot connectivity. By enforcing that start-nodes are exactly 2, end-nodes are exactly $n$, and internal nodes are strictly confined to $[3, n-1]$, this formulation eliminates fractional solutions where $u$ values 'float' loosely near the depot. This anchors the search space at the endpoints, making the parents' internal subtour elimination cuts significantly more effective."
                    },
                    "fitness": 1.7028451877265267,
                    "solver_reports": [
                        {
                            "gap": 7.9012,
                            "total_time": 12.72,
                            "explored_nodes": 3520,
                            "simplex_iterations": 60486,
                            "explored_time": 12.69,
                            "work_units": 10.0
                        },
                        {
                            "gap": 55.9895,
                            "total_time": 12.17,
                            "explored_nodes": 1,
                            "simplex_iterations": 6973,
                            "explored_time": 12.12,
                            "work_units": 10.0
                        },
                        {
                            "gap": 22.0816,
                            "total_time": 11.94,
                            "explored_nodes": 1994,
                            "simplex_iterations": 37402,
                            "explored_time": 11.93,
                            "work_units": 10.04
                        },
                        {
                            "gap": 91.9378,
                            "total_time": 15.39,
                            "explored_nodes": 1,
                            "simplex_iterations": 3945,
                            "explored_time": 15.34,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.9062,
                            "total_time": 13.8,
                            "explored_nodes": 8804,
                            "simplex_iterations": 92126,
                            "explored_time": 13.78,
                            "work_units": 10.0
                        },
                        {
                            "gap": 37.375,
                            "total_time": 12.38,
                            "explored_nodes": 59,
                            "simplex_iterations": 5763,
                            "explored_time": 12.35,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.8481,
                            "total_time": 13.16,
                            "explored_nodes": 168310,
                            "simplex_iterations": 1101069,
                            "explored_time": 13.16,
                            "work_units": 10.05
                        },
                        {
                            "gap": 8.9884,
                            "total_time": 11.51,
                            "explored_nodes": 4131,
                            "simplex_iterations": 60158,
                            "explored_time": 11.48,
                            "work_units": 10.0
                        },
                        {
                            "gap": 42.3823,
                            "total_time": 13.33,
                            "explored_nodes": 171,
                            "simplex_iterations": 8366,
                            "explored_time": 13.3,
                            "work_units": 12.11
                        },
                        {
                            "gap": 32.2994,
                            "total_time": 13.5,
                            "explored_nodes": 14,
                            "simplex_iterations": 5778,
                            "explored_time": 13.47,
                            "work_units": 10.07
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "4219409c-63d8-4d59-a41b-68893bae294b",
                        "767a8055-2320-475c-ba59-7fed4e475237"
                    ]
                },
                {
                    "id": "af57ce47-5200-4273-9541-b8f655f0ab69",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Depot-Lifted MTZ Stronger Constraints\n    # Dominates the Desrochers-Laporte cut by lifting depot connection variables (x[i,1], x[1,j])\n    # to tighten the RHS slack from n-2 to n-4 when nodes are not adjacent to the depot.\n    def depot_lifted_mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            # Derived Inequality:\n            # u_i - u_j + (n-3)x_{ij} + (n-5)x_{ji} - x_{i1} - x_{1j} <= n - 4\n            # Validity:\n            # 1. x_{ij}=1 => u_i - u_j = -1. LHS = -1 + n - 3 = n - 4. Valid.\n            # 2. x_{ji}=1 => u_i - u_j = 1. LHS = 1 + n - 5 = n - 4. Valid.\n            # 3. x=0 => Max u_i - u_j occurs when i is 'late' and j is 'early'.\n            #    If x_{i1}=0, max u_i = n-1. If x_{1j}=0, min u_j = 3. Diff <= n-4.\n            return model.u[i] - model.u[j] + (n - 3) * model.x[i, j] + (n - 5) * model.x[j, i] - model.x[i, 1] - model.x[1, j] <= n - 4\n        return pyo.Constraint.Skip\n    \n    model.depot_lifted_mtz = pyo.Constraint(model.N, model.N, rule=depot_lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Depot-Lifted MTZ Stronger Constraints\n# Dominates the Desrochers-Laporte cut by lifting depot connection variables (x[i,1], x[1,j])\n# to tighten the RHS slack from n-2 to n-4 when nodes are not adjacent to the depot.\ndef depot_lifted_mtz_rule(model, i, j):\n    if i != j and i != 1 and j != 1:\n        # Derived Inequality:\n        # u_i - u_j + (n-3)x_{ij} + (n-5)x_{ji} - x_{i1} - x_{1j} <= n - 4\n        # Validity:\n        # 1. x_{ij}=1 => u_i - u_j = -1. LHS = -1 + n - 3 = n - 4. Valid.\n        # 2. x_{ji}=1 => u_i - u_j = 1. LHS = 1 + n - 5 = n - 4. Valid.\n        # 3. x=0 => Max u_i - u_j occurs when i is 'late' and j is 'early'.\n        #    If x_{i1}=0, max u_i = n-1. If x_{1j}=0, min u_j = 3. Diff <= n-4.\n        return model.u[i] - model.u[j] + (n - 3) * model.x[i, j] + (n - 5) * model.x[j, i] - model.x[i, 1] - model.x[1, j] <= n - 4\n    return pyo.Constraint.Skip\n\nmodel.depot_lifted_mtz = pyo.Constraint(model.N, model.N, rule=depot_lifted_mtz_rule)",
                        "idea": "I applied a coefficient lifting procedure based on the positioning of nodes relative to the depot. In the MTZ framework, the maximum difference u_i - u_j is n-2. However, if node i is not the last node (x_{i1}=0) and node j is not the first node (x_{1j}=0), this difference is bounded by n-4. By incorporating the depot-connection variables x_{i1} and x_{1j} into the constraint, I tightened the Right-Hand Side (RHS) to n-4 and adjusted the coefficients of x_{ij} and x_{ji} to (n-3) and (n-5) respectively. This creates a hyperplane that strictly dominates the Desrochers-Laporte cut in the fractional relaxation when arc variables are close to zero."
                    },
                    "fitness": 0.9031322657546172,
                    "solver_reports": [
                        {
                            "gap": 33.591,
                            "total_time": 11.1,
                            "explored_nodes": 470,
                            "simplex_iterations": 10708,
                            "explored_time": 11.08,
                            "work_units": 10.05
                        },
                        {
                            "gap": 25.5389,
                            "total_time": 11.74,
                            "explored_nodes": 1,
                            "simplex_iterations": 2382,
                            "explored_time": 11.64,
                            "work_units": 10.01
                        },
                        {
                            "gap": 15.0465,
                            "total_time": 12.1,
                            "explored_nodes": 143,
                            "simplex_iterations": 5397,
                            "explored_time": 12.08,
                            "work_units": 11.95
                        },
                        {
                            "total_time": 11.48,
                            "explored_nodes": 1,
                            "simplex_iterations": 1987,
                            "explored_time": 11.36,
                            "work_units": 10.0
                        },
                        {
                            "gap": 9.4499,
                            "total_time": 10.42,
                            "explored_nodes": 1205,
                            "simplex_iterations": 23464,
                            "explored_time": 10.41,
                            "work_units": 10.03
                        },
                        {
                            "gap": 29.0264,
                            "total_time": 10.7,
                            "explored_nodes": 1,
                            "simplex_iterations": 1908,
                            "explored_time": 10.61,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.9194,
                            "total_time": 12.84,
                            "explored_nodes": 182537,
                            "simplex_iterations": 1133508,
                            "explored_time": 12.84,
                            "work_units": 10.01
                        },
                        {
                            "gap": 10.4909,
                            "total_time": 10.51,
                            "explored_nodes": 143,
                            "simplex_iterations": 7860,
                            "explored_time": 10.49,
                            "work_units": 10.01
                        },
                        {
                            "gap": 30.3628,
                            "total_time": 11.79,
                            "explored_nodes": 1,
                            "simplex_iterations": 1286,
                            "explored_time": 11.75,
                            "work_units": 10.0
                        },
                        {
                            "gap": 51.4389,
                            "total_time": 12.25,
                            "explored_nodes": 1,
                            "simplex_iterations": 1517,
                            "explored_time": 12.18,
                            "work_units": 10.07
                        }
                    ],
                    "generator": "Lifted",
                    "parents_id": [
                        "4219409c-63d8-4d59-a41b-68893bae294b"
                    ]
                }
            ],
            10.353038952236112
        ],
        [
            [
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "1c76dd70-5196-4d1c-a378-83cc15c00d2a",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Tightened Depot-Anchored Position Bounds\n    # Mutated from the original idea: We strengthen the bounds by considering \n    # the case where a node is NEITHER the first nor the last.\n    # If i is not connected to depot (x[i,1]=0 and x[1,i]=0), then 3 <= u[i] <= n-1.\n    # This combined logic dominates the original simpler cuts.\n    \n    def tight_depot_lb_rule(model, i):\n        if i != 1:\n            # Combines three cases:\n            # 1. x[i,1]=1 (last node) -> u[i] >= 3 + (n-3) - 0 = n\n            # 2. x[1,i]=1 (first node) -> u[i] >= 3 + 0 - 1 = 2\n            # 3. Neither (internal node) -> u[i] >= 3\n            return model.u[i] >= 3 + (n - 3) * model.x[i, 1] - model.x[1, i]\n        return pyo.Constraint.Skip\n    model.tight_depot_lb = pyo.Constraint(model.N, rule=tight_depot_lb_rule)\n    \n    def tight_depot_ub_rule(model, i):\n        if i != 1:\n            # Combines three cases:\n            # 1. x[1,i]=1 (first node) -> u[i] <= (n-1) + 0 - (n-3) = 2\n            # 2. x[i,1]=1 (last node) -> u[i] <= (n-1) + 1 - 0 = n\n            # 3. Neither (internal node) -> u[i] <= n - 1\n            return model.u[i] <= (n - 1) + model.x[i, 1] - (n - 3) * model.x[1, i]\n        return pyo.Constraint.Skip\n    model.tight_depot_ub = pyo.Constraint(model.N, rule=tight_depot_ub_rule)\n\n    return model\n",
                        "added_cut": "# Tightened Depot-Anchored Position Bounds\n# Mutated from the original idea: We strengthen the bounds by considering \n# the case where a node is NEITHER the first nor the last.\n# If i is not connected to depot (x[i,1]=0 and x[1,i]=0), then 3 <= u[i] <= n-1.\n# This combined logic dominates the original simpler cuts.\n\ndef tight_depot_lb_rule(model, i):\n    if i != 1:\n        # Combines three cases:\n        # 1. x[i,1]=1 (last node) -> u[i] >= 3 + (n-3) - 0 = n\n        # 2. x[1,i]=1 (first node) -> u[i] >= 3 + 0 - 1 = 2\n        # 3. Neither (internal node) -> u[i] >= 3\n        return model.u[i] >= 3 + (n - 3) * model.x[i, 1] - model.x[1, i]\n    return pyo.Constraint.Skip\nmodel.tight_depot_lb = pyo.Constraint(model.N, rule=tight_depot_lb_rule)\n\ndef tight_depot_ub_rule(model, i):\n    if i != 1:\n        # Combines three cases:\n        # 1. x[1,i]=1 (first node) -> u[i] <= (n-1) + 0 - (n-3) = 2\n        # 2. x[i,1]=1 (last node) -> u[i] <= (n-1) + 1 - 0 = n\n        # 3. Neither (internal node) -> u[i] <= n - 1\n        return model.u[i] <= (n - 1) + model.x[i, 1] - (n - 3) * model.x[1, i]\n    return pyo.Constraint.Skip\nmodel.tight_depot_ub = pyo.Constraint(model.N, rule=tight_depot_ub_rule)",
                        "idea": "Strengthened the depot-anchored bounds by narrowing the feasible interval for 'internal' nodes. While the original cuts enforced $u_i=2$ or $u_i=n$ only when explicitly connected to the depot, these mutated constraints additionally enforce $3 \\le u_i \\le n-1$ when node $i$ is not adjacent to the depot (neither first nor last). This strictly tightens the linear relaxation by removing fractional solutions where $u_i$ approaches extreme values without the requisite depot connections."
                    },
                    "fitness": 3.3312815631683423,
                    "solver_reports": [
                        {
                            "gap": 29.7663,
                            "total_time": 12.21,
                            "explored_nodes": 5414,
                            "simplex_iterations": 69380,
                            "explored_time": 12.18,
                            "work_units": 11.23
                        },
                        {
                            "gap": 20.2139,
                            "total_time": 12.86,
                            "explored_nodes": 1,
                            "simplex_iterations": 6006,
                            "explored_time": 12.82,
                            "work_units": 10.0
                        },
                        {
                            "gap": 10.0498,
                            "total_time": 11.17,
                            "explored_nodes": 8265,
                            "simplex_iterations": 95014,
                            "explored_time": 11.16,
                            "work_units": 10.0
                        },
                        {
                            "gap": 51.0184,
                            "total_time": 14.33,
                            "explored_nodes": 1,
                            "simplex_iterations": 2751,
                            "explored_time": 14.27,
                            "work_units": 10.01
                        },
                        {
                            "gap": 8.1119,
                            "total_time": 13.22,
                            "explored_nodes": 4834,
                            "simplex_iterations": 59183,
                            "explored_time": 13.2,
                            "work_units": 10.0
                        },
                        {
                            "gap": 23.84,
                            "total_time": 12.52,
                            "explored_nodes": 59,
                            "simplex_iterations": 6341,
                            "explored_time": 12.49,
                            "work_units": 10.02
                        },
                        {
                            "gap": 4.1922,
                            "total_time": 13.59,
                            "explored_nodes": 283930,
                            "simplex_iterations": 1867234,
                            "explored_time": 13.58,
                            "work_units": 10.01
                        },
                        {
                            "gap": 3.4357,
                            "total_time": 12.59,
                            "explored_nodes": 2793,
                            "simplex_iterations": 49865,
                            "explored_time": 12.56,
                            "work_units": 10.01
                        },
                        {
                            "gap": 33.79,
                            "total_time": 13.3,
                            "explored_nodes": 171,
                            "simplex_iterations": 7260,
                            "explored_time": 13.27,
                            "work_units": 11.94
                        },
                        {
                            "gap": 23.2312,
                            "total_time": 12.75,
                            "explored_nodes": 30,
                            "simplex_iterations": 5018,
                            "explored_time": 12.71,
                            "work_units": 10.05
                        }
                    ],
                    "generator": "General",
                    "parents_id": [
                        "fadbcc15-6ad6-48d6-8b82-910d79189cd1"
                    ]
                },
                {
                    "id": "898d4956-0115-4d3e-9257-00562d9c89df",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Combined Depot-Enhanced MTZ Cuts\n    # Integrates absolute position bounds (Parent 1) with depot-lifted subtour constraints (Parent 2).\n    # This strengthens the relaxation by fixing u[i] at boundaries and tightening internal u differences.\n    \n    # 1. Depot-Anchored Lower Bounds: If arc (i, 1) is active, i is the last node -> u[i] = n.\n    #    Otherwise u[i] >= 2 holds naturally.\n    def depot_pos_lb_rule(model, i):\n        if i != 1:\n            return model.u[i] >= 2 + (n - 2) * model.x[i, 1]\n        return pyo.Constraint.Skip\n    model.depot_pos_lb = pyo.Constraint(model.N, rule=depot_pos_lb_rule)\n    \n    # 2. Depot-Anchored Upper Bounds: If arc (1, i) is active, i is the second node -> u[i] = 2.\n    #    Otherwise u[i] <= n holds naturally.\n    def depot_pos_ub_rule(model, i):\n        if i != 1:\n            return model.u[i] <= n - (n - 2) * model.x[1, i]\n        return pyo.Constraint.Skip\n    model.depot_pos_ub = pyo.Constraint(model.N, rule=depot_pos_ub_rule)\n    \n    # 3. Depot-Lifted Desrochers-Laporte Constraints\n    # Tightens the MTZ difference bound u[i] - u[j] for non-depot nodes.\n    # By accounting for depot connections, the RHS is reduced to n-4 when nodes are internal.\n    def depot_lifted_mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return (model.u[i] - model.u[j] + \n                    (n - 3) * model.x[i, j] + \n                    (n - 5) * model.x[j, i] - \n                    model.x[1, j] - model.x[i, 1] <= n - 4)\n        return pyo.Constraint.Skip\n    model.depot_lifted_mtz = pyo.Constraint(model.N, model.N, rule=depot_lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Combined Depot-Enhanced MTZ Cuts\n# Integrates absolute position bounds (Parent 1) with depot-lifted subtour constraints (Parent 2).\n# This strengthens the relaxation by fixing u[i] at boundaries and tightening internal u differences.\n\n# 1. Depot-Anchored Lower Bounds: If arc (i, 1) is active, i is the last node -> u[i] = n.\n#    Otherwise u[i] >= 2 holds naturally.\ndef depot_pos_lb_rule(model, i):\n    if i != 1:\n        return model.u[i] >= 2 + (n - 2) * model.x[i, 1]\n    return pyo.Constraint.Skip\nmodel.depot_pos_lb = pyo.Constraint(model.N, rule=depot_pos_lb_rule)\n\n# 2. Depot-Anchored Upper Bounds: If arc (1, i) is active, i is the second node -> u[i] = 2.\n#    Otherwise u[i] <= n holds naturally.\ndef depot_pos_ub_rule(model, i):\n    if i != 1:\n        return model.u[i] <= n - (n - 2) * model.x[1, i]\n    return pyo.Constraint.Skip\nmodel.depot_pos_ub = pyo.Constraint(model.N, rule=depot_pos_ub_rule)\n\n# 3. Depot-Lifted Desrochers-Laporte Constraints\n# Tightens the MTZ difference bound u[i] - u[j] for non-depot nodes.\n# By accounting for depot connections, the RHS is reduced to n-4 when nodes are internal.\ndef depot_lifted_mtz_rule(model, i, j):\n    if i != j and i != 1 and j != 1:\n        return (model.u[i] - model.u[j] + \n                (n - 3) * model.x[i, j] + \n                (n - 5) * model.x[j, i] - \n                model.x[1, j] - model.x[i, 1] <= n - 4)\n    return pyo.Constraint.Skip\nmodel.depot_lifted_mtz = pyo.Constraint(model.N, model.N, rule=depot_lifted_mtz_rule)",
                        "idea": "I combined Parent 1's highly effective variable bounds with Parent 2's lifted subtour logic to create a Depot-Enhanced MTZ system. The first component explicitly enforces the implications of depot adjacency on the potentials $u_i$ (forcing $u=n$ at the end and $u=2$ at the start), which drastically tightens the domain. The second component utilizes these same depot variables ($x_{i,1}, x_{1,j}$) to lift the Desrochers-Laporte constraint, strengthening the subtour elimination inequality by reducing the RHS from $n-2$ to $n-4$ for paths not directly connected to the depot. This combination strictly dominates the standard MTZ relaxation."
                    },
                    "fitness": 1.2304146438449703,
                    "solver_reports": [
                        {
                            "gap": 20.2511,
                            "total_time": 11.52,
                            "explored_nodes": 1,
                            "simplex_iterations": 960,
                            "explored_time": 11.49,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 12.2,
                            "explored_nodes": 1,
                            "simplex_iterations": 1740,
                            "explored_time": 12.13,
                            "work_units": 10.01
                        },
                        {
                            "gap": 19.7243,
                            "total_time": 10.08,
                            "explored_nodes": 208,
                            "simplex_iterations": 8270,
                            "explored_time": 10.06,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 12.26,
                            "explored_nodes": 1,
                            "simplex_iterations": 1810,
                            "explored_time": 12.14,
                            "work_units": 10.03
                        },
                        {
                            "gap": 11.3388,
                            "total_time": 10.59,
                            "explored_nodes": 5491,
                            "simplex_iterations": 76585,
                            "explored_time": 10.55,
                            "work_units": 10.01
                        },
                        {
                            "gap": 69.2331,
                            "total_time": 11.3,
                            "explored_nodes": 1,
                            "simplex_iterations": 1235,
                            "explored_time": 11.23,
                            "work_units": 10.01
                        },
                        {
                            "gap": 0.0,
                            "total_time": 6.35,
                            "postsolve": 0.02,
                            "explored_nodes": 95838,
                            "simplex_iterations": 642608,
                            "explored_time": 6.34,
                            "work_units": 4.42
                        },
                        {
                            "total_time": 8.63,
                            "explored_nodes": 1,
                            "simplex_iterations": 1272,
                            "explored_time": 8.61,
                            "work_units": 10.0
                        },
                        {
                            "gap": 19.9492,
                            "total_time": 12.34,
                            "explored_nodes": 1,
                            "simplex_iterations": 1095,
                            "explored_time": 12.3,
                            "work_units": 10.01
                        },
                        {
                            "gap": 36.9593,
                            "total_time": 12.41,
                            "explored_nodes": 1,
                            "simplex_iterations": 1540,
                            "explored_time": 12.35,
                            "work_units": 10.01
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "fadbcc15-6ad6-48d6-8b82-910d79189cd1",
                        "edde8a4d-8aff-4a9f-8cc2-6fe807c39516"
                    ]
                },
                {
                    "id": "45a89b06-992f-4e78-8cd4-1ee52a24a558",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Hybrid Subtour Elimination and Bound Tightening\n    # Combines explicit 2-cycle elimination (Parent 1) with Desrochers-Laporte lifting and depot bounds (Parent 2)\n    \n    # 1. Explicit 2-cycle cuts: Directly removes fractional 2-cycles (high impact on relaxation)\n    def sec2_hybrid_rule(m, i, j):\n        if i < j:\n            return m.x[i, j] + m.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2_hybrid = pyo.Constraint(model.N, model.N, rule=sec2_hybrid_rule)\n    \n    # 2. Strengthened Lifted MTZ: Tightens u-variable polytope and links it to arc usage\n    def lifted_mtz_hybrid_rule(m, i, j):\n        if i == j: \n            return pyo.Constraint.Skip\n        \n        # Internal Nodes (i, j != 1): Desrochers-Laporte Lifting\n        # Stronger than standard MTZ; effectively handles subtours among internal nodes\n        if i != 1 and j != 1:\n            return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n            \n        # Depot Outgoing (1 -> j): Sequential Bound Tightening\n        # If arc (1, j) is used, u[j] must be 2. Tightens upper bound.\n        if i == 1:\n            return m.u[j] <= n - (n - 2) * m.x[i, j]\n            \n        # Depot Incoming (i -> 1): Sequential Bound Tightening\n        # If arc (i, 1) is used, u[i] must be n. Tightens lower bound.\n        if j == 1:\n            return m.u[i] >= 2 + (n - 2) * m.x[i, j]\n            \n        return pyo.Constraint.Skip\n    model.lifted_mtz_hybrid = pyo.Constraint(model.N, model.N, rule=lifted_mtz_hybrid_rule)\n\n    return model\n",
                        "added_cut": "# Hybrid Subtour Elimination and Bound Tightening\n# Combines explicit 2-cycle elimination (Parent 1) with Desrochers-Laporte lifting and depot bounds (Parent 2)\n\n# 1. Explicit 2-cycle cuts: Directly removes fractional 2-cycles (high impact on relaxation)\ndef sec2_hybrid_rule(m, i, j):\n    if i < j:\n        return m.x[i, j] + m.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2_hybrid = pyo.Constraint(model.N, model.N, rule=sec2_hybrid_rule)\n\n# 2. Strengthened Lifted MTZ: Tightens u-variable polytope and links it to arc usage\ndef lifted_mtz_hybrid_rule(m, i, j):\n    if i == j: \n        return pyo.Constraint.Skip\n    \n    # Internal Nodes (i, j != 1): Desrochers-Laporte Lifting\n    # Stronger than standard MTZ; effectively handles subtours among internal nodes\n    if i != 1 and j != 1:\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n        \n    # Depot Outgoing (1 -> j): Sequential Bound Tightening\n    # If arc (1, j) is used, u[j] must be 2. Tightens upper bound.\n    if i == 1:\n        return m.u[j] <= n - (n - 2) * m.x[i, j]\n        \n    # Depot Incoming (i -> 1): Sequential Bound Tightening\n    # If arc (i, 1) is used, u[i] must be n. Tightens lower bound.\n    if j == 1:\n        return m.u[i] >= 2 + (n - 2) * m.x[i, j]\n        \n    return pyo.Constraint.Skip\nmodel.lifted_mtz_hybrid = pyo.Constraint(model.N, model.N, rule=lifted_mtz_hybrid_rule)",
                        "idea": "This hybrid formulation synergizes the strengths of both parents: it retains the high-fitness explicit 2-cycle cuts from Parent 1 to aggressively prune fractional loops in the projection of arc variables, while incorporating the sophisticated Desrochers-Laporte lifting and depot-specific variable fixing from Parent 2. The combination enforces tighter bounds on both the assignment ($x$) and ordering ($u$) polytopes simultaneously, ensuring that the relationships implied by the lifted logic are explicitly respected by the arc variables."
                    },
                    "fitness": 10.308265795760455,
                    "solver_reports": [
                        {
                            "gap": 14.1169,
                            "total_time": 11.36,
                            "explored_nodes": 237,
                            "simplex_iterations": 8001,
                            "explored_time": 11.34,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 11.75,
                            "explored_nodes": 1,
                            "simplex_iterations": 2443,
                            "explored_time": 11.64,
                            "work_units": 10.01
                        },
                        {
                            "gap": 11.5218,
                            "total_time": 11.99,
                            "explored_nodes": 233,
                            "simplex_iterations": 9366,
                            "explored_time": 11.97,
                            "work_units": 10.07
                        },
                        {
                            "total_time": 11.35,
                            "explored_nodes": 1,
                            "simplex_iterations": 1701,
                            "explored_time": 11.2,
                            "work_units": 10.03
                        },
                        {
                            "gap": 6.0519,
                            "total_time": 12.17,
                            "explored_nodes": 2936,
                            "simplex_iterations": 61290,
                            "explored_time": 12.14,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.542,
                            "total_time": 12.48,
                            "explored_nodes": 1,
                            "simplex_iterations": 2779,
                            "explored_time": 12.41,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 3.21,
                            "postsolve": 0.0,
                            "explored_nodes": 75199,
                            "simplex_iterations": 494698,
                            "explored_time": 3.2,
                            "work_units": 1.81
                        },
                        {
                            "gap": 2.9309,
                            "total_time": 13.27,
                            "explored_nodes": 1149,
                            "simplex_iterations": 32716,
                            "explored_time": 13.25,
                            "work_units": 10.05
                        },
                        {
                            "gap": 5.865,
                            "total_time": 12.93,
                            "explored_nodes": 1,
                            "simplex_iterations": 2240,
                            "explored_time": 12.88,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 12.74,
                            "explored_nodes": 1,
                            "simplex_iterations": 1977,
                            "explored_time": 12.65,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "af1495e1-5fc4-49ff-a8e4-c09b3c01a782"
                    ]
                },
                {
                    "id": "dac64902-bc73-4360-b06f-a785302741fa",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Combined Cut Strategy: Explicit 2-Cycle Cuts + Desrochers-Laporte Lifting\n    \n    # 1. Explicit 2-cycle elimination (from Parent 1)\n    # Provides strong, sparse binary cuts that help the LP solver quickly prune\n    # fractional 2-cycles, complementing the Big-M constraints.\n    def sec2_cut_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2_cuts = pyo.Constraint(model.N, model.N, rule=sec2_cut_rule)\n    \n    # 2. Desrochers-Laporte (DL) Lifting & Depot Bound Tightening (from Parent 2)\n    # Strengthens the subtour elimination logic by lifting internal constraints\n    # and strictly fixing u-variables based on depot adjacency.\n    def dl_lifting_rule(model, i, j):\n        if i == j:\n            return pyo.Constraint.Skip\n    \n        # Internal Nodes (i, j != 1): Desrochers-Laporte Lifting\n        # Stronger than standard MTZ: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n        if i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n        # Depot Outgoing (1 -> j): Sequential Bound Tightening\n        # If x_1j = 1, force u_j = 2. Logic: u_j + (n-2) <= n\n        if i == 1:\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n    \n        # Depot Incoming (i -> 1): Sequential Bound Tightening\n        # If x_i1 = 1, force u_i = n. Logic: u_i - (n-2) >= 2\n        if j == 1:\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n    \n        return pyo.Constraint.Skip\n    model.enhanced_dl_mtz = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)\n\n    return model\n",
                        "added_cut": "# Combined Cut Strategy: Explicit 2-Cycle Cuts + Desrochers-Laporte Lifting\n\n# 1. Explicit 2-cycle elimination (from Parent 1)\n# Provides strong, sparse binary cuts that help the LP solver quickly prune\n# fractional 2-cycles, complementing the Big-M constraints.\ndef sec2_cut_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2_cuts = pyo.Constraint(model.N, model.N, rule=sec2_cut_rule)\n\n# 2. Desrochers-Laporte (DL) Lifting & Depot Bound Tightening (from Parent 2)\n# Strengthens the subtour elimination logic by lifting internal constraints\n# and strictly fixing u-variables based on depot adjacency.\ndef dl_lifting_rule(model, i, j):\n    if i == j:\n        return pyo.Constraint.Skip\n\n    # Internal Nodes (i, j != 1): Desrochers-Laporte Lifting\n    # Stronger than standard MTZ: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n    if i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\n    # Depot Outgoing (1 -> j): Sequential Bound Tightening\n    # If x_1j = 1, force u_j = 2. Logic: u_j + (n-2) <= n\n    if i == 1:\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n\n    # Depot Incoming (i -> 1): Sequential Bound Tightening\n    # If x_i1 = 1, force u_i = n. Logic: u_i - (n-2) >= 2\n    if j == 1:\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n\n    return pyo.Constraint.Skip\nmodel.enhanced_dl_mtz = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)",
                        "idea": "This enhancement merges the high-performance Desrochers-Laporte (DL) lifting and depot-based variable fixing from Parent 2 with the explicit 2-cycle cuts from Parent 1. Although the DL constraints mathematically imply 2-cycle elimination, adding the explicit binary cuts ($x_{ij} + x_{ji} \\le 1$) assists the solver's pre-solve and cutting plane routines, leading to faster convergence. The formulation strictly bounds the continuous $u$ variables for nodes connected to the depot (forcing $u=2$ or $u=n$) and tightens the Big-M coefficient for internal nodes, providing a significantly tighter approximation of the convex hull than standard MTZ."
                    },
                    "fitness": 8.479603140011015,
                    "solver_reports": [
                        {
                            "gap": 12.6845,
                            "total_time": 12.47,
                            "explored_nodes": 294,
                            "simplex_iterations": 9633,
                            "explored_time": 12.45,
                            "work_units": 10.12
                        },
                        {
                            "total_time": 11.52,
                            "explored_nodes": 1,
                            "simplex_iterations": 2124,
                            "explored_time": 11.41,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.0898,
                            "total_time": 13.2,
                            "explored_nodes": 1,
                            "simplex_iterations": 2285,
                            "explored_time": 13.16,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 11.55,
                            "explored_nodes": 1,
                            "simplex_iterations": 1703,
                            "explored_time": 11.43,
                            "work_units": 10.01
                        },
                        {
                            "gap": 2.9326,
                            "total_time": 15.32,
                            "explored_nodes": 3065,
                            "simplex_iterations": 73844,
                            "explored_time": 15.31,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.99,
                            "explored_nodes": 1,
                            "simplex_iterations": 1750,
                            "explored_time": 11.91,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 6.42,
                            "postsolve": 0.01,
                            "explored_nodes": 128746,
                            "simplex_iterations": 910075,
                            "explored_time": 6.42,
                            "work_units": 3.91
                        },
                        {
                            "gap": 2.927,
                            "total_time": 12.67,
                            "explored_nodes": 1934,
                            "simplex_iterations": 59365,
                            "explored_time": 12.65,
                            "work_units": 10.01
                        },
                        {
                            "gap": 12.4746,
                            "total_time": 12.32,
                            "explored_nodes": 1,
                            "simplex_iterations": 1399,
                            "explored_time": 12.26,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.27,
                            "explored_nodes": 1,
                            "simplex_iterations": 1765,
                            "explored_time": 13.18,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "099c4272-6b64-4d86-889b-c00f7e3852af",
                        "af1495e1-5fc4-49ff-a8e4-c09b3c01a782"
                    ]
                },
                {
                    "id": "fbdeba24-c5a6-4c65-ae60-5c8e5fed047a",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Hybrid Constraint: Desrochers-Laporte with Tighter Anchor Bounds\n    # Merges the structural subtour lifting of Parent 2 with the strict domain bounding of Parent 1.\n    \n    def dl_internal_rule(model, i, j):\n        # From Parent 2: Desrochers-Laporte lifting for internal nodes.\n        # Strengthens MTZ by considering the reverse arc (j, i) in the potential difference.\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    model.dl_internal = pyo.Constraint(model.N, model.N, rule=dl_internal_rule)\n    \n    def anchor_lb_rule(model, i):\n        # From Parent 1: Tighter lower bounds for u[i].\n        # Forces u[i] >= 3 if node i is not directly connected to the depot, anchoring the start of the chain.\n        # Logic: u[i] >= 3 - 1*x[1,i] + (n-3)*x[i,1]\n        if i != 1:\n            return model.u[i] + model.x[1, i] - (n - 3) * model.x[i, 1] >= 3\n        return pyo.Constraint.Skip\n    model.anchor_lb = pyo.Constraint(model.N, rule=anchor_lb_rule)\n    \n    def anchor_ub_rule(model, i):\n        # From Parent 1: Tighter upper bounds for u[i].\n        # Forces u[i] <= n-1 if node i is not directly connected to the depot, anchoring the end of the chain.\n        # Logic: u[i] <= (n-1) + 1*x[i,1] - (n-3)*x[1,i]\n        if i != 1:\n            return model.u[i] - model.x[i, 1] + (n - 3) * model.x[1, i] <= n - 1\n        return pyo.Constraint.Skip\n    model.anchor_ub = pyo.Constraint(model.N, rule=anchor_ub_rule)\n\n    return model\n",
                        "added_cut": "# Hybrid Constraint: Desrochers-Laporte with Tighter Anchor Bounds\n# Merges the structural subtour lifting of Parent 2 with the strict domain bounding of Parent 1.\n\ndef dl_internal_rule(model, i, j):\n    # From Parent 2: Desrochers-Laporte lifting for internal nodes.\n    # Strengthens MTZ by considering the reverse arc (j, i) in the potential difference.\n    if i != j and i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\nmodel.dl_internal = pyo.Constraint(model.N, model.N, rule=dl_internal_rule)\n\ndef anchor_lb_rule(model, i):\n    # From Parent 1: Tighter lower bounds for u[i].\n    # Forces u[i] >= 3 if node i is not directly connected to the depot, anchoring the start of the chain.\n    # Logic: u[i] >= 3 - 1*x[1,i] + (n-3)*x[i,1]\n    if i != 1:\n        return model.u[i] + model.x[1, i] - (n - 3) * model.x[i, 1] >= 3\n    return pyo.Constraint.Skip\nmodel.anchor_lb = pyo.Constraint(model.N, rule=anchor_lb_rule)\n\ndef anchor_ub_rule(model, i):\n    # From Parent 1: Tighter upper bounds for u[i].\n    # Forces u[i] <= n-1 if node i is not directly connected to the depot, anchoring the end of the chain.\n    # Logic: u[i] <= (n-1) + 1*x[i,1] - (n-3)*x[1,i]\n    if i != 1:\n        return model.u[i] - model.x[i, 1] + (n - 3) * model.x[1, i] <= n - 1\n    return pyo.Constraint.Skip\nmodel.anchor_ub = pyo.Constraint(model.N, rule=anchor_ub_rule)",
                        "idea": "This offspring synergizes the high-fitness structural component of Parent 2 (Desrochers-Laporte lifting) with the superior numerical bounds of Parent 1 (Internal Anchoring). While Parent 2's bounds only enforce $u_i \\in [2, n]$, Parent 1's logic correctly identifies that any node *not* connected to the depot must lie strictly in $[3, n-1]$. By constraining the $u$ variables to this tighter interval, the lifted subtour elimination cuts (from Parent 2) become significantly more effective, as the \"floating\" capacity of the auxiliary variables is reduced, forcing the LP relaxation closer to the integer hull."
                    },
                    "fitness": 1.107031472183953,
                    "solver_reports": [
                        {
                            "gap": 13.4132,
                            "total_time": 12.23,
                            "explored_nodes": 199,
                            "simplex_iterations": 8758,
                            "explored_time": 12.2,
                            "work_units": 10.61
                        },
                        {
                            "gap": 6.1487,
                            "total_time": 13.93,
                            "explored_nodes": 1,
                            "simplex_iterations": 1709,
                            "explored_time": 13.84,
                            "work_units": 10.0
                        },
                        {
                            "gap": 9.3985,
                            "total_time": 11.88,
                            "explored_nodes": 901,
                            "simplex_iterations": 21903,
                            "explored_time": 11.86,
                            "work_units": 10.04
                        },
                        {
                            "total_time": 13.72,
                            "explored_nodes": 1,
                            "simplex_iterations": 1733,
                            "explored_time": 13.62,
                            "work_units": 10.01
                        },
                        {
                            "gap": 6.196,
                            "total_time": 11.9,
                            "explored_nodes": 3090,
                            "simplex_iterations": 46523,
                            "explored_time": 11.89,
                            "work_units": 10.0
                        },
                        {
                            "gap": 90.5182,
                            "total_time": 13.41,
                            "explored_nodes": 1,
                            "simplex_iterations": 1398,
                            "explored_time": 13.35,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 3.72,
                            "postsolve": 0.0,
                            "explored_nodes": 58767,
                            "simplex_iterations": 428653,
                            "explored_time": 3.72,
                            "work_units": 2.29
                        },
                        {
                            "gap": 1.741,
                            "total_time": 12.89,
                            "explored_nodes": 2781,
                            "simplex_iterations": 65961,
                            "explored_time": 12.86,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.0497,
                            "total_time": 14.02,
                            "explored_nodes": 1,
                            "simplex_iterations": 2018,
                            "explored_time": 13.97,
                            "work_units": 10.0
                        },
                        {
                            "gap": 87.3874,
                            "total_time": 13.78,
                            "explored_nodes": 1,
                            "simplex_iterations": 1620,
                            "explored_time": 13.71,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "46e59429-4c1f-466a-a42c-b58f5066131e",
                        "7f8c5801-0e91-4e60-bc1b-85e77644b6cb"
                    ]
                },
                {
                    "id": "b52e0a35-2cf0-4c22-94ed-1f407d8fab5c",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Reverse-Lifted MTZ Constraints (Desrochers & Laporte 1991)\n    # While the input cut strengthens absolute node potentials based on the depot,\n    # this cut strengthens the relative potential difference between node pairs\n    # by explicitly accounting for the reverse arc x[j,i].\n    \n    def reverse_lifted_mtz_rule(model, i, j):\n        # Standard MTZ: u[i] - u[j] + n*x[i,j] <= n-1\n        # Lifted:       u[i] - u[j] + (n-1)*x[i,j] + (n-3)*x[j,i] <= n-2\n        # This constraint tightens the relaxed polytope by reducing the Big-M coefficient\n        # and penalizing the simultaneous fractional use of x[i,j] and x[j,i].\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    \n    model.reverse_lifted_mtz = pyo.Constraint(model.N, model.N, rule=reverse_lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Reverse-Lifted MTZ Constraints (Desrochers & Laporte 1991)\n# While the input cut strengthens absolute node potentials based on the depot,\n# this cut strengthens the relative potential difference between node pairs\n# by explicitly accounting for the reverse arc x[j,i].\n\ndef reverse_lifted_mtz_rule(model, i, j):\n    # Standard MTZ: u[i] - u[j] + n*x[i,j] <= n-1\n    # Lifted:       u[i] - u[j] + (n-1)*x[i,j] + (n-3)*x[j,i] <= n-2\n    # This constraint tightens the relaxed polytope by reducing the Big-M coefficient\n    # and penalizing the simultaneous fractional use of x[i,j] and x[j,i].\n    if i != j and i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\n\nmodel.reverse_lifted_mtz = pyo.Constraint(model.N, model.N, rule=reverse_lifted_mtz_rule)",
                        "idea": "While the provided individual tightens the **absolute** bounds of potential variables $u_i$ relative to the depot, this exploratory mutation strengthens the **relative** constraints between arbitrary nodes $i$ and $j$. By implementing the Desrochers & Laporte lifting, the cut incorporates the reverse arc variable $x_{ji}$ into the subtour elimination constraint. This reduces the effective Big-M coefficient from $n$ to $n-1$ (and further compensates with $n-3$ if the reverse arc is active), thereby cutting off fractional solutions containing partial 2-cycles that the standard MTZ and position bounds would otherwise admit."
                    },
                    "fitness": 4.554829604258969,
                    "solver_reports": [
                        {
                            "gap": 11.8089,
                            "total_time": 12.34,
                            "explored_nodes": 495,
                            "simplex_iterations": 10786,
                            "explored_time": 12.32,
                            "work_units": 10.04
                        },
                        {
                            "gap": 11.4825,
                            "total_time": 13.66,
                            "explored_nodes": 1,
                            "simplex_iterations": 2294,
                            "explored_time": 13.59,
                            "work_units": 10.0
                        },
                        {
                            "gap": 12.5166,
                            "total_time": 12.62,
                            "explored_nodes": 201,
                            "simplex_iterations": 8460,
                            "explored_time": 12.6,
                            "work_units": 10.05
                        },
                        {
                            "total_time": 12.19,
                            "explored_nodes": 1,
                            "simplex_iterations": 2125,
                            "explored_time": 12.07,
                            "work_units": 10.01
                        },
                        {
                            "gap": 3.9764,
                            "total_time": 13.04,
                            "explored_nodes": 3851,
                            "simplex_iterations": 48903,
                            "explored_time": 13.01,
                            "work_units": 10.0
                        },
                        {
                            "gap": 33.1642,
                            "total_time": 14.31,
                            "explored_nodes": 1,
                            "simplex_iterations": 1731,
                            "explored_time": 14.24,
                            "work_units": 10.01
                        },
                        {
                            "gap": 3.0372,
                            "total_time": 13.42,
                            "explored_nodes": 683982,
                            "simplex_iterations": 3870269,
                            "explored_time": 13.42,
                            "work_units": 10.01
                        },
                        {
                            "gap": 2.0959,
                            "total_time": 13.89,
                            "explored_nodes": 2784,
                            "simplex_iterations": 58202,
                            "explored_time": 13.85,
                            "work_units": 10.0
                        },
                        {
                            "gap": 27.8274,
                            "total_time": 11.49,
                            "explored_nodes": 59,
                            "simplex_iterations": 3310,
                            "explored_time": 11.45,
                            "work_units": 10.47
                        },
                        {
                            "gap": 22.5364,
                            "total_time": 13.65,
                            "explored_nodes": 1,
                            "simplex_iterations": 1633,
                            "explored_time": 13.6,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Exploratory",
                    "parents_id": [
                        "46e59429-4c1f-466a-a42c-b58f5066131e"
                    ]
                },
                {
                    "id": "6ade1488-2e92-4e98-b6fb-75db5ba8e0c0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Depot-Inferred Position Bounds\n    # Complements the input's 'connected' logic by tightening bounds for 'disconnected' cases.\n    # These cuts prune the LP relaxation by enforcing that nodes NOT connected to the depot\n    # must reside strictly in the interior of the tour sequence (indices 3 to n-1).\n    \n    def depot_lb_rule(model, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        # If i is not the first node after depot (x[1,i]=0), it must be at least 3rd in tour.\n        # Logic: x[1,i]=0 => u[i] >= 3. (If x[1,i]=1, u[i] >= 2 holds trivially)\n        return model.u[i] >= 3 - model.x[1, i]\n    \n    model.depot_lb_cuts = pyo.Constraint(model.N, rule=depot_lb_rule)\n    \n    def depot_ub_rule(model, i):\n        if i == 1:\n            return pyo.Constraint.Skip\n        # If i is not the last node before depot (x[i,1]=0), it must be at most (n-1)-th.\n        # Logic: x[i,1]=0 => u[i] <= n-1. (If x[i,1]=1, u[i] <= n holds trivially)\n        return model.u[i] <= (n - 1) + model.x[i, 1]\n    \n    model.depot_ub_cuts = pyo.Constraint(model.N, rule=depot_ub_rule)\n\n    return model\n",
                        "added_cut": "# Depot-Inferred Position Bounds\n# Complements the input's 'connected' logic by tightening bounds for 'disconnected' cases.\n# These cuts prune the LP relaxation by enforcing that nodes NOT connected to the depot\n# must reside strictly in the interior of the tour sequence (indices 3 to n-1).\n\ndef depot_lb_rule(model, i):\n    if i == 1:\n        return pyo.Constraint.Skip\n    # If i is not the first node after depot (x[1,i]=0), it must be at least 3rd in tour.\n    # Logic: x[1,i]=0 => u[i] >= 3. (If x[1,i]=1, u[i] >= 2 holds trivially)\n    return model.u[i] >= 3 - model.x[1, i]\n\nmodel.depot_lb_cuts = pyo.Constraint(model.N, rule=depot_lb_rule)\n\ndef depot_ub_rule(model, i):\n    if i == 1:\n        return pyo.Constraint.Skip\n    # If i is not the last node before depot (x[i,1]=0), it must be at most (n-1)-th.\n    # Logic: x[i,1]=0 => u[i] <= n-1. (If x[i,1]=1, u[i] <= n holds trivially)\n    return model.u[i] <= (n - 1) + model.x[i, 1]\n\nmodel.depot_ub_cuts = pyo.Constraint(model.N, rule=depot_ub_rule)",
                        "idea": "This mutation introduces 'Depot-Inferred Position Bounds', acting as the logical complement to the input's constraints. While the input tightens variables when arcs *connect* to the depot (forcing $u=2$ or $u=n$), this exploratory cut tightens the domain when arcs do *not* connect. Specifically, it enforces that any node $i$ not immediately succeeding the depot must have a position $u_i \\ge 3$, and any node not immediately preceding the depot must have $u_i \\le n-1$. This effectively partitions the continuous relaxation space for $u$ variables, eliminating fractional solutions where nodes 'hover' near the start or end of the tour without direct depot connectivity."
                    },
                    "fitness": 4.97969605589386,
                    "solver_reports": [
                        {
                            "gap": 9.7803,
                            "total_time": 13.5,
                            "explored_nodes": 3719,
                            "simplex_iterations": 58016,
                            "explored_time": 13.46,
                            "work_units": 10.0
                        },
                        {
                            "gap": 46.1022,
                            "total_time": 12.24,
                            "explored_nodes": 1,
                            "simplex_iterations": 6358,
                            "explored_time": 12.2,
                            "work_units": 10.0
                        },
                        {
                            "gap": 21.3155,
                            "total_time": 12.47,
                            "explored_nodes": 563,
                            "simplex_iterations": 18783,
                            "explored_time": 12.45,
                            "work_units": 11.05
                        },
                        {
                            "gap": 45.3316,
                            "total_time": 14.91,
                            "explored_nodes": 1,
                            "simplex_iterations": 3380,
                            "explored_time": 14.85,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1116,
                            "total_time": 11.28,
                            "explored_nodes": 2835,
                            "simplex_iterations": 62062,
                            "explored_time": 11.25,
                            "work_units": 10.01
                        },
                        {
                            "gap": 28.1667,
                            "total_time": 13.29,
                            "explored_nodes": 114,
                            "simplex_iterations": 9461,
                            "explored_time": 13.26,
                            "work_units": 10.11
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.28,
                            "explored_nodes": 291399,
                            "simplex_iterations": 1867312,
                            "explored_time": 13.28,
                            "work_units": 10.04
                        },
                        {
                            "gap": 7.8072,
                            "total_time": 11.1,
                            "explored_nodes": 4408,
                            "simplex_iterations": 67802,
                            "explored_time": 11.07,
                            "work_units": 10.0
                        },
                        {
                            "gap": 21.5371,
                            "total_time": 12.67,
                            "explored_nodes": 59,
                            "simplex_iterations": 5897,
                            "explored_time": 12.65,
                            "work_units": 11.14
                        },
                        {
                            "gap": 5.387,
                            "total_time": 14.03,
                            "explored_nodes": 87,
                            "simplex_iterations": 8137,
                            "explored_time": 14.0,
                            "work_units": 12.18
                        }
                    ],
                    "generator": "Exploratory",
                    "parents_id": [
                        "af1495e1-5fc4-49ff-a8e4-c09b3c01a782"
                    ]
                }
            ],
            10.353038952236112
        ],
        [
            [
                {
                    "id": "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Explicit 2-cycle subtour elimination constraints\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n    return model\n",
                        "added_cut": "# Explicit 2-cycle subtour elimination constraints\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2 = pyo.Constraint(model.N, model.N, rule=sec2_rule)",
                        "idea": "The standard MTZ constraints are known to be weak in preventing small subtours in the linear relaxation. Specifically, for a pair of nodes $i, j$, the MTZ inequalities sum to imply $x_{i,j} + x_{j,i} \\le 2(n-1)/n$, which approaches 2 for large $n$, allowing fractional solutions like $x_{i,j}=x_{j,i}=0.9$. This proposed constraint explicitly enforces $x_{i,j} + x_{j,i} \\le 1$, cutting these fractional 2-cycle solutions that satisfy the loose MTZ bounds but violate the TSP tour structure."
                    },
                    "fitness": 10.353038952236112,
                    "solver_reports": [
                        {
                            "gap": 8.2936,
                            "total_time": 12.77,
                            "explored_nodes": 4846,
                            "simplex_iterations": 70258,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.4564,
                            "total_time": 13.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 5680,
                            "explored_time": 13.92,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.8624,
                            "total_time": 12.83,
                            "explored_nodes": 3682,
                            "simplex_iterations": 59897,
                            "explored_time": 12.82,
                            "work_units": 10.05
                        },
                        {
                            "gap": 39.0758,
                            "total_time": 14.69,
                            "explored_nodes": 1,
                            "simplex_iterations": 3320,
                            "explored_time": 14.61,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.3333,
                            "total_time": 12.44,
                            "explored_nodes": 10336,
                            "simplex_iterations": 265363,
                            "explored_time": 12.43,
                            "work_units": 10.02
                        },
                        {
                            "gap": 15.1534,
                            "total_time": 12.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 3358,
                            "explored_time": 12.41,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.2,
                            "explored_nodes": 334422,
                            "simplex_iterations": 2168198,
                            "explored_time": 13.19,
                            "work_units": 10.01
                        },
                        {
                            "gap": 1.7433,
                            "total_time": 14.01,
                            "explored_nodes": 2951,
                            "simplex_iterations": 75993,
                            "explored_time": 13.99,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.8644,
                            "total_time": 12.52,
                            "explored_nodes": 87,
                            "simplex_iterations": 6767,
                            "explored_time": 12.47,
                            "work_units": 10.97
                        },
                        {
                            "gap": 10.6883,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 4050,
                            "explored_time": 14.11,
                            "work_units": 10.0
                        }
                    ],
                    "generator": null,
                    "parents_id": null
                },
                {
                    "id": "c55b6986-6d93-4c28-88f0-28ee947dc873",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Hybrid Cut Strategy: SEC2 + Simplified Lifted MTZ + Depot Fixing\n    \n    # 1. Explicit 2-Cycle Cuts (from Parent 1)\n    # Retains the high-fitness component: explicit binary cuts x_ij + x_ji <= 1.\n    # These are sparse and effectively prune fractional 2-cycle solutions\n    # that the weak MTZ constraints often permit.\n    def sec2_hybrid_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2_hybrid = pyo.Constraint(model.N, model.N, rule=sec2_hybrid_rule)\n    \n    # 2. Lifted MTZ & Depot Bounding (Refined from Parent 2)\n    # Adopts the numerical tightening logic from Parent 2 but simplifies the \n    # internal node constraint to reduce density while maintaining tighter bounds.\n    def lifted_mtz_depot_rule(model, i, j):\n        # Internal Arcs (i, j != 1): Simplified Lifting\n        # Use coefficient (n-1) instead of n, and RHS (n-2) instead of (n-1).\n        # Constraint: u_i - u_j + (n-1)x_ij <= n-2\n        # This is strictly tighter than the base model's MTZ constraint.\n        if i != 1 and j != 1 and i != j:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] <= n - 2\n        \n        # Depot Outgoing (1 -> j): Variable Upper Bound\n        # If x_1j = 1, forces u_j <= 2 (so u_j=2). Otherwise u_j <= n.\n        if i == 1 and j != 1:\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n            \n        # Depot Incoming (i -> 1): Variable Lower Bound\n        # If x_i1 = 1, forces u_i >= n (so u_i=n). Otherwise u_i >= 2.\n        if j == 1 and i != 1:\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n            \n        return pyo.Constraint.Skip\n    model.lifted_mtz_depot = pyo.Constraint(model.N, model.N, rule=lifted_mtz_depot_rule)\n\n    return model\n",
                        "added_cut": "# Hybrid Cut Strategy: SEC2 + Simplified Lifted MTZ + Depot Fixing\n\n# 1. Explicit 2-Cycle Cuts (from Parent 1)\n# Retains the high-fitness component: explicit binary cuts x_ij + x_ji <= 1.\n# These are sparse and effectively prune fractional 2-cycle solutions\n# that the weak MTZ constraints often permit.\ndef sec2_hybrid_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2_hybrid = pyo.Constraint(model.N, model.N, rule=sec2_hybrid_rule)\n\n# 2. Lifted MTZ & Depot Bounding (Refined from Parent 2)\n# Adopts the numerical tightening logic from Parent 2 but simplifies the \n# internal node constraint to reduce density while maintaining tighter bounds.\ndef lifted_mtz_depot_rule(model, i, j):\n    # Internal Arcs (i, j != 1): Simplified Lifting\n    # Use coefficient (n-1) instead of n, and RHS (n-2) instead of (n-1).\n    # Constraint: u_i - u_j + (n-1)x_ij <= n-2\n    # This is strictly tighter than the base model's MTZ constraint.\n    if i != 1 and j != 1 and i != j:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] <= n - 2\n    \n    # Depot Outgoing (1 -> j): Variable Upper Bound\n    # If x_1j = 1, forces u_j <= 2 (so u_j=2). Otherwise u_j <= n.\n    if i == 1 and j != 1:\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n        \n    # Depot Incoming (i -> 1): Variable Lower Bound\n    # If x_i1 = 1, forces u_i >= n (so u_i=n). Otherwise u_i >= 2.\n    if j == 1 and i != 1:\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n        \n    return pyo.Constraint.Skip\nmodel.lifted_mtz_depot = pyo.Constraint(model.N, model.N, rule=lifted_mtz_depot_rule)",
                        "idea": "This hybrid formulation combines the structural efficiency of Parent 1's explicit 2-cycle cuts with the numerical tightening of Parent 2. It retains the 'sec2' cuts for their proven effectiveness in pruning binary fractional cycles. From Parent 2, it extracts the depot-based variable fixing (tightening the bounds on u for nodes connected to the depot) and implements a 'Simplified Lifted MTZ' inequality (u_i - u_j + (n-1)x_ij <= n-2). This specific internal constraint is strictly tighter than the standard MTZ found in the base modelforcing x_ij to zero when the u gap is maximalwithout the computational overhead of the full Desrochers-Laporte lifting."
                    },
                    "fitness": 7.637418408131694,
                    "solver_reports": [
                        {
                            "gap": 14.8045,
                            "total_time": 12.75,
                            "explored_nodes": 8382,
                            "simplex_iterations": 89448,
                            "explored_time": 12.73,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 12.96,
                            "explored_nodes": 1,
                            "simplex_iterations": 5124,
                            "explored_time": 12.89,
                            "work_units": 10.01
                        },
                        {
                            "gap": 8.5014,
                            "total_time": 13.49,
                            "explored_nodes": 171,
                            "simplex_iterations": 10029,
                            "explored_time": 13.46,
                            "work_units": 11.0
                        },
                        {
                            "gap": 44.5405,
                            "total_time": 14.33,
                            "explored_nodes": 1,
                            "simplex_iterations": 2587,
                            "explored_time": 14.23,
                            "work_units": 10.01
                        },
                        {
                            "gap": 2.651,
                            "total_time": 13.72,
                            "explored_nodes": 5906,
                            "simplex_iterations": 116273,
                            "explored_time": 13.7,
                            "work_units": 10.01
                        },
                        {
                            "gap": 16.0786,
                            "total_time": 14.23,
                            "explored_nodes": 3,
                            "simplex_iterations": 3458,
                            "explored_time": 14.14,
                            "work_units": 10.02
                        },
                        {
                            "gap": 3.7787,
                            "total_time": 14.3,
                            "explored_nodes": 298266,
                            "simplex_iterations": 2100910,
                            "explored_time": 14.3,
                            "work_units": 10.04
                        },
                        {
                            "gap": 2.0682,
                            "total_time": 12.2,
                            "explored_nodes": 2891,
                            "simplex_iterations": 84767,
                            "explored_time": 12.16,
                            "work_units": 10.0
                        },
                        {
                            "gap": 23.6488,
                            "total_time": 12.12,
                            "explored_nodes": 31,
                            "simplex_iterations": 4397,
                            "explored_time": 12.08,
                            "work_units": 10.02
                        },
                        {
                            "gap": 9.8208,
                            "total_time": 14.28,
                            "explored_nodes": 1,
                            "simplex_iterations": 4274,
                            "explored_time": 14.21,
                            "work_units": 10.01
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "dac64902-bc73-4360-b06f-a785302741fa"
                    ]
                },
                {
                    "id": "eaca0dd7-2a60-481e-b2c0-6ac7774e6761",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Lifted MTZ Subtour Elimination (Hybrid Constraint)\n    # This constraint hybridizes Parent 1's 2-cycle elimination logic (handling reverse arcs x[j,i])\n    # with Parent 2's position-variable bounding structure (constraining u[i]).\n    # It implements the Desrochers & Laporte lifting, which strengthens the MTZ formulation\n    # by explicitly penalizing the reverse arc x[j,i] within the potential difference inequality.\n    \n    def lifted_mtz_rule(model, i, j):\n        # Apply only to non-depot nodes, similar to standard MTZ\n        if i != j and i != 1 and j != 1:\n            # Standard MTZ: u_i - u_j + n*x_ij <= n-1\n            # Hybrid Lifted: u_i - u_j + (n-1)*x_ij + (n-3)*x_ji <= n-2\n            # This tightens the feasible region for u by using the reverse arc (Parent 1's insight)\n            # and effectively precludes 2-cycles (x_ij + x_ji <= 1) in the relaxation.\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    \n    model.lifted_mtz_cuts = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "# Lifted MTZ Subtour Elimination (Hybrid Constraint)\n# This constraint hybridizes Parent 1's 2-cycle elimination logic (handling reverse arcs x[j,i])\n# with Parent 2's position-variable bounding structure (constraining u[i]).\n# It implements the Desrochers & Laporte lifting, which strengthens the MTZ formulation\n# by explicitly penalizing the reverse arc x[j,i] within the potential difference inequality.\n\ndef lifted_mtz_rule(model, i, j):\n    # Apply only to non-depot nodes, similar to standard MTZ\n    if i != j and i != 1 and j != 1:\n        # Standard MTZ: u_i - u_j + n*x_ij <= n-1\n        # Hybrid Lifted: u_i - u_j + (n-1)*x_ij + (n-3)*x_ji <= n-2\n        # This tightens the feasible region for u by using the reverse arc (Parent 1's insight)\n        # and effectively precludes 2-cycles (x_ij + x_ji <= 1) in the relaxation.\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\n\nmodel.lifted_mtz_cuts = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)",
                        "idea": "This hybrid constraint synthesizes the structural logic of Parent 2 (manipulating continuous position variables u) with the cycle-prevention condition of Parent 1 (penalizing 2-cycles involving x_ji). By incorporating the reverse arc term (n-3)x_ji into the MTZ difference inequality, the constraint tightens the linear relaxation significantly toward the convex hull. It strictly dominates standard MTZ constraints and implicitly enforces the 2-cycle elimination (x_ij + x_ji <= 1) without requiring separate binary cuts."
                    },
                    "fitness": 0.6273693525982429,
                    "solver_reports": [
                        {
                            "gap": 9.6258,
                            "total_time": 11.03,
                            "explored_nodes": 897,
                            "simplex_iterations": 15442,
                            "explored_time": 11.01,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.56,
                            "explored_nodes": 1,
                            "simplex_iterations": 2400,
                            "explored_time": 13.48,
                            "work_units": 10.0
                        },
                        {
                            "gap": 16.885,
                            "total_time": 13.05,
                            "explored_nodes": 171,
                            "simplex_iterations": 5745,
                            "explored_time": 13.03,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.65,
                            "explored_nodes": 1,
                            "simplex_iterations": 2112,
                            "explored_time": 11.56,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.3936,
                            "total_time": 12.35,
                            "explored_nodes": 6127,
                            "simplex_iterations": 60762,
                            "explored_time": 12.33,
                            "work_units": 10.01
                        },
                        {
                            "gap": 80.5648,
                            "total_time": 12.68,
                            "explored_nodes": 1,
                            "simplex_iterations": 2034,
                            "explored_time": 12.62,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1352,
                            "total_time": 15.03,
                            "explored_nodes": 388467,
                            "simplex_iterations": 2398130,
                            "explored_time": 15.03,
                            "work_units": 10.01
                        },
                        {
                            "gap": 9.4208,
                            "total_time": 10.86,
                            "explored_nodes": 686,
                            "simplex_iterations": 22175,
                            "explored_time": 10.84,
                            "work_units": 10.23
                        },
                        {
                            "gap": 71.1813,
                            "total_time": 11.58,
                            "explored_nodes": 59,
                            "simplex_iterations": 2936,
                            "explored_time": 11.55,
                            "work_units": 10.2
                        },
                        {
                            "gap": 38.625,
                            "total_time": 13.25,
                            "explored_nodes": 1,
                            "simplex_iterations": 3723,
                            "explored_time": 13.2,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "6ade1488-2e92-4e98-b6fb-75db5ba8e0c0"
                    ]
                },
                {
                    "id": "73a2a9f6-2bbe-4b0d-9b3a-c361b506d8a2",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Flow-Based Subtour Elimination (Gavish-Graves Strengthening)\n    # Adds auxiliary flow variables 'f' to impose structural connectivity constraints.\n    # Complements Parent 1 (Potential-based) and Parent 2 (Bound-based) by ensuring\n    # that every active arc supports a valid flow of 'demand' from the depot to all nodes.\n    \n    # Auxiliary variable f[i,j]: represents the flow of 'remaining nodes to visit' along arc (i,j)\n    model.f = pyo.Var(model.A, domain=pyo.NonNegativeReals)\n    \n    def flow_capacity_rule(m, i, j):\n        # Capacity Constraint: Flow is zero if arc is not used.\n        # Max flow is n-1 (at the depot start).\n        return m.f[i, j] <= (n - 1) * m.x[i, j]\n    model.flow_capacity = pyo.Constraint(model.A, rule=flow_capacity_rule)\n    \n    def flow_conservation_rule(m, k):\n        # Conservation Constraint: Inflow - Outflow = Demand.\n        # Depot (1) is the source; all other nodes k consume 1 unit.\n        if k == 1:\n            return pyo.Constraint.Skip\n        \n        inflow = sum(m.f[i, k] for i in m.N if i != k)\n        outflow = sum(m.f[k, j] for j in m.N if j != k)\n        \n        # Net flow accumulation at node k must be 1\n        return inflow - outflow == 1\n    model.flow_conservation = pyo.Constraint(model.N, rule=flow_conservation_rule)\n\n    return model\n",
                        "added_cut": "# Flow-Based Subtour Elimination (Gavish-Graves Strengthening)\n# Adds auxiliary flow variables 'f' to impose structural connectivity constraints.\n# Complements Parent 1 (Potential-based) and Parent 2 (Bound-based) by ensuring\n# that every active arc supports a valid flow of 'demand' from the depot to all nodes.\n\n# Auxiliary variable f[i,j]: represents the flow of 'remaining nodes to visit' along arc (i,j)\nmodel.f = pyo.Var(model.A, domain=pyo.NonNegativeReals)\n\ndef flow_capacity_rule(m, i, j):\n    # Capacity Constraint: Flow is zero if arc is not used.\n    # Max flow is n-1 (at the depot start).\n    return m.f[i, j] <= (n - 1) * m.x[i, j]\nmodel.flow_capacity = pyo.Constraint(model.A, rule=flow_capacity_rule)\n\ndef flow_conservation_rule(m, k):\n    # Conservation Constraint: Inflow - Outflow = Demand.\n    # Depot (1) is the source; all other nodes k consume 1 unit.\n    if k == 1:\n        return pyo.Constraint.Skip\n    \n    inflow = sum(m.f[i, k] for i in m.N if i != k)\n    outflow = sum(m.f[k, j] for j in m.N if j != k)\n    \n    # Net flow accumulation at node k must be 1\n    return inflow - outflow == 1\nmodel.flow_conservation = pyo.Constraint(model.N, rule=flow_conservation_rule)",
                        "idea": "This strategy superimposes the **Gavish-Graves (GG) single-commodity flow formulation** onto the existing MTZ structure. While Parent 1 focuses on tightening **potential differences** (via DL lifting) and Parent 2 focuses on tightening **potential bounds** (via depot adjacency), this offspring introduces auxiliary **flow variables** to enforce physical connectivity. By requiring the network to support a valid flow where each node consumes 1 unit supplied by the depot, this formulation creates a **structurally orthogonal** strengthening. It effectively prunes fractional subtours that might satisfy weak Big-M potential constraints but are capacity-infeasible, significantly tightening the convex hull."
                    },
                    "fitness": 0.38984022213021824,
                    "solver_reports": [
                        {
                            "gap": 7.3631,
                            "total_time": 12.41,
                            "explored_nodes": 1,
                            "simplex_iterations": 30144,
                            "explored_time": 12.33,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 10.36,
                            "explored_nodes": 1,
                            "simplex_iterations": 17152,
                            "explored_time": 10.26,
                            "work_units": 10.01
                        },
                        {
                            "gap": 30.1607,
                            "total_time": 11.35,
                            "explored_nodes": 1,
                            "simplex_iterations": 20684,
                            "explored_time": 11.31,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 11.07,
                            "explored_nodes": 1,
                            "simplex_iterations": 20602,
                            "explored_time": 10.96,
                            "work_units": 10.02
                        },
                        {
                            "gap": 0.0,
                            "total_time": 10.8,
                            "postsolve": 0.08,
                            "explored_nodes": 1,
                            "simplex_iterations": 39933,
                            "explored_time": 10.78,
                            "work_units": 7.37
                        },
                        {
                            "total_time": 9.19,
                            "explored_nodes": 1,
                            "simplex_iterations": 13650,
                            "explored_time": 9.12,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 0.35,
                            "postsolve": 0.01,
                            "explored_nodes": 1,
                            "simplex_iterations": 1099,
                            "explored_time": 0.34,
                            "work_units": 0.13
                        },
                        {
                            "gap": 7.5247,
                            "total_time": 10.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 19725,
                            "explored_time": 10.42,
                            "work_units": 10.0
                        },
                        {
                            "gap": 23.7201,
                            "total_time": 11.83,
                            "explored_nodes": 1,
                            "simplex_iterations": 13735,
                            "explored_time": 11.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 88.1276,
                            "total_time": 9.98,
                            "explored_nodes": 1,
                            "simplex_iterations": 17831,
                            "explored_time": 9.9,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "dac64902-bc73-4360-b06f-a785302741fa",
                        "6ade1488-2e92-4e98-b6fb-75db5ba8e0c0"
                    ]
                },
                {
                    "id": "3a0514a7-d9b5-4230-8054-2d35bda348ab",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Mutated Strategy: DL Lifting + Explicit 2-Cycle + Conditional Domain Tightening\n    \n    # 1. Explicit 2-cycle elimination\n    # Retained from individual: Provides sparse, strong cuts for LP relaxation.\n    def sec2_cut_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2_cuts = pyo.Constraint(model.N, model.N, rule=sec2_cut_rule)\n    \n    # 2. Desrochers-Laporte (DL) Lifting & Depot Fixing\n    # Retained: Strengthens subtour elimination and fixes u when connected to depot.\n    def dl_lifting_rule(model, i, j):\n        if i == j: return pyo.Constraint.Skip\n        \n        # Internal Nodes (i, j != 1): Lifted MTZ constraint\n        if i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n        # Depot Outgoing (1 -> j): If x_1j=1, force u_j=2\n        if i == 1:\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n    \n        # Depot Incoming (i -> 1): If x_i1=1, force u_i=n\n        if j == 1:\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n    \n        return pyo.Constraint.Skip\n    model.enhanced_dl_mtz = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)\n    \n    # 3. Conditional Depot Bounds (Added Mutation)\n    # Enhances the strategy by tightening u-bounds for nodes NOT connected to the depot.\n    # Complements the fixing constraints above to partition the domain of u.\n    \n    # Lower Bound Tightening: If node i is NOT the first visited (x_1i=0), u_i must be >= 3.\n    # Logic: u_i >= 2 + (1 - x_1i) => u_i >= 3 - x_1i\n    def depot_lb_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        return model.u[i] >= 3 - model.x[1, i]\n    model.depot_conditional_lb = pyo.Constraint(model.N, rule=depot_lb_rule)\n    \n    # Upper Bound Tightening: If node i is NOT the last visited (x_i1=0), u_i must be <= n-1.\n    # Logic: u_i <= n - (1 - x_i1) => u_i <= n - 1 + x_i1\n    def depot_ub_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        return model.u[i] <= (n - 1) + model.x[i, 1]\n    model.depot_conditional_ub = pyo.Constraint(model.N, rule=depot_ub_rule)\n\n    return model\n",
                        "added_cut": "# Mutated Strategy: DL Lifting + Explicit 2-Cycle + Conditional Domain Tightening\n\n# 1. Explicit 2-cycle elimination\n# Retained from individual: Provides sparse, strong cuts for LP relaxation.\ndef sec2_cut_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2_cuts = pyo.Constraint(model.N, model.N, rule=sec2_cut_rule)\n\n# 2. Desrochers-Laporte (DL) Lifting & Depot Fixing\n# Retained: Strengthens subtour elimination and fixes u when connected to depot.\ndef dl_lifting_rule(model, i, j):\n    if i == j: return pyo.Constraint.Skip\n    \n    # Internal Nodes (i, j != 1): Lifted MTZ constraint\n    if i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\n    # Depot Outgoing (1 -> j): If x_1j=1, force u_j=2\n    if i == 1:\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n\n    # Depot Incoming (i -> 1): If x_i1=1, force u_i=n\n    if j == 1:\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n\n    return pyo.Constraint.Skip\nmodel.enhanced_dl_mtz = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)\n\n# 3. Conditional Depot Bounds (Added Mutation)\n# Enhances the strategy by tightening u-bounds for nodes NOT connected to the depot.\n# Complements the fixing constraints above to partition the domain of u.\n\n# Lower Bound Tightening: If node i is NOT the first visited (x_1i=0), u_i must be >= 3.\n# Logic: u_i >= 2 + (1 - x_1i) => u_i >= 3 - x_1i\ndef depot_lb_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    return model.u[i] >= 3 - model.x[1, i]\nmodel.depot_conditional_lb = pyo.Constraint(model.N, rule=depot_lb_rule)\n\n# Upper Bound Tightening: If node i is NOT the last visited (x_i1=0), u_i must be <= n-1.\n# Logic: u_i <= n - (1 - x_i1) => u_i <= n - 1 + x_i1\ndef depot_ub_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    return model.u[i] <= (n - 1) + model.x[i, 1]\nmodel.depot_conditional_ub = pyo.Constraint(model.N, rule=depot_ub_rule)",
                        "idea": "This mutation augments the Desrochers-Laporte and 2-cycle strategy with Conditional Domain Tightening. While the original cuts fixed u[i] to 2 or n when connected to the depot, the new constraints strictly tighten the bounds for the 'unconnected' case (forcing u[i] into [3, n-1] when x[1,i]=0 or x[i,1]=0). This strictly partitions the continuous domain of u based on depot adjacency, significantly tightening the LP relaxation and strengthening the Big-M implications for all internal DL constraints."
                    },
                    "fitness": 12.559533054020575,
                    "solver_reports": [
                        {
                            "gap": 9.983,
                            "total_time": 14.25,
                            "explored_nodes": 1,
                            "simplex_iterations": 2480,
                            "explored_time": 14.21,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 11.61,
                            "explored_nodes": 1,
                            "simplex_iterations": 2767,
                            "explored_time": 11.53,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.5723,
                            "total_time": 12.08,
                            "explored_nodes": 369,
                            "simplex_iterations": 10792,
                            "explored_time": 12.06,
                            "work_units": 10.06
                        },
                        {
                            "total_time": 12.46,
                            "explored_nodes": 1,
                            "simplex_iterations": 1950,
                            "explored_time": 12.34,
                            "work_units": 10.0
                        },
                        {
                            "gap": 1.1852,
                            "total_time": 14.17,
                            "explored_nodes": 10783,
                            "simplex_iterations": 287126,
                            "explored_time": 14.16,
                            "work_units": 10.02
                        },
                        {
                            "gap": 17.5923,
                            "total_time": 12.82,
                            "explored_nodes": 1,
                            "simplex_iterations": 1661,
                            "explored_time": 12.73,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 2.88,
                            "postsolve": 0.0,
                            "explored_nodes": 42403,
                            "simplex_iterations": 292937,
                            "explored_time": 2.88,
                            "work_units": 1.53
                        },
                        {
                            "gap": 1.9875,
                            "total_time": 14.65,
                            "explored_nodes": 2958,
                            "simplex_iterations": 57432,
                            "explored_time": 14.61,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.2986,
                            "total_time": 12.42,
                            "explored_nodes": 1,
                            "simplex_iterations": 1777,
                            "explored_time": 12.37,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 13.63,
                            "explored_nodes": 1,
                            "simplex_iterations": 2314,
                            "explored_time": 13.56,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "General",
                    "parents_id": [
                        "dac64902-bc73-4360-b06f-a785302741fa"
                    ]
                },
                {
                    "id": "436986dd-d10e-4af7-8cc0-01370d657a43",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Combined Cut Strategy: SEC2 + Desrochers-Laporte (DL) + Global Rank Sum\n    \n    # 1. Explicit 2-Cycle Elimination (From Parent 1)\n    # Provides sparse, strong binary cuts that assist the solver's pre-solve\n    # in pruning fractional 2-cycles (x_ij = x_ji = 0.5).\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2_cuts = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n    \n    # 2. Desrochers-Laporte Lifting & Depot Bounds (From Parent 2)\n    # Lifts the standard MTZ constraints to approximate the convex hull more tightly\n    # by including the reverse arc term and fixing u-vars based on depot connectivity.\n    def dl_lifting_rule(model, i, j):\n        if i == j:\n            return pyo.Constraint.Skip\n    \n        # Internal Nodes (i, j != 1): DL Inequality\n        # u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n        if i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n        # Depot Outgoing (1 -> j): If x_1j=1, then u_j=2. (Relaxed: u_j + (n-2)x_1j <= n)\n        if i == 1:\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n    \n        # Depot Incoming (i -> 1): If x_i1=1, then u_i=n. (Relaxed: u_i - (n-2)x_i1 >= 2)\n        if j == 1:\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n    \n        return pyo.Constraint.Skip\n    model.dl_constraints = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)\n    \n    # 3. Global Rank Sum Invariant (New Enhancement)\n    # Forces the sum of non-depot position variables to equal the exact sum of the sequence 2..n.\n    # This cuts relaxations where the average position value drifts from the valid permutation.\n    def rank_sum_rule(model):\n        # Sum of integers 2..n is (n(n+1)/2) - 1\n        target_sum = (n * (n + 1)) // 2 - 1\n        return sum(model.u[i] for i in model.N if i != 1) == target_sum\n    model.rank_sum_constraint = pyo.Constraint(rule=rank_sum_rule)\n\n    return model\n",
                        "added_cut": "# Combined Cut Strategy: SEC2 + Desrochers-Laporte (DL) + Global Rank Sum\n\n# 1. Explicit 2-Cycle Elimination (From Parent 1)\n# Provides sparse, strong binary cuts that assist the solver's pre-solve\n# in pruning fractional 2-cycles (x_ij = x_ji = 0.5).\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2_cuts = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n# 2. Desrochers-Laporte Lifting & Depot Bounds (From Parent 2)\n# Lifts the standard MTZ constraints to approximate the convex hull more tightly\n# by including the reverse arc term and fixing u-vars based on depot connectivity.\ndef dl_lifting_rule(model, i, j):\n    if i == j:\n        return pyo.Constraint.Skip\n\n    # Internal Nodes (i, j != 1): DL Inequality\n    # u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n    if i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\n    # Depot Outgoing (1 -> j): If x_1j=1, then u_j=2. (Relaxed: u_j + (n-2)x_1j <= n)\n    if i == 1:\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n\n    # Depot Incoming (i -> 1): If x_i1=1, then u_i=n. (Relaxed: u_i - (n-2)x_i1 >= 2)\n    if j == 1:\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n\n    return pyo.Constraint.Skip\nmodel.dl_constraints = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)\n\n# 3. Global Rank Sum Invariant (New Enhancement)\n# Forces the sum of non-depot position variables to equal the exact sum of the sequence 2..n.\n# This cuts relaxations where the average position value drifts from the valid permutation.\ndef rank_sum_rule(model):\n    # Sum of integers 2..n is (n(n+1)/2) - 1\n    target_sum = (n * (n + 1)) // 2 - 1\n    return sum(model.u[i] for i in model.N if i != 1) == target_sum\nmodel.rank_sum_constraint = pyo.Constraint(rule=rank_sum_rule)",
                        "idea": "This strategy integrates the best features of both parents while adding a new global invariant. It retains Parent 1's explicit 2-cycle cuts for efficient pre-solving and Parent 2's Desrochers-Laporte (DL) lifting, which strengthens the MTZ subtour elimination by tightening coefficients and strictly bounding node positions connected to the depot. To further enhance the formulation, a 'Global Rank Sum' constraint is added; since the position variables $u_i$ (for $i \\neq 1$) must be a permutation of $2..n$ in any integer solution, their sum is fixed. This equality constraint cuts off fractional solutions where the distribution of $u$ values satisfies local differences but violates the global average position, effectively shrinking the feasible region of the linear relaxation."
                    },
                    "fitness": 6.739486471390821,
                    "solver_reports": [
                        {
                            "gap": 22.8163,
                            "total_time": 11.89,
                            "explored_nodes": 59,
                            "simplex_iterations": 3622,
                            "explored_time": 11.87,
                            "work_units": 10.23
                        },
                        {
                            "total_time": 11.61,
                            "explored_nodes": 1,
                            "simplex_iterations": 2867,
                            "explored_time": 11.5,
                            "work_units": 10.01
                        },
                        {
                            "gap": 17.9026,
                            "total_time": 11.62,
                            "explored_nodes": 135,
                            "simplex_iterations": 6372,
                            "explored_time": 11.59,
                            "work_units": 10.02
                        },
                        {
                            "gap": 51.893,
                            "total_time": 13.1,
                            "explored_nodes": 1,
                            "simplex_iterations": 2381,
                            "explored_time": 12.97,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.3577,
                            "total_time": 14.09,
                            "explored_nodes": 2827,
                            "simplex_iterations": 70189,
                            "explored_time": 14.07,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 11.18,
                            "explored_nodes": 1,
                            "simplex_iterations": 2880,
                            "explored_time": 11.1,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 3.68,
                            "postsolve": 0.01,
                            "explored_nodes": 48616,
                            "simplex_iterations": 352424,
                            "explored_time": 3.67,
                            "work_units": 2.18
                        },
                        {
                            "gap": 2.1398,
                            "total_time": 13.78,
                            "explored_nodes": 2791,
                            "simplex_iterations": 94684,
                            "explored_time": 13.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.2966,
                            "total_time": 11.86,
                            "explored_nodes": 1,
                            "simplex_iterations": 1730,
                            "explored_time": 11.79,
                            "work_units": 10.0
                        },
                        {
                            "gap": 11.3109,
                            "total_time": 12.51,
                            "explored_nodes": 1,
                            "simplex_iterations": 2230,
                            "explored_time": 12.41,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "dac64902-bc73-4360-b06f-a785302741fa"
                    ]
                },
                {
                    "id": "8993fcbe-2cb4-41a4-a27c-2e65cc63e704",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Hybrid Strong Cuts: Synergizes explicit cycle elimination with depot-anchored lifting\n    # 1. Global 2-cycle Elimination (Inherited from Parent 2 for high fitness efficiency)\n    def sec2_cut_rule(m, i, j):\n        if i < j:\n            return m.x[i, j] + m.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2_cut = pyo.Constraint(model.N, model.N, rule=sec2_cut_rule)\n    \n    # 2. Depot Bound Tightening (Inherited from Parent 1)\n    # Tightens the feasible range of u[i] based on immediate connectivity to the depot.\n    # These constraints force u[i]=2 (first) or u[i]=n (last) if connected to node 1.\n    def depot_bound_out_rule(m, j):\n        if j != 1:\n            return m.u[j] <= n - (n - 2) * m.x[1, j]\n        return pyo.Constraint.Skip\n    model.depot_bound_out = pyo.Constraint(model.N, rule=depot_bound_out_rule)\n    \n    def depot_bound_in_rule(m, i):\n        if i != 1:\n            return m.u[i] >= 2 + (n - 2) * m.x[i, 1]\n        return pyo.Constraint.Skip\n    model.depot_bound_in = pyo.Constraint(model.N, rule=depot_bound_in_rule)\n    \n    # 3. Explicit Depot 3-Cycle Elimination (Novel Hybrid Component)\n    # MTZ algebraic constraints often allow 1->i->j->1 subtours (where u=[1, 2, n]).\n    # This cut explicitly removes them for n > 3, bridging the gap between u-bounds and x-cuts.\n    def depot_sec3_rule(m, i, j):\n        if n > 3 and i != 1 and j != 1 and i != j:\n            return m.x[1, i] + m.x[i, j] + m.x[j, 1] <= 2\n        return pyo.Constraint.Skip\n    model.depot_sec3 = pyo.Constraint(model.N, model.N, rule=depot_sec3_rule)\n\n    return model\n",
                        "added_cut": "# Hybrid Strong Cuts: Synergizes explicit cycle elimination with depot-anchored lifting\n# 1. Global 2-cycle Elimination (Inherited from Parent 2 for high fitness efficiency)\ndef sec2_cut_rule(m, i, j):\n    if i < j:\n        return m.x[i, j] + m.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2_cut = pyo.Constraint(model.N, model.N, rule=sec2_cut_rule)\n\n# 2. Depot Bound Tightening (Inherited from Parent 1)\n# Tightens the feasible range of u[i] based on immediate connectivity to the depot.\n# These constraints force u[i]=2 (first) or u[i]=n (last) if connected to node 1.\ndef depot_bound_out_rule(m, j):\n    if j != 1:\n        return m.u[j] <= n - (n - 2) * m.x[1, j]\n    return pyo.Constraint.Skip\nmodel.depot_bound_out = pyo.Constraint(model.N, rule=depot_bound_out_rule)\n\ndef depot_bound_in_rule(m, i):\n    if i != 1:\n        return m.u[i] >= 2 + (n - 2) * m.x[i, 1]\n    return pyo.Constraint.Skip\nmodel.depot_bound_in = pyo.Constraint(model.N, rule=depot_bound_in_rule)\n\n# 3. Explicit Depot 3-Cycle Elimination (Novel Hybrid Component)\n# MTZ algebraic constraints often allow 1->i->j->1 subtours (where u=[1, 2, n]).\n# This cut explicitly removes them for n > 3, bridging the gap between u-bounds and x-cuts.\ndef depot_sec3_rule(m, i, j):\n    if n > 3 and i != 1 and j != 1 and i != j:\n        return m.x[1, i] + m.x[i, j] + m.x[j, 1] <= 2\n    return pyo.Constraint.Skip\nmodel.depot_sec3 = pyo.Constraint(model.N, model.N, rule=depot_sec3_rule)",
                        "idea": "This hybrid formulation combines the efficient explicit 2-cycle cuts from Parent 2 with the strong depot-variable tightening from Parent 1. To further strengthen the relaxation, it introduces a novel explicit 3-cycle elimination constraint specifically for paths passing through the depot (1-i-j-1). These short subtours are often numerically feasible in standard MTZ relaxations (satisfying bounds u_i=2, u_j=n); explicitly cutting them tightens the polytope significantly in the critical depot-adjacent subspace without the computational overhead of full Desrochers-Laporte lifting."
                    },
                    "fitness": 4.38930628733397,
                    "solver_reports": [
                        {
                            "gap": 12.9601,
                            "total_time": 13.73,
                            "explored_nodes": 2395,
                            "simplex_iterations": 35374,
                            "explored_time": 13.71,
                            "work_units": 10.02
                        },
                        {
                            "total_time": 12.36,
                            "explored_nodes": 1,
                            "simplex_iterations": 3536,
                            "explored_time": 12.3,
                            "work_units": 10.01
                        },
                        {
                            "gap": 6.8553,
                            "total_time": 14.39,
                            "explored_nodes": 3098,
                            "simplex_iterations": 49108,
                            "explored_time": 14.37,
                            "work_units": 10.86
                        },
                        {
                            "total_time": 14.74,
                            "explored_nodes": 1,
                            "simplex_iterations": 2658,
                            "explored_time": 14.65,
                            "work_units": 10.01
                        },
                        {
                            "gap": 3.0792,
                            "total_time": 14.29,
                            "explored_nodes": 2860,
                            "simplex_iterations": 58111,
                            "explored_time": 14.26,
                            "work_units": 10.0
                        },
                        {
                            "gap": 19.017,
                            "total_time": 15.2,
                            "explored_nodes": 1,
                            "simplex_iterations": 2977,
                            "explored_time": 15.13,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 5.02,
                            "postsolve": 0.01,
                            "explored_nodes": 81538,
                            "simplex_iterations": 589250,
                            "explored_time": 5.01,
                            "work_units": 3.09
                        },
                        {
                            "gap": 2.1172,
                            "total_time": 12.68,
                            "explored_nodes": 767,
                            "simplex_iterations": 28515,
                            "explored_time": 12.65,
                            "work_units": 11.14
                        },
                        {
                            "gap": 23.5457,
                            "total_time": 12.32,
                            "explored_nodes": 15,
                            "simplex_iterations": 4388,
                            "explored_time": 12.29,
                            "work_units": 10.09
                        },
                        {
                            "gap": 31.8322,
                            "total_time": 15.21,
                            "explored_nodes": 1,
                            "simplex_iterations": 2955,
                            "explored_time": 15.12,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "45a89b06-992f-4e78-8cd4-1ee52a24a558",
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "f85ce181-93f9-472e-a1a7-f5b59f636ba7",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Integrated Strong MTZ: 2-Cycle Cuts + DL Lifting + 4-Way Depot Bounds\n    \n    # 1. Explicit 2-Cycle Cuts\n    # Prunes fractional 2-cycles (i->j->i) to aid pre-solve.\n    model.sec2_cuts = pyo.Constraint(model.N, model.N, rule=lambda m, i, j: m.x[i, j] + m.x[j, i] <= 1 if i < j else pyo.Constraint.Skip)\n    \n    # 2. Desrochers-Laporte (DL) Lifting for Internal Nodes\n    # Stronger subtour elimination for nodes i,j != 1.\n    # Formula: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n    def dl_rule(m, i, j):\n        if i != 1 and j != 1 and i != j:\n            return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    model.internal_dl = pyo.Constraint(model.N, model.N, rule=dl_rule)\n    \n    # 3. Enhanced Depot Bounds (Fixing + Tightening)\n    # While parents only fix u when arcs are used, this adds tight bounds when arcs are NOT used.\n    \n    # A. Outgoing from Depot (1 -> j): \n    # If x_1j = 1, force u_j = 2 (Upper Bound Fix). \n    # If x_1j = 0, force u_j >= 3 (Lower Bound Tightening).\n    model.depot_out_fix = pyo.Constraint(model.N, rule=lambda m, j: m.u[j] <= n - (n - 2) * m.x[1, j] if j > 1 else pyo.Constraint.Skip)\n    model.depot_out_tight = pyo.Constraint(model.N, rule=lambda m, j: m.u[j] >= 3 - m.x[1, j] if j > 1 else pyo.Constraint.Skip)\n    \n    # B. Incoming to Depot (i -> 1):\n    # If x_i1 = 1, force u_i = n (Lower Bound Fix).\n    # If x_i1 = 0, force u_i <= n-1 (Upper Bound Tightening).\n    model.depot_in_fix = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 + (n - 2) * m.x[i, 1] if i > 1 else pyo.Constraint.Skip)\n    model.depot_in_tight = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n - 1 + m.x[i, 1] if i > 1 else pyo.Constraint.Skip)\n\n    return model\n",
                        "added_cut": "# Integrated Strong MTZ: 2-Cycle Cuts + DL Lifting + 4-Way Depot Bounds\n\n# 1. Explicit 2-Cycle Cuts\n# Prunes fractional 2-cycles (i->j->i) to aid pre-solve.\nmodel.sec2_cuts = pyo.Constraint(model.N, model.N, rule=lambda m, i, j: m.x[i, j] + m.x[j, i] <= 1 if i < j else pyo.Constraint.Skip)\n\n# 2. Desrochers-Laporte (DL) Lifting for Internal Nodes\n# Stronger subtour elimination for nodes i,j != 1.\n# Formula: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\ndef dl_rule(m, i, j):\n    if i != 1 and j != 1 and i != j:\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\nmodel.internal_dl = pyo.Constraint(model.N, model.N, rule=dl_rule)\n\n# 3. Enhanced Depot Bounds (Fixing + Tightening)\n# While parents only fix u when arcs are used, this adds tight bounds when arcs are NOT used.\n\n# A. Outgoing from Depot (1 -> j): \n# If x_1j = 1, force u_j = 2 (Upper Bound Fix). \n# If x_1j = 0, force u_j >= 3 (Lower Bound Tightening).\nmodel.depot_out_fix = pyo.Constraint(model.N, rule=lambda m, j: m.u[j] <= n - (n - 2) * m.x[1, j] if j > 1 else pyo.Constraint.Skip)\nmodel.depot_out_tight = pyo.Constraint(model.N, rule=lambda m, j: m.u[j] >= 3 - m.x[1, j] if j > 1 else pyo.Constraint.Skip)\n\n# B. Incoming to Depot (i -> 1):\n# If x_i1 = 1, force u_i = n (Lower Bound Fix).\n# If x_i1 = 0, force u_i <= n-1 (Upper Bound Tightening).\nmodel.depot_in_fix = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 + (n - 2) * m.x[i, 1] if i > 1 else pyo.Constraint.Skip)\nmodel.depot_in_tight = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n - 1 + m.x[i, 1] if i > 1 else pyo.Constraint.Skip)",
                        "idea": "This formulation unifies the strongest elements of both parents (explicit 2-cycle cuts and Desrochers-Laporte lifting) and significantly tightens the depot-connectivity logic. While the parents successfully fixed variables when depot arcs are used (e.g., $x_{1j}=1 \\implies u_j=2$), this strategy introduces complementary bounds for when they are *not* used ($x_{1j}=0 \\implies u_j \\ge 3$ and $x_{i1}=0 \\implies u_i \\le n-1$). These valid 4-way inequalities strictly bound the continuous relaxation of $u$ variables, eliminating fractional solutions where node potentials float outside feasible integer ranges, thus providing a tighter approximation of the TSP convex hull."
                    },
                    "fitness": 2.190080633977209,
                    "solver_reports": [
                        {
                            "gap": 14.9359,
                            "total_time": 13.49,
                            "explored_nodes": 59,
                            "simplex_iterations": 3858,
                            "explored_time": 13.47,
                            "work_units": 10.64
                        },
                        {
                            "total_time": 11.95,
                            "explored_nodes": 1,
                            "simplex_iterations": 2524,
                            "explored_time": 11.84,
                            "work_units": 10.01
                        },
                        {
                            "gap": 16.6229,
                            "total_time": 13.11,
                            "explored_nodes": 5,
                            "simplex_iterations": 2076,
                            "explored_time": 13.09,
                            "work_units": 10.06
                        },
                        {
                            "total_time": 12.28,
                            "explored_nodes": 1,
                            "simplex_iterations": 2000,
                            "explored_time": 12.18,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.0612,
                            "total_time": 14.29,
                            "explored_nodes": 3381,
                            "simplex_iterations": 58535,
                            "explored_time": 14.26,
                            "work_units": 10.0
                        },
                        {
                            "gap": 1.1856,
                            "total_time": 12.87,
                            "explored_nodes": 1,
                            "simplex_iterations": 4116,
                            "explored_time": 12.81,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 4.75,
                            "postsolve": 0.01,
                            "explored_nodes": 67583,
                            "simplex_iterations": 456975,
                            "explored_time": 4.74,
                            "work_units": 2.77
                        },
                        {
                            "gap": 3.5354,
                            "total_time": 12.86,
                            "explored_nodes": 59,
                            "simplex_iterations": 4561,
                            "explored_time": 12.82,
                            "work_units": 10.81
                        },
                        {
                            "gap": 89.4705,
                            "total_time": 12.53,
                            "explored_nodes": 1,
                            "simplex_iterations": 2147,
                            "explored_time": 12.47,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 13.62,
                            "explored_nodes": 1,
                            "simplex_iterations": 2323,
                            "explored_time": 13.53,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "dac64902-bc73-4360-b06f-a785302741fa",
                        "45a89b06-992f-4e78-8cd4-1ee52a24a558"
                    ]
                }
            ],
            12.559533054020575
        ],
        [
            [
                {
                    "id": "3a0514a7-d9b5-4230-8054-2d35bda348ab",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Mutated Strategy: DL Lifting + Explicit 2-Cycle + Conditional Domain Tightening\n    \n    # 1. Explicit 2-cycle elimination\n    # Retained from individual: Provides sparse, strong cuts for LP relaxation.\n    def sec2_cut_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2_cuts = pyo.Constraint(model.N, model.N, rule=sec2_cut_rule)\n    \n    # 2. Desrochers-Laporte (DL) Lifting & Depot Fixing\n    # Retained: Strengthens subtour elimination and fixes u when connected to depot.\n    def dl_lifting_rule(model, i, j):\n        if i == j: return pyo.Constraint.Skip\n        \n        # Internal Nodes (i, j != 1): Lifted MTZ constraint\n        if i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n        # Depot Outgoing (1 -> j): If x_1j=1, force u_j=2\n        if i == 1:\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n    \n        # Depot Incoming (i -> 1): If x_i1=1, force u_i=n\n        if j == 1:\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n    \n        return pyo.Constraint.Skip\n    model.enhanced_dl_mtz = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)\n    \n    # 3. Conditional Depot Bounds (Added Mutation)\n    # Enhances the strategy by tightening u-bounds for nodes NOT connected to the depot.\n    # Complements the fixing constraints above to partition the domain of u.\n    \n    # Lower Bound Tightening: If node i is NOT the first visited (x_1i=0), u_i must be >= 3.\n    # Logic: u_i >= 2 + (1 - x_1i) => u_i >= 3 - x_1i\n    def depot_lb_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        return model.u[i] >= 3 - model.x[1, i]\n    model.depot_conditional_lb = pyo.Constraint(model.N, rule=depot_lb_rule)\n    \n    # Upper Bound Tightening: If node i is NOT the last visited (x_i1=0), u_i must be <= n-1.\n    # Logic: u_i <= n - (1 - x_i1) => u_i <= n - 1 + x_i1\n    def depot_ub_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        return model.u[i] <= (n - 1) + model.x[i, 1]\n    model.depot_conditional_ub = pyo.Constraint(model.N, rule=depot_ub_rule)\n\n    return model\n",
                        "added_cut": "# Mutated Strategy: DL Lifting + Explicit 2-Cycle + Conditional Domain Tightening\n\n# 1. Explicit 2-cycle elimination\n# Retained from individual: Provides sparse, strong cuts for LP relaxation.\ndef sec2_cut_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2_cuts = pyo.Constraint(model.N, model.N, rule=sec2_cut_rule)\n\n# 2. Desrochers-Laporte (DL) Lifting & Depot Fixing\n# Retained: Strengthens subtour elimination and fixes u when connected to depot.\ndef dl_lifting_rule(model, i, j):\n    if i == j: return pyo.Constraint.Skip\n    \n    # Internal Nodes (i, j != 1): Lifted MTZ constraint\n    if i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\n    # Depot Outgoing (1 -> j): If x_1j=1, force u_j=2\n    if i == 1:\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n\n    # Depot Incoming (i -> 1): If x_i1=1, force u_i=n\n    if j == 1:\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n\n    return pyo.Constraint.Skip\nmodel.enhanced_dl_mtz = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)\n\n# 3. Conditional Depot Bounds (Added Mutation)\n# Enhances the strategy by tightening u-bounds for nodes NOT connected to the depot.\n# Complements the fixing constraints above to partition the domain of u.\n\n# Lower Bound Tightening: If node i is NOT the first visited (x_1i=0), u_i must be >= 3.\n# Logic: u_i >= 2 + (1 - x_1i) => u_i >= 3 - x_1i\ndef depot_lb_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    return model.u[i] >= 3 - model.x[1, i]\nmodel.depot_conditional_lb = pyo.Constraint(model.N, rule=depot_lb_rule)\n\n# Upper Bound Tightening: If node i is NOT the last visited (x_i1=0), u_i must be <= n-1.\n# Logic: u_i <= n - (1 - x_i1) => u_i <= n - 1 + x_i1\ndef depot_ub_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    return model.u[i] <= (n - 1) + model.x[i, 1]\nmodel.depot_conditional_ub = pyo.Constraint(model.N, rule=depot_ub_rule)",
                        "idea": "This mutation augments the Desrochers-Laporte and 2-cycle strategy with Conditional Domain Tightening. While the original cuts fixed u[i] to 2 or n when connected to the depot, the new constraints strictly tighten the bounds for the 'unconnected' case (forcing u[i] into [3, n-1] when x[1,i]=0 or x[i,1]=0). This strictly partitions the continuous domain of u based on depot adjacency, significantly tightening the LP relaxation and strengthening the Big-M implications for all internal DL constraints."
                    },
                    "fitness": 12.559533054020575,
                    "solver_reports": [
                        {
                            "gap": 9.983,
                            "total_time": 14.25,
                            "explored_nodes": 1,
                            "simplex_iterations": 2480,
                            "explored_time": 14.21,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 11.61,
                            "explored_nodes": 1,
                            "simplex_iterations": 2767,
                            "explored_time": 11.53,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.5723,
                            "total_time": 12.08,
                            "explored_nodes": 369,
                            "simplex_iterations": 10792,
                            "explored_time": 12.06,
                            "work_units": 10.06
                        },
                        {
                            "total_time": 12.46,
                            "explored_nodes": 1,
                            "simplex_iterations": 1950,
                            "explored_time": 12.34,
                            "work_units": 10.0
                        },
                        {
                            "gap": 1.1852,
                            "total_time": 14.17,
                            "explored_nodes": 10783,
                            "simplex_iterations": 287126,
                            "explored_time": 14.16,
                            "work_units": 10.02
                        },
                        {
                            "gap": 17.5923,
                            "total_time": 12.82,
                            "explored_nodes": 1,
                            "simplex_iterations": 1661,
                            "explored_time": 12.73,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 2.88,
                            "postsolve": 0.0,
                            "explored_nodes": 42403,
                            "simplex_iterations": 292937,
                            "explored_time": 2.88,
                            "work_units": 1.53
                        },
                        {
                            "gap": 1.9875,
                            "total_time": 14.65,
                            "explored_nodes": 2958,
                            "simplex_iterations": 57432,
                            "explored_time": 14.61,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.2986,
                            "total_time": 12.42,
                            "explored_nodes": 1,
                            "simplex_iterations": 1777,
                            "explored_time": 12.37,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 13.63,
                            "explored_nodes": 1,
                            "simplex_iterations": 2314,
                            "explored_time": 13.56,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "General",
                    "parents_id": [
                        "dac64902-bc73-4360-b06f-a785302741fa"
                    ]
                },
                {
                    "id": "e385488a-3ec8-4677-9dde-3ba6103df133",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # 1. Explicit 2-Cycle Elimination\n    # Prunes sparse fractional 2-cycles (x_ij = x_ji = 0.5) often missed by MTZ.\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2_cuts = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n    \n    # 2. Desrochers-Laporte (DL) Lifting for Internal Nodes\n    # Stronger than standard MTZ by lifting with the reverse arc (n-3)*x[j,i].\n    def dl_internal_rule(model, i, j):\n        if i != 1 and j != 1 and i != j:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    model.dl_internal = pyo.Constraint(model.N, model.N, rule=dl_internal_rule)\n    \n    # 3. Strong Depot-Based Bounds (Domain Partitioning)\n    # Strictly partitions the domain of u[i] based on depot connectivity.\n    \n    # 3a. Forward Partition (Depot -> Node i)\n    # If x[1,i] == 1, force u[i] = 2. If x[1,i] == 0, force u[i] >= 3.\n    def depot_fwd_ub_rule(model, i):\n        if i != 1:\n            return model.u[i] + (n - 2) * model.x[1, i] <= n\n        return pyo.Constraint.Skip\n    model.depot_fwd_ub = pyo.Constraint(model.N, rule=depot_fwd_ub_rule)\n    \n    def depot_fwd_lb_rule(model, i):\n        if i != 1:\n            return model.u[i] >= 3 - model.x[1, i]\n        return pyo.Constraint.Skip\n    model.depot_fwd_lb = pyo.Constraint(model.N, rule=depot_fwd_lb_rule)\n    \n    # 3b. Backward Partition (Node i -> Depot)\n    # If x[i,1] == 1, force u[i] = n. If x[i,1] == 0, force u[i] <= n-1.\n    def depot_bwd_lb_rule(model, i):\n        if i != 1:\n            return model.u[i] - (n - 2) * model.x[i, 1] >= 2\n        return pyo.Constraint.Skip\n    model.depot_bwd_lb = pyo.Constraint(model.N, rule=depot_bwd_lb_rule)\n    \n    def depot_bwd_ub_rule(model, i):\n        if i != 1:\n            return model.u[i] <= (n - 1) + model.x[i, 1]\n        return pyo.Constraint.Skip\n    model.depot_bwd_ub = pyo.Constraint(model.N, rule=depot_bwd_ub_rule)\n\n    return model\n",
                        "added_cut": "# 1. Explicit 2-Cycle Elimination\n# Prunes sparse fractional 2-cycles (x_ij = x_ji = 0.5) often missed by MTZ.\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2_cuts = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n# 2. Desrochers-Laporte (DL) Lifting for Internal Nodes\n# Stronger than standard MTZ by lifting with the reverse arc (n-3)*x[j,i].\ndef dl_internal_rule(model, i, j):\n    if i != 1 and j != 1 and i != j:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\nmodel.dl_internal = pyo.Constraint(model.N, model.N, rule=dl_internal_rule)\n\n# 3. Strong Depot-Based Bounds (Domain Partitioning)\n# Strictly partitions the domain of u[i] based on depot connectivity.\n\n# 3a. Forward Partition (Depot -> Node i)\n# If x[1,i] == 1, force u[i] = 2. If x[1,i] == 0, force u[i] >= 3.\ndef depot_fwd_ub_rule(model, i):\n    if i != 1:\n        return model.u[i] + (n - 2) * model.x[1, i] <= n\n    return pyo.Constraint.Skip\nmodel.depot_fwd_ub = pyo.Constraint(model.N, rule=depot_fwd_ub_rule)\n\ndef depot_fwd_lb_rule(model, i):\n    if i != 1:\n        return model.u[i] >= 3 - model.x[1, i]\n    return pyo.Constraint.Skip\nmodel.depot_fwd_lb = pyo.Constraint(model.N, rule=depot_fwd_lb_rule)\n\n# 3b. Backward Partition (Node i -> Depot)\n# If x[i,1] == 1, force u[i] = n. If x[i,1] == 0, force u[i] <= n-1.\ndef depot_bwd_lb_rule(model, i):\n    if i != 1:\n        return model.u[i] - (n - 2) * model.x[i, 1] >= 2\n    return pyo.Constraint.Skip\nmodel.depot_bwd_lb = pyo.Constraint(model.N, rule=depot_bwd_lb_rule)\n\ndef depot_bwd_ub_rule(model, i):\n    if i != 1:\n        return model.u[i] <= (n - 1) + model.x[i, 1]\n    return pyo.Constraint.Skip\nmodel.depot_bwd_ub = pyo.Constraint(model.N, rule=depot_bwd_ub_rule)",
                        "idea": "Combines Explicit 2-Cycle Elimination with Desrochers-Laporte (DL) lifting and strict Depot-Based Domain Partitioning. The strategy enhances the standard MTZ formulation by using the stronger DL inequality (lifting with the reverse arc) for internal nodes and strictly partitioning the domain of position variables u[i] into {2}, [3, n-1], or {n} based on depot connectivity. This significantly tightens the linear relaxation by removing fractional solutions near the domain boundaries."
                    },
                    "fitness": 9.29754633992978,
                    "solver_reports": [
                        {
                            "gap": 14.051,
                            "total_time": 12.67,
                            "explored_nodes": 87,
                            "simplex_iterations": 5643,
                            "explored_time": 12.65,
                            "work_units": 10.34
                        },
                        {
                            "total_time": 12.53,
                            "explored_nodes": 1,
                            "simplex_iterations": 2217,
                            "explored_time": 12.41,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.0466,
                            "total_time": 12.23,
                            "explored_nodes": 168,
                            "simplex_iterations": 6680,
                            "explored_time": 12.21,
                            "work_units": 10.06
                        },
                        {
                            "total_time": 12.5,
                            "explored_nodes": 1,
                            "simplex_iterations": 2206,
                            "explored_time": 12.36,
                            "work_units": 10.01
                        },
                        {
                            "gap": 8.4151,
                            "total_time": 11.42,
                            "explored_nodes": 3959,
                            "simplex_iterations": 55947,
                            "explored_time": 11.39,
                            "work_units": 10.0
                        },
                        {
                            "gap": 1.4686,
                            "total_time": 12.81,
                            "explored_nodes": 1,
                            "simplex_iterations": 1816,
                            "explored_time": 12.74,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 3.32,
                            "postsolve": 0.01,
                            "explored_nodes": 42976,
                            "simplex_iterations": 296847,
                            "explored_time": 3.31,
                            "work_units": 1.78
                        },
                        {
                            "gap": 1.769,
                            "total_time": 13.42,
                            "explored_nodes": 2972,
                            "simplex_iterations": 72348,
                            "explored_time": 13.39,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.7884,
                            "total_time": 13.27,
                            "explored_nodes": 1,
                            "simplex_iterations": 1450,
                            "explored_time": 13.21,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 13.14,
                            "explored_nodes": 1,
                            "simplex_iterations": 2517,
                            "explored_time": 13.08,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "3a0514a7-d9b5-4230-8054-2d35bda348ab",
                        "c55b6986-6d93-4c28-88f0-28ee947dc873"
                    ]
                },
                {
                    "id": "d5324f33-a881-4cae-a977-81fbbd88a642",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # 4. Superadditive Lifted Bounds (Unified Depot-Connection Tightening)\n    # Applies coefficient lifting to merge and strengthen the conditional bounds.\n    # These constraints dominate separate DL fixing and user bounds by effectively \n    # creating a single hyperplane that is tight for all integer depot-connection cases.\n    def super_lifted_lb_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        # Logic: \n        # 1. If x[1,i]=1 -> u[i] >= 2 (Tight: 3 - 1 + 0 = 2)\n        # 2. If x[i,1]=1 -> u[i] >= n (Tight: 3 - 0 + n - 3 = n)\n        # 3. If Both=0   -> u[i] >= 3 (Tight: 3 - 0 + 0 = 3)\n        return model.u[i] >= 3 - model.x[1, i] + (n - 3) * model.x[i, 1]\n    model.super_lifted_lb = pyo.Constraint(model.N, rule=super_lifted_lb_rule)\n    \n    def super_lifted_ub_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        # Logic:\n        # 1. If x[1,i]=1 -> u[i] <= 2 (Tight: n-1 + 0 - (n-3) = 2)\n        # 2. If x[i,1]=1 -> u[i] <= n (Tight: n-1 + 1 - 0 = n)\n        # 3. If Both=0   -> u[i] <= n-1 (Tight: n-1 + 0 - 0 = n-1)\n        return model.u[i] <= (n - 1) + model.x[i, 1] - (n - 3) * model.x[1, i]\n    model.super_lifted_ub = pyo.Constraint(model.N, rule=super_lifted_ub_rule)\n    \n    # 5. Global Position Mass Balance (Aggregation Lifting)\n    # Lifts the set of position variables by enforcing their invariant sum.\n    # Since u describes a permutation of 2..n, their sum is constant.\n    # This cuts off fractional solutions where u variables 'collapse' to lower bounds.\n    def position_sum_rule(model):\n        target_sum = (n * (n + 1)) // 2 - 1  # Sum(1..n) - u[1]\n        return sum(model.u[i] for i in model.N if i != 1) == target_sum\n    model.position_mass_balance = pyo.Constraint(rule=position_sum_rule)\n\n    return model\n",
                        "added_cut": "# 4. Superadditive Lifted Bounds (Unified Depot-Connection Tightening)\n# Applies coefficient lifting to merge and strengthen the conditional bounds.\n# These constraints dominate separate DL fixing and user bounds by effectively \n# creating a single hyperplane that is tight for all integer depot-connection cases.\ndef super_lifted_lb_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    # Logic: \n    # 1. If x[1,i]=1 -> u[i] >= 2 (Tight: 3 - 1 + 0 = 2)\n    # 2. If x[i,1]=1 -> u[i] >= n (Tight: 3 - 0 + n - 3 = n)\n    # 3. If Both=0   -> u[i] >= 3 (Tight: 3 - 0 + 0 = 3)\n    return model.u[i] >= 3 - model.x[1, i] + (n - 3) * model.x[i, 1]\nmodel.super_lifted_lb = pyo.Constraint(model.N, rule=super_lifted_lb_rule)\n\ndef super_lifted_ub_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    # Logic:\n    # 1. If x[1,i]=1 -> u[i] <= 2 (Tight: n-1 + 0 - (n-3) = 2)\n    # 2. If x[i,1]=1 -> u[i] <= n (Tight: n-1 + 1 - 0 = n)\n    # 3. If Both=0   -> u[i] <= n-1 (Tight: n-1 + 0 - 0 = n-1)\n    return model.u[i] <= (n - 1) + model.x[i, 1] - (n - 3) * model.x[1, i]\nmodel.super_lifted_ub = pyo.Constraint(model.N, rule=super_lifted_ub_rule)\n\n# 5. Global Position Mass Balance (Aggregation Lifting)\n# Lifts the set of position variables by enforcing their invariant sum.\n# Since u describes a permutation of 2..n, their sum is constant.\n# This cuts off fractional solutions where u variables 'collapse' to lower bounds.\ndef position_sum_rule(model):\n    target_sum = (n * (n + 1)) // 2 - 1  # Sum(1..n) - u[1]\n    return sum(model.u[i] for i in model.N if i != 1) == target_sum\nmodel.position_mass_balance = pyo.Constraint(rule=position_sum_rule)",
                        "idea": "This mutation applies Superadditive Lifting and Global Aggregation to the MTZ position variables. First, the Superadditive Lifted Bounds unify the Desrochers-Laporte depot constraints with the Conditional Domain Tightening. By incorporating terms for both entering (x_1i) and leaving (x_i1) the depot into a single inequality with lifted coefficients (e.g., n-3), these cuts dominate the original separate bounds and strictly enforce the partition of u_i into {2}, {n}, or [3, n-1] in the LP relaxation. Second, the Global Position Mass Balance adds a rank-1 equality cut fixing the sum of u_i to the triangular number invariant (n(n+1)/2 - 1). This specifically counters the tendency of MTZ relaxations to minimize u values collectively to satisfy subtour constraints cheaply."
                    },
                    "fitness": 3.8598805769733815,
                    "solver_reports": [
                        {
                            "gap": 11.9888,
                            "total_time": 12.7,
                            "explored_nodes": 2582,
                            "simplex_iterations": 36044,
                            "explored_time": 12.69,
                            "work_units": 10.01
                        },
                        {
                            "gap": 16.9537,
                            "total_time": 12.42,
                            "explored_nodes": 1,
                            "simplex_iterations": 6710,
                            "explored_time": 12.38,
                            "work_units": 10.0
                        },
                        {
                            "gap": 11.2881,
                            "total_time": 12.58,
                            "explored_nodes": 213,
                            "simplex_iterations": 14626,
                            "explored_time": 12.57,
                            "work_units": 11.25
                        },
                        {
                            "gap": 72.1808,
                            "total_time": 13.96,
                            "explored_nodes": 1,
                            "simplex_iterations": 3098,
                            "explored_time": 13.91,
                            "work_units": 10.0
                        },
                        {
                            "gap": 2.5185,
                            "total_time": 12.73,
                            "explored_nodes": 7985,
                            "simplex_iterations": 124841,
                            "explored_time": 12.72,
                            "work_units": 10.01
                        },
                        {
                            "gap": 30.5572,
                            "total_time": 11.27,
                            "explored_nodes": 31,
                            "simplex_iterations": 7647,
                            "explored_time": 11.23,
                            "work_units": 10.21
                        },
                        {
                            "gap": 5.3757,
                            "total_time": 13.9,
                            "explored_nodes": 165921,
                            "simplex_iterations": 1028049,
                            "explored_time": 13.9,
                            "work_units": 10.02
                        },
                        {
                            "gap": 4.7218,
                            "total_time": 12.06,
                            "explored_nodes": 3192,
                            "simplex_iterations": 68294,
                            "explored_time": 12.03,
                            "work_units": 10.0
                        },
                        {
                            "gap": 28.454,
                            "total_time": 12.58,
                            "explored_nodes": 115,
                            "simplex_iterations": 10756,
                            "explored_time": 12.55,
                            "work_units": 10.49
                        },
                        {
                            "gap": 29.5758,
                            "total_time": 11.74,
                            "explored_nodes": 31,
                            "simplex_iterations": 5854,
                            "explored_time": 11.71,
                            "work_units": 10.12
                        }
                    ],
                    "generator": "Lifted",
                    "parents_id": [
                        "3a0514a7-d9b5-4230-8054-2d35bda348ab"
                    ]
                },
                {
                    "id": "dde00df7-accf-4251-bf1e-933dbb64dcdd",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    import itertools\n    \n    # Exploratory Strategy: Explicit Size-3 Subtour Elimination (SEC-3)\n    # While the previous strategy focused on strengthening position variables (u) via algebraic lifting (DL, Rank Sum),\n    # this strategy targets the binary variables (x) directly by explicitly eliminating size-3 subtours.\n    # MTZ formulations are notoriously weak against small fractional cycles (triangles) among non-depot nodes.\n    # This constraint block exhaustively removes these artifacts from the relaxation.\n    \n    def sec3_cut_generator(model):\n        # This cut is only valid/necessary if the graph has enough nodes to form a subtour distinct from the full tour.\n        # For n=3, the only cycle is the tour itself.\n        if n < 4:\n            return\n    \n        # We target subsets of size 3 from the non-depot nodes (2..n).\n        # Subtours passing through the depot are generally well-handled by standard MTZ constraints.\n        # 'Floating' subtours disjoint from the depot are the primary source of weak LP bounds.\n        non_depot_nodes = [i for i in model.N if i != 1]\n        \n        # Initialize a constraint list to hold the generated cuts\n        model.sec3_cuts = pyo.ConstraintList()\n        \n        # Iterate over all unique triplets of non-depot nodes\n        for S in itertools.combinations(non_depot_nodes, 3):\n            # Calculate the sum of arcs purely internal to the subset S\n            # S = {i, j, k}. Internal arcs are (i,j), (j,i), (j,k), (k,j), (k,i), (i,k)\n            internal_flow = sum(model.x[u, v] for u in S for v in S if u != v)\n            \n            # SEC Logic: For any subset S, sum(x_ij) <= |S| - 1\n            # For |S|=3, max edges = 2. This forbids cycles of length 3 (which use 3 edges).\n            model.sec3_cuts.add(internal_flow <= 2)\n    \n    # Execute the generator\n    sec3_cut_generator(model)\n\n    return model\n",
                        "added_cut": "import itertools\n\n# Exploratory Strategy: Explicit Size-3 Subtour Elimination (SEC-3)\n# While the previous strategy focused on strengthening position variables (u) via algebraic lifting (DL, Rank Sum),\n# this strategy targets the binary variables (x) directly by explicitly eliminating size-3 subtours.\n# MTZ formulations are notoriously weak against small fractional cycles (triangles) among non-depot nodes.\n# This constraint block exhaustively removes these artifacts from the relaxation.\n\ndef sec3_cut_generator(model):\n    # This cut is only valid/necessary if the graph has enough nodes to form a subtour distinct from the full tour.\n    # For n=3, the only cycle is the tour itself.\n    if n < 4:\n        return\n\n    # We target subsets of size 3 from the non-depot nodes (2..n).\n    # Subtours passing through the depot are generally well-handled by standard MTZ constraints.\n    # 'Floating' subtours disjoint from the depot are the primary source of weak LP bounds.\n    non_depot_nodes = [i for i in model.N if i != 1]\n    \n    # Initialize a constraint list to hold the generated cuts\n    model.sec3_cuts = pyo.ConstraintList()\n    \n    # Iterate over all unique triplets of non-depot nodes\n    for S in itertools.combinations(non_depot_nodes, 3):\n        # Calculate the sum of arcs purely internal to the subset S\n        # S = {i, j, k}. Internal arcs are (i,j), (j,i), (j,k), (k,j), (k,i), (i,k)\n        internal_flow = sum(model.x[u, v] for u in S for v in S if u != v)\n        \n        # SEC Logic: For any subset S, sum(x_ij) <= |S| - 1\n        # For |S|=3, max edges = 2. This forbids cycles of length 3 (which use 3 edges).\n        model.sec3_cuts.add(internal_flow <= 2)\n\n# Execute the generator\nsec3_cut_generator(model)",
                        "idea": "This strategy diverges from the parent's focus on tightening algebraic position variables ($u$) and instead introduces explicit combinatorial cuts on the arc variables ($x$). Specifically, it implements Size-3 Subtour Elimination Constraints (SEC-3) for all node triplets excluding the depot. While MTZ formulations effectively prevent global disconnected tours, their linear relaxations often permit 'floating' fractional triangles ($x_{ij}=x_{jk}=x_{ki}=0.5$) among internal nodes. By enforcing that the number of edges within any size-3 subset is at most 2, these cuts prune a significant class of fractional solutions, tightening the convex hull approximation purely through binary structure."
                    },
                    "fitness": 0.2133046613938846,
                    "solver_reports": [
                        {
                            "gap": 45.7776,
                            "total_time": 11.92,
                            "explored_nodes": 1,
                            "simplex_iterations": 1001,
                            "explored_time": 11.79,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 7.0,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 6.43,
                            "work_units": 10.0
                        },
                        {
                            "gap": 57.7632,
                            "total_time": 11.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 1101,
                            "explored_time": 11.36,
                            "work_units": 10.04
                        },
                        {
                            "total_time": 8.63,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 7.87,
                            "work_units": 10.0
                        },
                        {
                            "gap": 9.9585,
                            "total_time": 17.44,
                            "explored_nodes": 115,
                            "simplex_iterations": 7154,
                            "explored_time": 17.41,
                            "work_units": 10.06
                        },
                        {
                            "total_time": 5.99,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 5.61,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.1637,
                            "total_time": 13.32,
                            "explored_nodes": 222780,
                            "simplex_iterations": 1431853,
                            "explored_time": 13.31,
                            "work_units": 10.04
                        },
                        {
                            "gap": 22.661,
                            "total_time": 11.42,
                            "explored_nodes": 1,
                            "simplex_iterations": 1243,
                            "explored_time": 11.32,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 8.51,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 8.25,
                            "work_units": 10.04
                        },
                        {
                            "total_time": 6.96,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 6.59,
                            "work_units": 10.01
                        }
                    ],
                    "generator": "Exploratory",
                    "parents_id": [
                        "436986dd-d10e-4af7-8cc0-01370d657a43"
                    ]
                },
                {
                    "id": "f5782c55-8780-4a7b-946e-ef17a4a8cc28",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Exploratory Mutation: Exact Positional Hull (Reverse MTZ + Permutation Sum)\n    \n    # 1. Reverse MTZ (Positional Upper Bound)\n    # While standard MTZ enforces u_j >= u_i + 1 when x_ij=1, this enforces u_j <= u_i + 1.\n    # This \"locks\" the positional difference to exactly 1 for active arcs, eliminating slack.\n    # Validity: If x_ij=1, u_j - u_i <= 1. If x_ij=0, u_j - u_i <= n-1 (Max diff is n-2, so valid).\n    def reverse_mtz_rule(model, i, j):\n        if i != 1 and j != 1 and i != j:\n            # Logic: u_j - u_i <= 1 + (n - 2)(1 - x_ij)\n            # Rearranged: u_j - u_i + (n - 2) * model.x[i, j] <= n - 1\n            return model.u[j] - model.u[i] + (n - 2) * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.reverse_mtz = pyo.Constraint(model.N, model.N, rule=reverse_mtz_rule)\n    \n    # 2. Permutation Sum Equality\n    # In any valid TSP tour, the set of position variables {u_2, ..., u_n} is a permutation of {2, ..., n}.\n    # Therefore, their sum is invariant and equal to n(n+1)/2 - 1.\n    # This global cut removes fractional solutions where u-variables are collectively too small or large.\n    def perm_sum_rule(model):\n        target_sum = (n * (n + 1)) // 2 - 1\n        return sum(model.u[i] for i in model.N if i != 1) == target_sum\n    model.permutation_sum = pyo.Constraint(rule=perm_sum_rule)\n\n    return model\n",
                        "added_cut": "# Exploratory Mutation: Exact Positional Hull (Reverse MTZ + Permutation Sum)\n\n# 1. Reverse MTZ (Positional Upper Bound)\n# While standard MTZ enforces u_j >= u_i + 1 when x_ij=1, this enforces u_j <= u_i + 1.\n# This \"locks\" the positional difference to exactly 1 for active arcs, eliminating slack.\n# Validity: If x_ij=1, u_j - u_i <= 1. If x_ij=0, u_j - u_i <= n-1 (Max diff is n-2, so valid).\ndef reverse_mtz_rule(model, i, j):\n    if i != 1 and j != 1 and i != j:\n        # Logic: u_j - u_i <= 1 + (n - 2)(1 - x_ij)\n        # Rearranged: u_j - u_i + (n - 2) * model.x[i, j] <= n - 1\n        return model.u[j] - model.u[i] + (n - 2) * model.x[i, j] <= n - 1\n    return pyo.Constraint.Skip\nmodel.reverse_mtz = pyo.Constraint(model.N, model.N, rule=reverse_mtz_rule)\n\n# 2. Permutation Sum Equality\n# In any valid TSP tour, the set of position variables {u_2, ..., u_n} is a permutation of {2, ..., n}.\n# Therefore, their sum is invariant and equal to n(n+1)/2 - 1.\n# This global cut removes fractional solutions where u-variables are collectively too small or large.\ndef perm_sum_rule(model):\n    target_sum = (n * (n + 1)) // 2 - 1\n    return sum(model.u[i] for i in model.N if i != 1) == target_sum\nmodel.permutation_sum = pyo.Constraint(rule=perm_sum_rule)",
                        "idea": "This mutation introduces 'Exact Positional Hull' constraints to restrict the feasible region of the continuous position variables u. Standard MTZ/DL constraints only enforce a lower bound on position differences (u_j >= u_i + 1), allowing 'slack' in the u-space for fractional solutions. The 'Reverse MTZ' constraint imposes the complementary upper bound (u_j <= u_i + 1), tightly coupling u to the tour order. Additionally, the 'Permutation Sum' constraint exploits the combinatorial property that positions are a permutation of 2..n, enforcing a global hyperplane cut that invalidates relaxations where u-values do not strictly adhere to the sum of a valid tour sequence."
                    },
                    "fitness": 1.3423374197733104,
                    "solver_reports": [
                        {
                            "gap": 13.0644,
                            "total_time": 13.04,
                            "explored_nodes": 59,
                            "simplex_iterations": 6536,
                            "explored_time": 13.02,
                            "work_units": 12.1
                        },
                        {
                            "total_time": 13.91,
                            "explored_nodes": 1,
                            "simplex_iterations": 4266,
                            "explored_time": 13.84,
                            "work_units": 10.01
                        },
                        {
                            "gap": 19.6477,
                            "total_time": 13.53,
                            "explored_nodes": 59,
                            "simplex_iterations": 8176,
                            "explored_time": 13.51,
                            "work_units": 12.03
                        },
                        {
                            "total_time": 14.61,
                            "explored_nodes": 1,
                            "simplex_iterations": 3119,
                            "explored_time": 14.52,
                            "work_units": 10.03
                        },
                        {
                            "gap": 7.1221,
                            "total_time": 9.76,
                            "explored_nodes": 2446,
                            "simplex_iterations": 43347,
                            "explored_time": 9.75,
                            "work_units": 10.03
                        },
                        {
                            "total_time": 13.2,
                            "explored_nodes": 1,
                            "simplex_iterations": 7884,
                            "explored_time": 13.15,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.6343,
                            "total_time": 13.02,
                            "explored_nodes": 197090,
                            "simplex_iterations": 1336511,
                            "explored_time": 13.02,
                            "work_units": 10.02
                        },
                        {
                            "gap": 4.9051,
                            "total_time": 11.98,
                            "explored_nodes": 59,
                            "simplex_iterations": 9215,
                            "explored_time": 11.96,
                            "work_units": 12.24
                        },
                        {
                            "gap": 68.2562,
                            "total_time": 12.53,
                            "explored_nodes": 1,
                            "simplex_iterations": 3942,
                            "explored_time": 12.48,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 12.57,
                            "explored_nodes": 1,
                            "simplex_iterations": 4032,
                            "explored_time": 12.48,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Exploratory",
                    "parents_id": [
                        "3a0514a7-d9b5-4230-8054-2d35bda348ab"
                    ]
                },
                {
                    "id": "faf5c70b-1c2a-403c-8f23-df93565ce71d",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Full Desrochers-Laporte (DL) Lifted MTZ with Depot Tightening\n    def full_dl_rule(model, i, j):\n        # Internal Arcs (i, j != 1): Full Desrochers-Laporte Lifting\n        # Constraint: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n        # The term (n-3)x_ji provides maximal lifting, algebraically forcing \n        # 2-cycle elimination (Parent 1's strength) and tightening the big-M \n        # relaxation significantly more than Parent 2's simplified version.\n        if i != 1 and j != 1 and i != j:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n        \n        # Depot Outgoing (1 -> j): Variable Binding\n        # Forces u[j] = 2 if x[1,j] = 1, tightening the upper bound.\n        elif i == 1 and j != 1:\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n    \n        # Depot Incoming (i -> 1): Variable Binding\n        # Forces u[i] = n if x[i,1] = 1, tightening the lower bound.\n        elif j == 1 and i != 1:\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n            \n        return pyo.Constraint.Skip\n    \n    model.full_dl_cuts = pyo.Constraint(model.N, model.N, rule=full_dl_rule)\n\n    return model\n",
                        "added_cut": "# Full Desrochers-Laporte (DL) Lifted MTZ with Depot Tightening\ndef full_dl_rule(model, i, j):\n    # Internal Arcs (i, j != 1): Full Desrochers-Laporte Lifting\n    # Constraint: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n    # The term (n-3)x_ji provides maximal lifting, algebraically forcing \n    # 2-cycle elimination (Parent 1's strength) and tightening the big-M \n    # relaxation significantly more than Parent 2's simplified version.\n    if i != 1 and j != 1 and i != j:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n    # Depot Outgoing (1 -> j): Variable Binding\n    # Forces u[j] = 2 if x[1,j] = 1, tightening the upper bound.\n    elif i == 1 and j != 1:\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n\n    # Depot Incoming (i -> 1): Variable Binding\n    # Forces u[i] = n if x[i,1] = 1, tightening the lower bound.\n    elif j == 1 and i != 1:\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n        \n    return pyo.Constraint.Skip\n\nmodel.full_dl_cuts = pyo.Constraint(model.N, model.N, rule=full_dl_rule)",
                        "idea": "This constraint implements the 'Full Desrochers-Laporte' lifting, which strictly dominates both parent approaches. By including the reverse-arc term $(n-3)x_{ji}$ (omitted in Parent 2), this formulation mathematically subsumes Parent 1's 2-cycle elimination cuts ($x_{ij}+x_{ji} \\le 1$) directly within the subtour logic. It provides the tightest possible linear relaxation for the MTZ variables without auxiliary variables, unifying Parent 1's cycle-breaking efficiency with Parent 2's depot-bound logic into a single, compact, and polyhedrally stronger constraint set."
                    },
                    "fitness": 1.2598160141331316,
                    "solver_reports": [
                        {
                            "gap": 13.2745,
                            "total_time": 10.79,
                            "explored_nodes": 810,
                            "simplex_iterations": 18790,
                            "explored_time": 10.77,
                            "work_units": 10.03
                        },
                        {
                            "gap": 11.322,
                            "total_time": 14.14,
                            "explored_nodes": 1,
                            "simplex_iterations": 2266,
                            "explored_time": 14.05,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.2456,
                            "total_time": 11.44,
                            "explored_nodes": 456,
                            "simplex_iterations": 17496,
                            "explored_time": 11.42,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 13.06,
                            "explored_nodes": 1,
                            "simplex_iterations": 1615,
                            "explored_time": 12.96,
                            "work_units": 10.02
                        },
                        {
                            "gap": 1.037,
                            "total_time": 11.91,
                            "explored_nodes": 37689,
                            "simplex_iterations": 936834,
                            "explored_time": 11.9,
                            "work_units": 10.06
                        },
                        {
                            "total_time": 12.82,
                            "explored_nodes": 1,
                            "simplex_iterations": 1508,
                            "explored_time": 12.74,
                            "work_units": 10.09
                        },
                        {
                            "gap": 0.0,
                            "total_time": 3.45,
                            "postsolve": 0.01,
                            "explored_nodes": 60465,
                            "simplex_iterations": 375914,
                            "explored_time": 3.44,
                            "work_units": 1.86
                        },
                        {
                            "gap": 1.2806,
                            "total_time": 13.01,
                            "explored_nodes": 13735,
                            "simplex_iterations": 329922,
                            "explored_time": 12.99,
                            "work_units": 10.02
                        },
                        {
                            "gap": 7.5664,
                            "total_time": 13.18,
                            "explored_nodes": 1,
                            "simplex_iterations": 2768,
                            "explored_time": 13.14,
                            "work_units": 10.12
                        },
                        {
                            "gap": 88.2147,
                            "total_time": 13.13,
                            "explored_nodes": 1,
                            "simplex_iterations": 2294,
                            "explored_time": 13.06,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0",
                        "c55b6986-6d93-4c28-88f0-28ee947dc873"
                    ]
                },
                {
                    "id": "b9d7a2ef-4386-41b5-959c-9817289ca0e4",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Strong MTZ Enhancement: 2-Cycle Elimination + Depot Position Fixing\n    \n    # 1. Explicit 2-Cycle Cuts (Inherited from Parent 2)\n    # Removes fractional 2-node subtours (i<->j) which satisfy standard MTZ but violate TSP.\n    # This is O(N^2) but sparse and highly effective for tightening the relaxation.\n    model.sec2_cuts = pyo.Constraint(model.N, model.N, rule=lambda m, i, j: m.x[i, j] + m.x[j, i] <= 1 if i < j else pyo.Constraint.Skip)\n    \n    # 2. Depot Position Bounds (Refined from Parent 1)\n    # These O(N) constraints tighten the domain of 'u' based on connectivity to the depot (node 1).\n    # They eliminate fractional solutions where 'u' values float near 2 or n without direct depot connections.\n    \n    # A. Outgoing from Depot (1 -> j): \n    # If x_1j = 1, force u_j = 2. If x_1j = 0, force u_j >= 3.\n    # Logic: u_j + (n - 2)*x_1j <= n  ==>  if x_1j=1, u_j<=2 (fixes u_j=2).\n    # Logic: u_j >= 3 - x_1j        ==>  if x_1j=0, u_j>=3 (tightens LB).\n    model.depot_out_fix = pyo.Constraint(model.N, rule=lambda m, j: m.u[j] + (n - 2) * m.x[1, j] <= n if j > 1 else pyo.Constraint.Skip)\n    model.depot_out_tight = pyo.Constraint(model.N, rule=lambda m, j: m.u[j] >= 3 - m.x[1, j] if j > 1 else pyo.Constraint.Skip)\n    \n    # B. Incoming to Depot (i -> 1):\n    # If x_i1 = 1, force u_i = n. If x_i1 = 0, force u_i <= n - 1.\n    # Logic: u_i - (n - 2)*x_i1 >= 2  ==>  if x_i1=1, u_i>=n (fixes u_i=n).\n    # Logic: u_i <= n - 1 + x_i1    ==>  if x_i1=0, u_i<=n-1 (tightens UB).\n    model.depot_in_fix = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] - (n - 2) * m.x[i, 1] >= 2 if i > 1 else pyo.Constraint.Skip)\n    model.depot_in_tight = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n - 1 + m.x[i, 1] if i > 1 else pyo.Constraint.Skip)\n\n    return model\n",
                        "added_cut": "# Strong MTZ Enhancement: 2-Cycle Elimination + Depot Position Fixing\n\n# 1. Explicit 2-Cycle Cuts (Inherited from Parent 2)\n# Removes fractional 2-node subtours (i<->j) which satisfy standard MTZ but violate TSP.\n# This is O(N^2) but sparse and highly effective for tightening the relaxation.\nmodel.sec2_cuts = pyo.Constraint(model.N, model.N, rule=lambda m, i, j: m.x[i, j] + m.x[j, i] <= 1 if i < j else pyo.Constraint.Skip)\n\n# 2. Depot Position Bounds (Refined from Parent 1)\n# These O(N) constraints tighten the domain of 'u' based on connectivity to the depot (node 1).\n# They eliminate fractional solutions where 'u' values float near 2 or n without direct depot connections.\n\n# A. Outgoing from Depot (1 -> j): \n# If x_1j = 1, force u_j = 2. If x_1j = 0, force u_j >= 3.\n# Logic: u_j + (n - 2)*x_1j <= n  ==>  if x_1j=1, u_j<=2 (fixes u_j=2).\n# Logic: u_j >= 3 - x_1j        ==>  if x_1j=0, u_j>=3 (tightens LB).\nmodel.depot_out_fix = pyo.Constraint(model.N, rule=lambda m, j: m.u[j] + (n - 2) * m.x[1, j] <= n if j > 1 else pyo.Constraint.Skip)\nmodel.depot_out_tight = pyo.Constraint(model.N, rule=lambda m, j: m.u[j] >= 3 - m.x[1, j] if j > 1 else pyo.Constraint.Skip)\n\n# B. Incoming to Depot (i -> 1):\n# If x_i1 = 1, force u_i = n. If x_i1 = 0, force u_i <= n - 1.\n# Logic: u_i - (n - 2)*x_i1 >= 2  ==>  if x_i1=1, u_i>=n (fixes u_i=n).\n# Logic: u_i <= n - 1 + x_i1    ==>  if x_i1=0, u_i<=n-1 (tightens UB).\nmodel.depot_in_fix = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] - (n - 2) * m.x[i, 1] >= 2 if i > 1 else pyo.Constraint.Skip)\nmodel.depot_in_tight = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n - 1 + m.x[i, 1] if i > 1 else pyo.Constraint.Skip)",
                        "idea": "This formulation combines the highly effective explicit 2-cycle cuts from Parent 2 with the logical depot-variable fixing from Parent 1. It discards the computationally expensive O(N^2) Desrochers-Laporte lifting from Parent 1 (which likely degraded fitness via model size) to focus on O(N) constraints that strictly bind the MTZ auxiliary variables ($u$) to the depot arcs ($x_{1j}, x_{i1}$). This tightens the linear relaxation by eliminating fractional $u$-values inconsistent with tour start/end logic while maintaining the sparsity and robustness of the 2-cycle cuts."
                    },
                    "fitness": 4.598002789116044,
                    "solver_reports": [
                        {
                            "gap": 14.2638,
                            "total_time": 14.28,
                            "explored_nodes": 6214,
                            "simplex_iterations": 77060,
                            "explored_time": 14.25,
                            "work_units": 11.12
                        },
                        {
                            "gap": 9.2981,
                            "total_time": 13.47,
                            "explored_nodes": 1,
                            "simplex_iterations": 4681,
                            "explored_time": 13.43,
                            "work_units": 10.0
                        },
                        {
                            "gap": 11.0869,
                            "total_time": 12.41,
                            "explored_nodes": 171,
                            "simplex_iterations": 8013,
                            "explored_time": 12.39,
                            "work_units": 10.04
                        },
                        {
                            "gap": 50.1472,
                            "total_time": 14.15,
                            "explored_nodes": 1,
                            "simplex_iterations": 2876,
                            "explored_time": 14.08,
                            "work_units": 10.0
                        },
                        {
                            "gap": 2.3704,
                            "total_time": 12.44,
                            "explored_nodes": 2870,
                            "simplex_iterations": 60501,
                            "explored_time": 12.43,
                            "work_units": 10.0
                        },
                        {
                            "gap": 35.254,
                            "total_time": 12.4,
                            "explored_nodes": 7,
                            "simplex_iterations": 3655,
                            "explored_time": 12.36,
                            "work_units": 10.07
                        },
                        {
                            "gap": 5.1904,
                            "total_time": 15.84,
                            "explored_nodes": 151793,
                            "simplex_iterations": 921164,
                            "explored_time": 15.84,
                            "work_units": 10.02
                        },
                        {
                            "gap": 2.8753,
                            "total_time": 14.12,
                            "explored_nodes": 2863,
                            "simplex_iterations": 58885,
                            "explored_time": 14.1,
                            "work_units": 10.02
                        },
                        {
                            "gap": 23.0347,
                            "total_time": 10.8,
                            "explored_nodes": 7,
                            "simplex_iterations": 4565,
                            "explored_time": 10.78,
                            "work_units": 10.06
                        },
                        {
                            "gap": 29.359,
                            "total_time": 13.4,
                            "explored_nodes": 1,
                            "simplex_iterations": 2831,
                            "explored_time": 13.36,
                            "work_units": 10.01
                        }
                    ],
                    "generator": "Min_Violation",
                    "parents_id": [
                        "f85ce181-93f9-472e-a1a7-f5b59f636ba7",
                        "2e9aa48b-1305-4a70-b23f-a5f97b686de0"
                    ]
                },
                {
                    "id": "9dee4e72-fe81-4735-8fe4-87fafd3373d7",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Hybrid Strategy: Unified Lifted MTZ + Conditional Domain Tightening\n    # Combines the structural efficiency of Parent 1 (unified constraint blocks) with the \n    # superior numerical tightening of Parent 2 (DL lifting + conditional bounds).\n    \n    # 1. Explicit 2-Cycle Elimination (Retained from both parents)\n    # Keeps the LP relaxation tight against fractional 2-cycles.\n    def sec2_hybrid_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2_hybrid = pyo.Constraint(model.N, model.N, rule=sec2_hybrid_rule)\n    \n    # 2. Unified Lifted MTZ (Structure: Parent 1, Logic: Parent 2)\n    # Merges Internal DL Lifting and Depot Variable Fixing into a single O(n^2) constraint.\n    # This reduces object overhead while applying the stronger DL coefficients.\n    def unified_mtz_rule(model, i, j):\n        if i == j: return pyo.Constraint.Skip\n        \n        # Internal Nodes (i, j != 1): Desrochers-Laporte Lifting\n        # Stronger than base MTZ due to the (n-3)*x[j,i] term and tighter RHS.\n        if i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n        # Depot Outgoing (1 -> j): Variable Upper Bound Fixing\n        # If x[1,j]=1, force u[j] <= 2. Otherwise u[j] <= n.\n        if i == 1:\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n    \n        # Depot Incoming (i -> 1): Variable Lower Bound Fixing\n        # If x[i,1]=1, force u[i] >= n. Otherwise u[i] >= 2.\n        if j == 1:\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n            \n        return pyo.Constraint.Skip\n    model.unified_mtz = pyo.Constraint(model.N, model.N, rule=unified_mtz_rule)\n    \n    # 3. Conditional Domain Tightening (From Parent 2)\n    # Strictly partitions the domain of u based on depot adjacency.\n    # Improves the Big-M strength of internal cuts by shrinking the effective range of u.\n    \n    # If node i is NOT the first visited (x[1,i]=0), then u[i] must be >= 3.\n    def cond_lb_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        return model.u[i] >= 3 - model.x[1, i]\n    model.conditional_lb = pyo.Constraint(model.N, rule=cond_lb_rule)\n    \n    # If node i is NOT the last visited (x[i,1]=0), then u[i] must be <= n-1.\n    def cond_ub_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        return model.u[i] <= (n - 1) + model.x[i, 1]\n    model.conditional_ub = pyo.Constraint(model.N, rule=cond_ub_rule)\n\n    return model\n",
                        "added_cut": "# Hybrid Strategy: Unified Lifted MTZ + Conditional Domain Tightening\n# Combines the structural efficiency of Parent 1 (unified constraint blocks) with the \n# superior numerical tightening of Parent 2 (DL lifting + conditional bounds).\n\n# 1. Explicit 2-Cycle Elimination (Retained from both parents)\n# Keeps the LP relaxation tight against fractional 2-cycles.\ndef sec2_hybrid_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2_hybrid = pyo.Constraint(model.N, model.N, rule=sec2_hybrid_rule)\n\n# 2. Unified Lifted MTZ (Structure: Parent 1, Logic: Parent 2)\n# Merges Internal DL Lifting and Depot Variable Fixing into a single O(n^2) constraint.\n# This reduces object overhead while applying the stronger DL coefficients.\ndef unified_mtz_rule(model, i, j):\n    if i == j: return pyo.Constraint.Skip\n    \n    # Internal Nodes (i, j != 1): Desrochers-Laporte Lifting\n    # Stronger than base MTZ due to the (n-3)*x[j,i] term and tighter RHS.\n    if i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\n    # Depot Outgoing (1 -> j): Variable Upper Bound Fixing\n    # If x[1,j]=1, force u[j] <= 2. Otherwise u[j] <= n.\n    if i == 1:\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n\n    # Depot Incoming (i -> 1): Variable Lower Bound Fixing\n    # If x[i,1]=1, force u[i] >= n. Otherwise u[i] >= 2.\n    if j == 1:\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n        \n    return pyo.Constraint.Skip\nmodel.unified_mtz = pyo.Constraint(model.N, model.N, rule=unified_mtz_rule)\n\n# 3. Conditional Domain Tightening (From Parent 2)\n# Strictly partitions the domain of u based on depot adjacency.\n# Improves the Big-M strength of internal cuts by shrinking the effective range of u.\n\n# If node i is NOT the first visited (x[1,i]=0), then u[i] must be >= 3.\ndef cond_lb_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    return model.u[i] >= 3 - model.x[1, i]\nmodel.conditional_lb = pyo.Constraint(model.N, rule=cond_lb_rule)\n\n# If node i is NOT the last visited (x[i,1]=0), then u[i] must be <= n-1.\ndef cond_ub_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    return model.u[i] <= (n - 1) + model.x[i, 1]\nmodel.conditional_ub = pyo.Constraint(model.N, rule=cond_ub_rule)",
                        "idea": "This hybrid formulation merges Parent 1's structural efficiency (unified constraint blocks) with Parent 2's stronger numerical logic. It implements the Desrochers-Laporte (DL) lifting ($u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} \\le n-2$) alongside strict depot-based variable fixing within a single pass, reducing model overhead. Crucially, it incorporates Parent 2's 'Conditional Domain Tightening', which forces $u_i \\in [3, n-1]$ for nodes not directly connected to the depot. This partitioning tightens the LP relaxation significantly more than standard MTZ bounds by eliminating fractional solutions where $u$ values hover near the boundaries (2 or $n$) without valid depot connections."
                    },
                    "fitness": 9.742362863624347,
                    "solver_reports": [
                        {
                            "gap": 17.4273,
                            "total_time": 12.36,
                            "explored_nodes": 31,
                            "simplex_iterations": 2623,
                            "explored_time": 12.34,
                            "work_units": 10.1
                        },
                        {
                            "total_time": 12.97,
                            "explored_nodes": 1,
                            "simplex_iterations": 2011,
                            "explored_time": 12.88,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.5838,
                            "total_time": 15.71,
                            "explored_nodes": 2751,
                            "simplex_iterations": 73793,
                            "explored_time": 15.67,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 11.49,
                            "explored_nodes": 1,
                            "simplex_iterations": 1708,
                            "explored_time": 11.38,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.0287,
                            "total_time": 13.88,
                            "explored_nodes": 2821,
                            "simplex_iterations": 54908,
                            "explored_time": 13.85,
                            "work_units": 10.01
                        },
                        {
                            "total_time": 12.9,
                            "explored_nodes": 1,
                            "simplex_iterations": 1832,
                            "explored_time": 12.8,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 1.53,
                            "postsolve": 0.01,
                            "explored_nodes": 18671,
                            "simplex_iterations": 190625,
                            "explored_time": 1.53,
                            "work_units": 0.99
                        },
                        {
                            "gap": 4.6008,
                            "total_time": 13.54,
                            "explored_nodes": 213,
                            "simplex_iterations": 14463,
                            "explored_time": 13.51,
                            "work_units": 10.01
                        },
                        {
                            "gap": 5.9491,
                            "total_time": 12.88,
                            "explored_nodes": 1,
                            "simplex_iterations": 2380,
                            "explored_time": 12.82,
                            "work_units": 10.03
                        },
                        {
                            "total_time": 12.91,
                            "explored_nodes": 1,
                            "simplex_iterations": 2179,
                            "explored_time": 12.82,
                            "work_units": 10.01
                        }
                    ],
                    "generator": "Hybrid",
                    "parents_id": [
                        "c55b6986-6d93-4c28-88f0-28ee947dc873",
                        "3a0514a7-d9b5-4230-8054-2d35bda348ab"
                    ]
                }
            ],
            12.559533054020575
        ],
        [
            [
                {
                    "id": "3a0514a7-d9b5-4230-8054-2d35bda348ab",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Mutated Strategy: DL Lifting + Explicit 2-Cycle + Conditional Domain Tightening\n    \n    # 1. Explicit 2-cycle elimination\n    # Retained from individual: Provides sparse, strong cuts for LP relaxation.\n    def sec2_cut_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2_cuts = pyo.Constraint(model.N, model.N, rule=sec2_cut_rule)\n    \n    # 2. Desrochers-Laporte (DL) Lifting & Depot Fixing\n    # Retained: Strengthens subtour elimination and fixes u when connected to depot.\n    def dl_lifting_rule(model, i, j):\n        if i == j: return pyo.Constraint.Skip\n        \n        # Internal Nodes (i, j != 1): Lifted MTZ constraint\n        if i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n        # Depot Outgoing (1 -> j): If x_1j=1, force u_j=2\n        if i == 1:\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n    \n        # Depot Incoming (i -> 1): If x_i1=1, force u_i=n\n        if j == 1:\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n    \n        return pyo.Constraint.Skip\n    model.enhanced_dl_mtz = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)\n    \n    # 3. Conditional Depot Bounds (Added Mutation)\n    # Enhances the strategy by tightening u-bounds for nodes NOT connected to the depot.\n    # Complements the fixing constraints above to partition the domain of u.\n    \n    # Lower Bound Tightening: If node i is NOT the first visited (x_1i=0), u_i must be >= 3.\n    # Logic: u_i >= 2 + (1 - x_1i) => u_i >= 3 - x_1i\n    def depot_lb_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        return model.u[i] >= 3 - model.x[1, i]\n    model.depot_conditional_lb = pyo.Constraint(model.N, rule=depot_lb_rule)\n    \n    # Upper Bound Tightening: If node i is NOT the last visited (x_i1=0), u_i must be <= n-1.\n    # Logic: u_i <= n - (1 - x_i1) => u_i <= n - 1 + x_i1\n    def depot_ub_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        return model.u[i] <= (n - 1) + model.x[i, 1]\n    model.depot_conditional_ub = pyo.Constraint(model.N, rule=depot_ub_rule)\n\n    return model\n",
                        "added_cut": "# Mutated Strategy: DL Lifting + Explicit 2-Cycle + Conditional Domain Tightening\n\n# 1. Explicit 2-cycle elimination\n# Retained from individual: Provides sparse, strong cuts for LP relaxation.\ndef sec2_cut_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2_cuts = pyo.Constraint(model.N, model.N, rule=sec2_cut_rule)\n\n# 2. Desrochers-Laporte (DL) Lifting & Depot Fixing\n# Retained: Strengthens subtour elimination and fixes u when connected to depot.\ndef dl_lifting_rule(model, i, j):\n    if i == j: return pyo.Constraint.Skip\n    \n    # Internal Nodes (i, j != 1): Lifted MTZ constraint\n    if i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\n    # Depot Outgoing (1 -> j): If x_1j=1, force u_j=2\n    if i == 1:\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n\n    # Depot Incoming (i -> 1): If x_i1=1, force u_i=n\n    if j == 1:\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n\n    return pyo.Constraint.Skip\nmodel.enhanced_dl_mtz = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)\n\n# 3. Conditional Depot Bounds (Added Mutation)\n# Enhances the strategy by tightening u-bounds for nodes NOT connected to the depot.\n# Complements the fixing constraints above to partition the domain of u.\n\n# Lower Bound Tightening: If node i is NOT the first visited (x_1i=0), u_i must be >= 3.\n# Logic: u_i >= 2 + (1 - x_1i) => u_i >= 3 - x_1i\ndef depot_lb_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    return model.u[i] >= 3 - model.x[1, i]\nmodel.depot_conditional_lb = pyo.Constraint(model.N, rule=depot_lb_rule)\n\n# Upper Bound Tightening: If node i is NOT the last visited (x_i1=0), u_i must be <= n-1.\n# Logic: u_i <= n - (1 - x_i1) => u_i <= n - 1 + x_i1\ndef depot_ub_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    return model.u[i] <= (n - 1) + model.x[i, 1]\nmodel.depot_conditional_ub = pyo.Constraint(model.N, rule=depot_ub_rule)",
                        "idea": "This mutation augments the Desrochers-Laporte and 2-cycle strategy with Conditional Domain Tightening. While the original cuts fixed u[i] to 2 or n when connected to the depot, the new constraints strictly tighten the bounds for the 'unconnected' case (forcing u[i] into [3, n-1] when x[1,i]=0 or x[i,1]=0). This strictly partitions the continuous domain of u based on depot adjacency, significantly tightening the LP relaxation and strengthening the Big-M implications for all internal DL constraints."
                    },
                    "fitness": 12.559533054020575,
                    "solver_reports": [
                        {
                            "gap": 9.983,
                            "total_time": 14.25,
                            "explored_nodes": 1,
                            "simplex_iterations": 2480,
                            "explored_time": 14.21,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 11.61,
                            "explored_nodes": 1,
                            "simplex_iterations": 2767,
                            "explored_time": 11.53,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.5723,
                            "total_time": 12.08,
                            "explored_nodes": 369,
                            "simplex_iterations": 10792,
                            "explored_time": 12.06,
                            "work_units": 10.06
                        },
                        {
                            "total_time": 12.46,
                            "explored_nodes": 1,
                            "simplex_iterations": 1950,
                            "explored_time": 12.34,
                            "work_units": 10.0
                        },
                        {
                            "gap": 1.1852,
                            "total_time": 14.17,
                            "explored_nodes": 10783,
                            "simplex_iterations": 287126,
                            "explored_time": 14.16,
                            "work_units": 10.02
                        },
                        {
                            "gap": 17.5923,
                            "total_time": 12.82,
                            "explored_nodes": 1,
                            "simplex_iterations": 1661,
                            "explored_time": 12.73,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 2.88,
                            "postsolve": 0.0,
                            "explored_nodes": 42403,
                            "simplex_iterations": 292937,
                            "explored_time": 2.88,
                            "work_units": 1.53
                        },
                        {
                            "gap": 1.9875,
                            "total_time": 14.65,
                            "explored_nodes": 2958,
                            "simplex_iterations": 57432,
                            "explored_time": 14.61,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.2986,
                            "total_time": 12.42,
                            "explored_nodes": 1,
                            "simplex_iterations": 1777,
                            "explored_time": 12.37,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 13.63,
                            "explored_nodes": 1,
                            "simplex_iterations": 2314,
                            "explored_time": 13.56,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "General",
                    "parents_id": [
                        "dac64902-bc73-4360-b06f-a785302741fa"
                    ]
                },
                {
                    "id": "c8ae531f-63a1-46c6-9dcc-b37f8b5f0c91",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Hybrid Strong MTZ: Lifted Logic + Global Position Invariant\n    # Combines Parent 1's DL lifting and conditional bounds with a global sum constraint\n    # to minimize joint violations and tighten the relaxation via permutation logic.\n    \n    # 1. Explicit 2-Cycle Elimination (O(N^2), Structural foundation)\n    # Removes fractional 2-cycles which are weak in base MTZ.\n    def sec2_rule(m, i, j):\n        if i < j:\n            return m.x[i, j] + m.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2_enhanced = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n    \n    # 2. Unified Lifted MTZ & Depot Logic (O(N^2), Inherited from Parent 1)\n    # Applies Desrochers-Laporte lifting for internal arcs and strict fixing for depot arcs.\n    # This block replaces standard MTZ with tighter coefficients.\n    def lifted_mtz_rule(m, i, j):\n        if i == j: return pyo.Constraint.Skip\n        \n        # Internal Nodes (i, j != 1): Desrochers-Laporte Lifting\n        # u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n        if i != 1 and j != 1:\n            return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    \n        # Depot Outgoing (1 -> j): Force u[j] = 2 if x[1,j] = 1\n        if i == 1:\n            return m.u[j] + (n - 2) * m.x[1, j] <= n\n    \n        # Depot Incoming (i -> 1): Force u[i] = n if x[i,1] = 1\n        if j == 1:\n            return m.u[i] - (n - 2) * m.x[i, 1] >= 2\n            \n        return pyo.Constraint.Skip\n    model.lifted_mtz_enhanced = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n    \n    # 3. Conditional Domain Tightening (O(N), from Parents)\n    # Tightens the domain of u_i based on its potential connectivity to the depot.\n    # If x[1,i]=0, u[i] >= 3. If x[i,1]=0, u[i] <= n-1.\n    model.cond_lb_enhanced = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 3 - m.x[1, i] if i != 1 else pyo.Constraint.Skip)\n    model.cond_ub_enhanced = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n - 1 + m.x[i, 1] if i != 1 else pyo.Constraint.Skip)\n    \n    # 4. Global Position Invariant (New)\n    # Enforces the sum of non-depot position variables equals the sum of the sequence 2..n.\n    # This is a valid cut for any TSP tour (where u is a permutation) but significantly \n    # tightens the LP relaxation by preventing fractional 'clustering' of u values.\n    target_sum = (n * (n + 1) // 2) - 1\n    model.position_sum_cut = pyo.Constraint(expr=sum(model.u[i] for i in model.N if i != 1) == target_sum)\n\n    return model\n",
                        "added_cut": "# Hybrid Strong MTZ: Lifted Logic + Global Position Invariant\n# Combines Parent 1's DL lifting and conditional bounds with a global sum constraint\n# to minimize joint violations and tighten the relaxation via permutation logic.\n\n# 1. Explicit 2-Cycle Elimination (O(N^2), Structural foundation)\n# Removes fractional 2-cycles which are weak in base MTZ.\ndef sec2_rule(m, i, j):\n    if i < j:\n        return m.x[i, j] + m.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2_enhanced = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n# 2. Unified Lifted MTZ & Depot Logic (O(N^2), Inherited from Parent 1)\n# Applies Desrochers-Laporte lifting for internal arcs and strict fixing for depot arcs.\n# This block replaces standard MTZ with tighter coefficients.\ndef lifted_mtz_rule(m, i, j):\n    if i == j: return pyo.Constraint.Skip\n    \n    # Internal Nodes (i, j != 1): Desrochers-Laporte Lifting\n    # u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n    if i != 1 and j != 1:\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n\n    # Depot Outgoing (1 -> j): Force u[j] = 2 if x[1,j] = 1\n    if i == 1:\n        return m.u[j] + (n - 2) * m.x[1, j] <= n\n\n    # Depot Incoming (i -> 1): Force u[i] = n if x[i,1] = 1\n    if j == 1:\n        return m.u[i] - (n - 2) * m.x[i, 1] >= 2\n        \n    return pyo.Constraint.Skip\nmodel.lifted_mtz_enhanced = pyo.Constraint(model.N, model.N, rule=lifted_mtz_rule)\n\n# 3. Conditional Domain Tightening (O(N), from Parents)\n# Tightens the domain of u_i based on its potential connectivity to the depot.\n# If x[1,i]=0, u[i] >= 3. If x[i,1]=0, u[i] <= n-1.\nmodel.cond_lb_enhanced = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 3 - m.x[1, i] if i != 1 else pyo.Constraint.Skip)\nmodel.cond_ub_enhanced = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n - 1 + m.x[i, 1] if i != 1 else pyo.Constraint.Skip)\n\n# 4. Global Position Invariant (New)\n# Enforces the sum of non-depot position variables equals the sum of the sequence 2..n.\n# This is a valid cut for any TSP tour (where u is a permutation) but significantly \n# tightens the LP relaxation by preventing fractional 'clustering' of u values.\ntarget_sum = (n * (n + 1) // 2) - 1\nmodel.position_sum_cut = pyo.Constraint(expr=sum(model.u[i] for i in model.N if i != 1) == target_sum)",
                        "idea": "This hybrid formulation merges Parent 1's superior 'Lifted MTZ' logic (Desrochers-Laporte coefficients + tight depot bounds) with a new global 'Position Sum Invariant'. While Parent 1 efficiently tightens local arc consistencies ($u_i - u_j$), the added sum constraint forces the collective potentials $\\sum u_i$ to exactly match the theoretical permutation sum ($n(n+1)/2 - 1$). This orthogonal constraint acts as a global valid inequality, eliminating fractional solutions where $u$-variables cluster at low values to satisfy difference constraints cheaply, thus minimizing joint violations and significantly improving the linear relaxation bound."
                    },
                    "fitness": 2.1136498086444218,
                    "solver_reports": [
                        {
                            "gap": 25.3378,
                            "total_time": 13.41,
                            "explored_nodes": 1,
                            "simplex_iterations": 2079,
                            "explored_time": 13.37,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 11.41,
                            "explored_nodes": 1,
                            "simplex_iterations": 2971,
                            "explored_time": 11.32,
                            "work_units": 10.01
                        },
                        {
                            "gap": 27.7037,
                            "total_time": 12.63,
                            "explored_nodes": 1,
                            "simplex_iterations": 2000,
                            "explored_time": 12.61,
                            "work_units": 10.08
                        },
                        {
                            "gap": 52.2028,
                            "total_time": 13.86,
                            "explored_nodes": 1,
                            "simplex_iterations": 1343,
                            "explored_time": 13.75,
                            "work_units": 10.0
                        },
                        {
                            "gap": 10.4022,
                            "total_time": 10.95,
                            "explored_nodes": 4057,
                            "simplex_iterations": 82849,
                            "explored_time": 10.92,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 11.56,
                            "explored_nodes": 1,
                            "simplex_iterations": 2365,
                            "explored_time": 11.48,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 3.12,
                            "postsolve": 0.0,
                            "explored_nodes": 38462,
                            "simplex_iterations": 276875,
                            "explored_time": 3.12,
                            "work_units": 1.83
                        },
                        {
                            "gap": 14.3604,
                            "total_time": 11.36,
                            "explored_nodes": 59,
                            "simplex_iterations": 6351,
                            "explored_time": 11.34,
                            "work_units": 10.23
                        },
                        {
                            "gap": 9.8443,
                            "total_time": 12.71,
                            "explored_nodes": 1,
                            "simplex_iterations": 1763,
                            "explored_time": 12.64,
                            "work_units": 10.08
                        },
                        {
                            "gap": 19.3242,
                            "total_time": 13.53,
                            "explored_nodes": 1,
                            "simplex_iterations": 1152,
                            "explored_time": 13.45,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Min_Violation",
                    "parents_id": [
                        "9dee4e72-fe81-4735-8fe4-87fafd3373d7",
                        "b9d7a2ef-4386-41b5-959c-9817289ca0e4"
                    ]
                },
                {
                    "id": "70e1ec92-e475-47f3-99fe-f30b7853129e",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Hybrid Strategy: DL Lifting + Conditional Bounds + Global Position Invariant\n    \n    # 1. Explicit 2-Cycle Elimination\n    # Removes trivial length-2 subtours (i <-> j), strengthening the LP relaxation.\n    def sec2_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2_elimination = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n    \n    # 2. Desrochers-Laporte (DL) Lifting & Depot Fixing\n    # Applies the stronger Lifted MTZ constraint (DL) for internal nodes and\n    # fixes u variables to 2 (start) or n (end) when connected to the depot.\n    def dl_mtz_rule(model, i, j):\n        if i == j: return pyo.Constraint.Skip\n        \n        # Internal Nodes (i, j != 1): DL Lifting\n        # Stronger than MTZ due to the (n-3)*x[j,i] term.\n        if i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n        # Depot Outgoing (1 -> j): Force u[j] = 2\n        # Implemented as u[j] <= 2 (since u >= 2 global) via Big-M logic\n        if i == 1:\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n    \n        # Depot Incoming (i -> 1): Force u[i] = n\n        # Implemented as u[i] >= n (since u <= n global) via Big-M logic\n        if j == 1:\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n            \n        return pyo.Constraint.Skip\n    model.dl_mtz_constraints = pyo.Constraint(model.N, model.N, rule=dl_mtz_rule)\n    \n    # 3. Conditional Domain Partitioning\n    # Tightens the bounds of u[i] based on depot adjacency variables.\n    # If x[1,i]=0, u[i] cannot be 2, so u[i] >= 3.\n    # If x[i,1]=0, u[i] cannot be n, so u[i] <= n-1.\n    def cond_lb_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        return model.u[i] >= 3 - model.x[1, i]\n    model.cond_lb = pyo.Constraint(model.N, rule=cond_lb_rule)\n    \n    def cond_ub_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        return model.u[i] <= (n - 1) + model.x[i, 1]\n    model.cond_ub = pyo.Constraint(model.N, rule=cond_ub_rule)\n    \n    # 4. Global Position Sum Invariant\n    # Enforces that the sum of position variables matches the sum of the sequence 2..n.\n    # In any valid TSP tour, u values are a permutation of 2..n.\n    # This cuts off fractional solutions where u values 'float' to satisfy difference constraints\n    # without forming a valid global sequence.\n    def global_pos_sum_rule(model):\n        target_sum = (n * (n + 1) // 2) - 1\n        return sum(model.u[i] for i in model.N if i != 1) == target_sum\n    model.global_pos_sum = pyo.Constraint(rule=global_pos_sum_rule)\n\n    return model\n",
                        "added_cut": "# Hybrid Strategy: DL Lifting + Conditional Bounds + Global Position Invariant\n\n# 1. Explicit 2-Cycle Elimination\n# Removes trivial length-2 subtours (i <-> j), strengthening the LP relaxation.\ndef sec2_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2_elimination = pyo.Constraint(model.N, model.N, rule=sec2_rule)\n\n# 2. Desrochers-Laporte (DL) Lifting & Depot Fixing\n# Applies the stronger Lifted MTZ constraint (DL) for internal nodes and\n# fixes u variables to 2 (start) or n (end) when connected to the depot.\ndef dl_mtz_rule(model, i, j):\n    if i == j: return pyo.Constraint.Skip\n    \n    # Internal Nodes (i, j != 1): DL Lifting\n    # Stronger than MTZ due to the (n-3)*x[j,i] term.\n    if i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\n    # Depot Outgoing (1 -> j): Force u[j] = 2\n    # Implemented as u[j] <= 2 (since u >= 2 global) via Big-M logic\n    if i == 1:\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n\n    # Depot Incoming (i -> 1): Force u[i] = n\n    # Implemented as u[i] >= n (since u <= n global) via Big-M logic\n    if j == 1:\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n        \n    return pyo.Constraint.Skip\nmodel.dl_mtz_constraints = pyo.Constraint(model.N, model.N, rule=dl_mtz_rule)\n\n# 3. Conditional Domain Partitioning\n# Tightens the bounds of u[i] based on depot adjacency variables.\n# If x[1,i]=0, u[i] cannot be 2, so u[i] >= 3.\n# If x[i,1]=0, u[i] cannot be n, so u[i] <= n-1.\ndef cond_lb_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    return model.u[i] >= 3 - model.x[1, i]\nmodel.cond_lb = pyo.Constraint(model.N, rule=cond_lb_rule)\n\ndef cond_ub_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    return model.u[i] <= (n - 1) + model.x[i, 1]\nmodel.cond_ub = pyo.Constraint(model.N, rule=cond_ub_rule)\n\n# 4. Global Position Sum Invariant\n# Enforces that the sum of position variables matches the sum of the sequence 2..n.\n# In any valid TSP tour, u values are a permutation of 2..n.\n# This cuts off fractional solutions where u values 'float' to satisfy difference constraints\n# without forming a valid global sequence.\ndef global_pos_sum_rule(model):\n    target_sum = (n * (n + 1) // 2) - 1\n    return sum(model.u[i] for i in model.N if i != 1) == target_sum\nmodel.global_pos_sum = pyo.Constraint(rule=global_pos_sum_rule)",
                        "idea": "This formulation fuses the structural strengths of Parent 2 (Desrochers-Laporte lifting and conditional domain bounds) with a new **Global Position Sum Invariant**. While DL lifting and conditional bounds strictly constrain local variable differences and node-specific ranges based on depot adjacency, the global sum constraint ($\\sum_{i \\neq 1} u_i = n(n+1)/2 - 1$) enforces that the aggregate 'mass' of the position variables corresponds exactly to a permutation of $\\{2, \\dots, n\\}$. This cuts off relaxed solutions where $u$-variables satisfy local difference constraints but drift to fractional values that don't constitute a valid global sequence, thereby tightening the relaxation significantly."
                    },
                    "fitness": 6.434804411894356,
                    "solver_reports": [
                        {
                            "gap": 15.072,
                            "total_time": 11.48,
                            "explored_nodes": 143,
                            "simplex_iterations": 4071,
                            "explored_time": 11.46,
                            "work_units": 10.12
                        },
                        {
                            "total_time": 11.76,
                            "explored_nodes": 1,
                            "simplex_iterations": 2593,
                            "explored_time": 11.68,
                            "work_units": 10.03
                        },
                        {
                            "gap": 15.7373,
                            "total_time": 12.19,
                            "explored_nodes": 87,
                            "simplex_iterations": 5724,
                            "explored_time": 12.17,
                            "work_units": 10.45
                        },
                        {
                            "gap": 60.417,
                            "total_time": 13.63,
                            "explored_nodes": 1,
                            "simplex_iterations": 1539,
                            "explored_time": 13.54,
                            "work_units": 10.01
                        },
                        {
                            "gap": 7.5284,
                            "total_time": 10.7,
                            "explored_nodes": 2942,
                            "simplex_iterations": 56469,
                            "explored_time": 10.67,
                            "work_units": 10.0
                        },
                        {
                            "gap": 42.0109,
                            "total_time": 13.13,
                            "explored_nodes": 1,
                            "simplex_iterations": 1887,
                            "explored_time": 13.05,
                            "work_units": 10.01
                        },
                        {
                            "gap": 0.0,
                            "total_time": 1.0,
                            "postsolve": 0.0,
                            "explored_nodes": 10189,
                            "simplex_iterations": 65256,
                            "explored_time": 1.0,
                            "work_units": 0.69
                        },
                        {
                            "gap": 4.3223,
                            "total_time": 12.71,
                            "explored_nodes": 59,
                            "simplex_iterations": 8155,
                            "explored_time": 12.68,
                            "work_units": 10.59
                        },
                        {
                            "total_time": 11.27,
                            "explored_nodes": 1,
                            "simplex_iterations": 1936,
                            "explored_time": 11.19,
                            "work_units": 10.0
                        },
                        {
                            "gap": 7.9659,
                            "total_time": 13.29,
                            "explored_nodes": 1,
                            "simplex_iterations": 1299,
                            "explored_time": 13.21,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "9dee4e72-fe81-4735-8fe4-87fafd3373d7",
                        "3a0514a7-d9b5-4230-8054-2d35bda348ab"
                    ]
                },
                {
                    "id": "2c92857b-0549-4e0b-98b4-f38a71e05730",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # 1. Global Position Sum Equality\n    # Forces the sum of position variables u[2]...u[n] to equal the exact arithmetic progression sum\n    # of a valid Hamiltonian tour (sum(2..n)). This global cut prevents 'potential compression' in\n    # fractional solutions where u-variables drift low to satisfy weak MTZ constraints.\n    model.global_pos_sum = pyo.Constraint(expr=sum(model.u[i] for i in model.N if i != 1) == (n * (n + 1) // 2) - 1)\n    \n    # 2. Depot-Anchored 3-Cycle Elimination\n    # Explicitly eliminates fractional subtours of length 3 passing through the depot (1 -> i -> j -> 1).\n    # While Parents focus on internal DL lifting and 2-cycles, this addresses the specific triangular\n    # geometry anchored at the depot, which is a common weak point in MTZ relaxations.\n    def depot_sec3_rule(model, i, j):\n        if i != 1 and j != 1 and i != j:\n            # Breaking the cycle 1 -> i -> j -> 1\n            return model.x[1, i] + model.x[i, j] + model.x[j, 1] <= 2\n        return pyo.Constraint.Skip\n    model.depot_sec3 = pyo.Constraint(model.N, model.N, rule=depot_sec3_rule)\n\n    return model\n",
                        "added_cut": "# 1. Global Position Sum Equality\n# Forces the sum of position variables u[2]...u[n] to equal the exact arithmetic progression sum\n# of a valid Hamiltonian tour (sum(2..n)). This global cut prevents 'potential compression' in\n# fractional solutions where u-variables drift low to satisfy weak MTZ constraints.\nmodel.global_pos_sum = pyo.Constraint(expr=sum(model.u[i] for i in model.N if i != 1) == (n * (n + 1) // 2) - 1)\n\n# 2. Depot-Anchored 3-Cycle Elimination\n# Explicitly eliminates fractional subtours of length 3 passing through the depot (1 -> i -> j -> 1).\n# While Parents focus on internal DL lifting and 2-cycles, this addresses the specific triangular\n# geometry anchored at the depot, which is a common weak point in MTZ relaxations.\ndef depot_sec3_rule(model, i, j):\n    if i != 1 and j != 1 and i != j:\n        # Breaking the cycle 1 -> i -> j -> 1\n        return model.x[1, i] + model.x[i, j] + model.x[j, 1] <= 2\n    return pyo.Constraint.Skip\nmodel.depot_sec3 = pyo.Constraint(model.N, model.N, rule=depot_sec3_rule)",
                        "idea": "This offspring introduces a 'Global & Anchored' strategy distinct from the Parents' 'Local & Lifted' approach. While the parents tighten bounds on individual u_i variables and lift internal pairwise constraints, this strategy enforces a Global Position Sum equality (forcing the collective average of u to be correct) and explicitly eliminates Depot-Anchored 3-Cycles. This combination targets the 'drift' of potential variables and specific triangular fractional cycles involving the depot, providing orthogonal strengthening to the search space."
                    },
                    "fitness": 0.5956002574393846,
                    "solver_reports": [
                        {
                            "gap": 8.5811,
                            "total_time": 11.54,
                            "explored_nodes": 290,
                            "simplex_iterations": 13280,
                            "explored_time": 11.52,
                            "work_units": 10.01
                        },
                        {
                            "gap": 46.9158,
                            "total_time": 13.42,
                            "explored_nodes": 1,
                            "simplex_iterations": 6944,
                            "explored_time": 13.33,
                            "work_units": 10.0
                        },
                        {
                            "gap": 24.1986,
                            "total_time": 10.73,
                            "explored_nodes": 678,
                            "simplex_iterations": 24856,
                            "explored_time": 10.71,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 15.2,
                            "explored_nodes": 1,
                            "simplex_iterations": 3653,
                            "explored_time": 15.11,
                            "work_units": 10.0
                        },
                        {
                            "gap": 14.0374,
                            "total_time": 10.82,
                            "explored_nodes": 6479,
                            "simplex_iterations": 78170,
                            "explored_time": 10.79,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 14.87,
                            "explored_nodes": 1,
                            "simplex_iterations": 5752,
                            "explored_time": 14.81,
                            "work_units": 10.01
                        },
                        {
                            "gap": 0.0,
                            "total_time": 5.8,
                            "postsolve": 0.0,
                            "explored_nodes": 71884,
                            "simplex_iterations": 683199,
                            "explored_time": 5.8,
                            "work_units": 3.73
                        },
                        {
                            "gap": 3.5521,
                            "total_time": 11.16,
                            "explored_nodes": 811,
                            "simplex_iterations": 28361,
                            "explored_time": 11.14,
                            "work_units": 10.03
                        },
                        {
                            "gap": 72.2172,
                            "total_time": 10.91,
                            "explored_nodes": 59,
                            "simplex_iterations": 8413,
                            "explored_time": 10.88,
                            "work_units": 10.22
                        },
                        {
                            "gap": 40.2256,
                            "total_time": 14.25,
                            "explored_nodes": 1,
                            "simplex_iterations": 4476,
                            "explored_time": 14.16,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Complement",
                    "parents_id": [
                        "e385488a-3ec8-4677-9dde-3ba6103df133",
                        "3a0514a7-d9b5-4230-8054-2d35bda348ab"
                    ]
                },
                {
                    "id": "0648bdd2-55a5-4ecb-9fb3-b4ee16fbcec3",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # 4. Explicit 3-Node Subtour Elimination (GSEC for |S|=3)\n    # Generalizes the input's 'Explicit 2-Cycle Elimination' to subsets of size 3.\n    # Standard MTZ/DL formulations are locally weak and can admit fractional subtours on 3 nodes (triangle cycles).\n    # We enforce the Generalized Subtour Elimination Constraint: sum(x_ij) <= |S|-1 for |S|=3.\n    # This is only applied if n > 3, as for n=3 the tour itself is a 3-cycle.\n    if n > 3:\n        import itertools\n        # Generate all unique triplets (i, j, k) from the set of nodes\n        model.sec3_triplets = pyo.Set(dimen=3, initialize=list(itertools.combinations(model.N, 3)))\n    \n        def sec3_rule(model, i, j, k):\n            subset = [i, j, k]\n            # The sum of all arcs connecting nodes strictly within the subset {i, j, k} must be <= 2.\n            return sum(model.x[u, v] for u in subset for v in subset if u != v) <= 2\n    \n        model.sec3_cuts = pyo.Constraint(model.sec3_triplets, rule=sec3_rule)\n\n    return model\n",
                        "added_cut": "# 4. Explicit 3-Node Subtour Elimination (GSEC for |S|=3)\n# Generalizes the input's 'Explicit 2-Cycle Elimination' to subsets of size 3.\n# Standard MTZ/DL formulations are locally weak and can admit fractional subtours on 3 nodes (triangle cycles).\n# We enforce the Generalized Subtour Elimination Constraint: sum(x_ij) <= |S|-1 for |S|=3.\n# This is only applied if n > 3, as for n=3 the tour itself is a 3-cycle.\nif n > 3:\n    import itertools\n    # Generate all unique triplets (i, j, k) from the set of nodes\n    model.sec3_triplets = pyo.Set(dimen=3, initialize=list(itertools.combinations(model.N, 3)))\n\n    def sec3_rule(model, i, j, k):\n        subset = [i, j, k]\n        # The sum of all arcs connecting nodes strictly within the subset {i, j, k} must be <= 2.\n        return sum(model.x[u, v] for u in subset for v in subset if u != v) <= 2\n\n    model.sec3_cuts = pyo.Constraint(model.sec3_triplets, rule=sec3_rule)",
                        "idea": "Extends the individual's logic of Explicit 2-Cycle Elimination to Explicit 3-Cycle Elimination using Generalized Subtour Elimination Constraints (GSEC) for subsets of size 3. While the provided Desrochers-Laporte (DL) cuts tighten the relation between position variables and arcs, the MTZ-based linear relaxation can still allow fractional subtours on small clusters (e.g., a triangle cycle where the sum of arcs is 3). Explicitly enforcing sum(x_uv) <= 2 for all subsets of size 3 removes these violations. This adds O(n^3) constraints, which defines facets of the subtour elimination polytope that the continuous MTZ relaxation often misses, significantly strengthening the lower bound."
                    },
                    "fitness": 2.1821449846377585,
                    "solver_reports": [
                        {
                            "gap": 38.7022,
                            "total_time": 11.05,
                            "explored_nodes": 1,
                            "simplex_iterations": 969,
                            "explored_time": 10.9,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 6.98,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 6.43,
                            "work_units": 10.01
                        },
                        {
                            "gap": 40.3692,
                            "total_time": 10.55,
                            "explored_nodes": 1,
                            "simplex_iterations": 888,
                            "explored_time": 10.45,
                            "work_units": 10.02
                        },
                        {
                            "total_time": 8.8,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 7.91,
                            "work_units": 10.0
                        },
                        {
                            "gap": 4.5455,
                            "total_time": 14.67,
                            "explored_nodes": 1,
                            "simplex_iterations": 8026,
                            "explored_time": 14.6,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 6.3,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 5.7,
                            "work_units": 10.01
                        },
                        {
                            "gap": 0.0,
                            "total_time": 5.12,
                            "postsolve": 0.01,
                            "explored_nodes": 74657,
                            "simplex_iterations": 601061,
                            "explored_time": 5.12,
                            "work_units": 3.22
                        },
                        {
                            "gap": 5.7159,
                            "total_time": 10.79,
                            "explored_nodes": 1,
                            "simplex_iterations": 1598,
                            "explored_time": 10.64,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 8.4,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 8.11,
                            "work_units": 10.03
                        },
                        {
                            "total_time": 6.95,
                            "explored_nodes": 0,
                            "simplex_iterations": 0,
                            "explored_time": 6.57,
                            "work_units": 10.01
                        }
                    ],
                    "generator": "General",
                    "parents_id": [
                        "e385488a-3ec8-4677-9dde-3ba6103df133"
                    ]
                },
                {
                    "id": "fcc96c36-f50d-404b-9c4a-7cc9519f27a2",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Desrochers-Laporte (DL) Lifted MTZ Constraints\n    # This constraint applies coefficient lifting to the MTZ subtour elimination logic.\n    # It incorporates the reverse arc x[j,i] to strengthen the bound on the potential difference u[i] - u[j].\n    # This O(N^2) formulation dominates both the standard MTZ constraints and the separate 2-cycle cuts.\n    model.dl_lifted_cuts = pyo.Constraint(model.N, model.N, rule=lambda m, i, j: \n        m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2 \n        if i != j and i != 1 and j != 1 else pyo.Constraint.Skip)\n\n    return model\n",
                        "added_cut": "# Desrochers-Laporte (DL) Lifted MTZ Constraints\n# This constraint applies coefficient lifting to the MTZ subtour elimination logic.\n# It incorporates the reverse arc x[j,i] to strengthen the bound on the potential difference u[i] - u[j].\n# This O(N^2) formulation dominates both the standard MTZ constraints and the separate 2-cycle cuts.\nmodel.dl_lifted_cuts = pyo.Constraint(model.N, model.N, rule=lambda m, i, j: \n    m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2 \n    if i != j and i != 1 and j != 1 else pyo.Constraint.Skip)",
                        "idea": "We apply Desrochers-Laporte lifting to the subtour elimination constraints. The individual's approach used weak standard MTZ cuts alongside separate 2-cycle cuts. By lifting the reverse arc variable x_{ji} into the MTZ inequality with coefficient (n-3), we derive the facet-defining inequality u_i - u_j + (n-1)x_{ij} + (n-3)x_{ji} <= n-2. This strictly dominates the standard MTZ cut (reducing the Big-M coefficient) and enforces 2-cycle logic directly within the potential difference constraints, yielding a significantly tighter linear relaxation."
                    },
                    "fitness": 5.749458180182717,
                    "solver_reports": [
                        {
                            "gap": 11.7846,
                            "total_time": 12.29,
                            "explored_nodes": 543,
                            "simplex_iterations": 11251,
                            "explored_time": 12.28,
                            "work_units": 10.09
                        },
                        {
                            "gap": 14.9279,
                            "total_time": 14.58,
                            "explored_nodes": 1,
                            "simplex_iterations": 2078,
                            "explored_time": 14.51,
                            "work_units": 10.01
                        },
                        {
                            "gap": 15.1493,
                            "total_time": 12.61,
                            "explored_nodes": 87,
                            "simplex_iterations": 5248,
                            "explored_time": 12.59,
                            "work_units": 10.07
                        },
                        {
                            "total_time": 11.16,
                            "explored_nodes": 1,
                            "simplex_iterations": 2040,
                            "explored_time": 11.08,
                            "work_units": 10.0
                        },
                        {
                            "gap": 6.4378,
                            "total_time": 12.68,
                            "explored_nodes": 3526,
                            "simplex_iterations": 55582,
                            "explored_time": 12.67,
                            "work_units": 10.0
                        },
                        {
                            "gap": 13.5036,
                            "total_time": 12.73,
                            "explored_nodes": 1,
                            "simplex_iterations": 1759,
                            "explored_time": 12.65,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.9213,
                            "total_time": 14.14,
                            "explored_nodes": 384194,
                            "simplex_iterations": 2350050,
                            "explored_time": 14.13,
                            "work_units": 10.02
                        },
                        {
                            "gap": 2.6982,
                            "total_time": 14.38,
                            "explored_nodes": 2998,
                            "simplex_iterations": 53069,
                            "explored_time": 14.34,
                            "work_units": 10.01
                        },
                        {
                            "gap": 24.2041,
                            "total_time": 11.93,
                            "explored_nodes": 15,
                            "simplex_iterations": 2460,
                            "explored_time": 11.89,
                            "work_units": 10.12
                        },
                        {
                            "gap": 10.4753,
                            "total_time": 12.7,
                            "explored_nodes": 1,
                            "simplex_iterations": 1944,
                            "explored_time": 12.64,
                            "work_units": 10.1
                        }
                    ],
                    "generator": "Lifted",
                    "parents_id": [
                        "b9d7a2ef-4386-41b5-959c-9817289ca0e4"
                    ]
                },
                {
                    "id": "f82c2724-f500-42ca-8855-446af37e0247",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Hybrid Strong MTZ: DL Lifting + Explicit Depot-Domain Coupling\n    # Integrates Parent 1's tight internal DL lifting with Parent 2's strict depot bound logic.\n    \n    # 1. Explicit 2-Cycle Elimination (O(N^2), retained from both)\n    # Removes fractional 2-node subtours which MTZ constraints might allow.\n    model.sec2_cuts = pyo.Constraint(model.N, model.N, rule=lambda m, i, j: m.x[i, j] + m.x[j, i] <= 1 if i < j else pyo.Constraint.Skip)\n    \n    # 2. Internal Desrochers-Laporte (DL) Lifting (O(N^2))\n    # Applies to nodes i, j != 1. Stronger than standard MTZ by including the reverse arc term x[j,i].\n    # Formula: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\n    def internal_dl_rule(m, i, j):\n        if i != 1 and j != 1 and i != j:\n            return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n        return pyo.Constraint.Skip\n    model.internal_dl = pyo.Constraint(model.N, model.N, rule=internal_dl_rule)\n    \n    # 3. Strict Depot-Variable Coupling (O(N))\n    # Strictly binds u[i] based on depot adjacency using logical implications.\n    \n    # Depot Out (1->j): If x[1,j]=1, then u[j] must be 2. If x[1,j]=0, u[j] must be >= 3.\n    model.depot_out_fix = pyo.Constraint(model.N, rule=lambda m, j: m.u[j] + (n - 2) * m.x[1, j] <= n if j != 1 else pyo.Constraint.Skip)\n    model.depot_out_lb  = pyo.Constraint(model.N, rule=lambda m, j: m.u[j] >= 3 - m.x[1, j] if j != 1 else pyo.Constraint.Skip)\n    \n    # Depot In (i->1): If x[i,1]=1, then u[i] must be n. If x[i,1]=0, u[i] must be <= n-1.\n    model.depot_in_fix  = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] - (n - 2) * m.x[i, 1] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.depot_in_ub   = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n - 1 + m.x[i, 1] if i != 1 else pyo.Constraint.Skip)\n\n    return model\n",
                        "added_cut": "# Hybrid Strong MTZ: DL Lifting + Explicit Depot-Domain Coupling\n# Integrates Parent 1's tight internal DL lifting with Parent 2's strict depot bound logic.\n\n# 1. Explicit 2-Cycle Elimination (O(N^2), retained from both)\n# Removes fractional 2-node subtours which MTZ constraints might allow.\nmodel.sec2_cuts = pyo.Constraint(model.N, model.N, rule=lambda m, i, j: m.x[i, j] + m.x[j, i] <= 1 if i < j else pyo.Constraint.Skip)\n\n# 2. Internal Desrochers-Laporte (DL) Lifting (O(N^2))\n# Applies to nodes i, j != 1. Stronger than standard MTZ by including the reverse arc term x[j,i].\n# Formula: u_i - u_j + (n-1)x_ij + (n-3)x_ji <= n-2\ndef internal_dl_rule(m, i, j):\n    if i != 1 and j != 1 and i != j:\n        return m.u[i] - m.u[j] + (n - 1) * m.x[i, j] + (n - 3) * m.x[j, i] <= n - 2\n    return pyo.Constraint.Skip\nmodel.internal_dl = pyo.Constraint(model.N, model.N, rule=internal_dl_rule)\n\n# 3. Strict Depot-Variable Coupling (O(N))\n# Strictly binds u[i] based on depot adjacency using logical implications.\n\n# Depot Out (1->j): If x[1,j]=1, then u[j] must be 2. If x[1,j]=0, u[j] must be >= 3.\nmodel.depot_out_fix = pyo.Constraint(model.N, rule=lambda m, j: m.u[j] + (n - 2) * m.x[1, j] <= n if j != 1 else pyo.Constraint.Skip)\nmodel.depot_out_lb  = pyo.Constraint(model.N, rule=lambda m, j: m.u[j] >= 3 - m.x[1, j] if j != 1 else pyo.Constraint.Skip)\n\n# Depot In (i->1): If x[i,1]=1, then u[i] must be n. If x[i,1]=0, u[i] must be <= n-1.\nmodel.depot_in_fix  = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] - (n - 2) * m.x[i, 1] >= 2 if i != 1 else pyo.Constraint.Skip)\nmodel.depot_in_ub   = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n - 1 + m.x[i, 1] if i != 1 else pyo.Constraint.Skip)",
                        "idea": "This formulation merges Parent 1's high-fitness Desrochers-Laporte lifting for internal nodes with Parent 2's explicit depot-bound logic. The hybrid approach strictly partitions the domain of the sequence variables $u_i$: internal nodes use tighter lifted MTZ cuts ($O(N^2)$), while depot connections use conditional bounds ($O(N)$) to force $u=2$ or $u=n$ when connected to the depot, and $u \\in [3, n-1]$ when not. This eliminates fractional solutions hovering near bounds without valid depot support."
                    },
                    "fitness": 2.190080633977209,
                    "solver_reports": [
                        {
                            "gap": 14.9359,
                            "total_time": 14.0,
                            "explored_nodes": 59,
                            "simplex_iterations": 3858,
                            "explored_time": 13.97,
                            "work_units": 10.64
                        },
                        {
                            "total_time": 12.14,
                            "explored_nodes": 1,
                            "simplex_iterations": 2524,
                            "explored_time": 12.05,
                            "work_units": 10.01
                        },
                        {
                            "gap": 16.6229,
                            "total_time": 13.07,
                            "explored_nodes": 5,
                            "simplex_iterations": 2076,
                            "explored_time": 13.05,
                            "work_units": 10.06
                        },
                        {
                            "total_time": 12.05,
                            "explored_nodes": 1,
                            "simplex_iterations": 2000,
                            "explored_time": 11.94,
                            "work_units": 10.0
                        },
                        {
                            "gap": 3.0612,
                            "total_time": 14.57,
                            "explored_nodes": 3381,
                            "simplex_iterations": 58535,
                            "explored_time": 14.54,
                            "work_units": 10.0
                        },
                        {
                            "gap": 1.1856,
                            "total_time": 12.81,
                            "explored_nodes": 1,
                            "simplex_iterations": 4116,
                            "explored_time": 12.75,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 4.03,
                            "postsolve": 0.0,
                            "explored_nodes": 67583,
                            "simplex_iterations": 456975,
                            "explored_time": 4.02,
                            "work_units": 2.77
                        },
                        {
                            "gap": 3.5354,
                            "total_time": 12.88,
                            "explored_nodes": 59,
                            "simplex_iterations": 4561,
                            "explored_time": 12.86,
                            "work_units": 10.81
                        },
                        {
                            "gap": 89.4705,
                            "total_time": 12.45,
                            "explored_nodes": 1,
                            "simplex_iterations": 2147,
                            "explored_time": 12.37,
                            "work_units": 10.0
                        },
                        {
                            "total_time": 13.72,
                            "explored_nodes": 1,
                            "simplex_iterations": 2323,
                            "explored_time": 13.63,
                            "work_units": 10.0
                        }
                    ],
                    "generator": "Intersection",
                    "parents_id": [
                        "9dee4e72-fe81-4735-8fe4-87fafd3373d7",
                        "b9d7a2ef-4386-41b5-959c-9817289ca0e4"
                    ]
                },
                {
                    "id": "7053156d-357b-4781-b786-b451a9096f24",
                    "chromosome": {
                        "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    def strong_lifted_mtz_rule(model, i, j):\n        if i == j: \n            return pyo.Constraint.Skip\n        \n        # Case 1: Internal Nodes (Neither is Depot)\n        # Applies a strengthened Desrochers-Laporte lifting by using depot-connection variables.\n        # Base logic: If i is not last (x[i,1]=0) and j is not first (x[1,j]=0), u[i]-u[j] <= n-4.\n        # We lift this to be valid for all cases by adding slack via x[i,1] and x[1,j].\n        if i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 3) * model.x[i, j] + (n - 5) * model.x[j, i] - model.x[i, 1] - model.x[1, j] <= n - 4\n    \n        # Case 2: Depot Outgoing (1 -> j)\n        # Logic: If x[1,j]=1, u[j]=2 (tight). If x[1,j]=0, u[j] <= n (valid).\n        if i == 1:\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n    \n        # Case 3: Depot Incoming (i -> 1)\n        # Logic: If x[i,1]=1, u[i]=n (tight). If x[i,1]=0, u[i] >= 2 (valid).\n        if j == 1:\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n            \n        return pyo.Constraint.Skip\n    \n    model.strong_lifted_mtz = pyo.Constraint(model.N, model.N, rule=strong_lifted_mtz_rule)\n\n    return model\n",
                        "added_cut": "def strong_lifted_mtz_rule(model, i, j):\n    if i == j: \n        return pyo.Constraint.Skip\n    \n    # Case 1: Internal Nodes (Neither is Depot)\n    # Applies a strengthened Desrochers-Laporte lifting by using depot-connection variables.\n    # Base logic: If i is not last (x[i,1]=0) and j is not first (x[1,j]=0), u[i]-u[j] <= n-4.\n    # We lift this to be valid for all cases by adding slack via x[i,1] and x[1,j].\n    if i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 3) * model.x[i, j] + (n - 5) * model.x[j, i] - model.x[i, 1] - model.x[1, j] <= n - 4\n\n    # Case 2: Depot Outgoing (1 -> j)\n    # Logic: If x[1,j]=1, u[j]=2 (tight). If x[1,j]=0, u[j] <= n (valid).\n    if i == 1:\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n\n    # Case 3: Depot Incoming (i -> 1)\n    # Logic: If x[i,1]=1, u[i]=n (tight). If x[i,1]=0, u[i] >= 2 (valid).\n    if j == 1:\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n        \n    return pyo.Constraint.Skip\n\nmodel.strong_lifted_mtz = pyo.Constraint(model.N, model.N, rule=strong_lifted_mtz_rule)",
                        "idea": "This mutation tightens the Desrochers-Laporte (DL) constraints by applying Sequential Lifting with depot-connectivity variables. Observing that the difference u[i] - u[j] is bounded by n-4 (rather than n-2) when i is not the last node and j is not the first, we lift the cut using x[i,1] and x[1,j]. The resulting inequality, u[i] - u[j] + (n-3)x[i,j] + (n-5)x[j,i] - x[i,1] - x[1,j] <= n-4, strictly dominates the standard DL cut for all feasible fractional solutions by dynamically adjusting the RHS based on depot adjacency."
                    },
                    "fitness": 1.4023361505759924,
                    "solver_reports": [
                        {
                            "gap": 15.487,
                            "total_time": 13.21,
                            "explored_nodes": 87,
                            "simplex_iterations": 3765,
                            "explored_time": 13.19,
                            "work_units": 12.72
                        },
                        {
                            "total_time": 10.88,
                            "explored_nodes": 1,
                            "simplex_iterations": 1929,
                            "explored_time": 10.82,
                            "work_units": 10.01
                        },
                        {
                            "gap": 32.5572,
                            "total_time": 10.45,
                            "explored_nodes": 227,
                            "simplex_iterations": 11547,
                            "explored_time": 10.42,
                            "work_units": 10.21
                        },
                        {
                            "total_time": 11.94,
                            "explored_nodes": 1,
                            "simplex_iterations": 1583,
                            "explored_time": 11.79,
                            "work_units": 10.01
                        },
                        {
                            "gap": 4.8529,
                            "total_time": 10.32,
                            "explored_nodes": 171,
                            "simplex_iterations": 6321,
                            "explored_time": 10.3,
                            "work_units": 11.57
                        },
                        {
                            "gap": 56.8714,
                            "total_time": 11.06,
                            "explored_nodes": 1,
                            "simplex_iterations": 1133,
                            "explored_time": 11.0,
                            "work_units": 10.0
                        },
                        {
                            "gap": 0.0,
                            "total_time": 4.77,
                            "postsolve": 0.0,
                            "explored_nodes": 50848,
                            "simplex_iterations": 364711,
                            "explored_time": 4.76,
                            "work_units": 3.13
                        },
                        {
                            "gap": 6.0198,
                            "total_time": 10.66,
                            "explored_nodes": 1,
                            "simplex_iterations": 2384,
                            "explored_time": 10.63,
                            "work_units": 10.0
                        },
                        {
                            "gap": 19.2982,
                            "total_time": 10.46,
                            "explored_nodes": 1,
                            "simplex_iterations": 1277,
                            "explored_time": 10.42,
                            "work_units": 10.0
                        },
                        {
                            "gap": 42.9112,
                            "total_time": 10.16,
                            "explored_nodes": 1,
                            "simplex_iterations": 1184,
                            "explored_time": 10.11,
                            "work_units": 10.01
                        }
                    ],
                    "generator": "Lifted",
                    "parents_id": [
                        "9dee4e72-fe81-4735-8fe4-87fafd3373d7"
                    ]
                }
            ],
            12.559533054020575
        ]
    ],
    "best_fitness": 12.559533054020575,
    "best_indiv": {
        "id": "3a0514a7-d9b5-4230-8054-2d35bda348ab",
        "chromosome": {
            "full_code": "def create_model(n, c):\n    \"\"\"\n    Create a Pyomo model for the Traveling Salesman Problem (TSP) using the MTZ formulation with node 1 as depot.\n   \n    Parameters:\n      n: int, number of nodes (cities).\n      c: dict, cost matrix where c[i, j] is the travel cost from node i to node j.\n   \n    Returns:\n      model: Pyomo ConcreteModel.\n    \"\"\"\n\n    model = pyo.ConcreteModel()\n    model.N = pyo.RangeSet(1, n)  # Set of nodes\n    model.A = pyo.Set(initialize=[(i, j) for i in model.N for j in model.N if i != j])  # Set of arcs (i, j)\n\n    # Decision variables: x[i,j]=1 if arc (i,j) is used; u[i] is the position of node i in the tour.\n    model.x = pyo.Var(model.A, domain=pyo.Binary)\n    model.u = pyo.Var(model.N, domain=pyo.NonNegativeIntegers)\n\n    # Objective: Minimize total travel cost.\n    model.obj = pyo.Objective(expr=sum(c[i, j] * model.x[i, j] for (i, j) in model.A), sense=pyo.minimize)\n\n    # Each node has exactly one outgoing arc.\n    model.outgoing_arc = pyo.Constraint(model.N, rule=lambda m, i: sum(m.x[i, j] for j in m.N if j != i) == 1)\n    # Each node has exactly one incoming arc.\n    model.incoming_arc = pyo.Constraint(model.N, rule=lambda m, j: sum(m.x[i, j] for i in m.N if i != j) == 1)\n\n    # MTZ Subtour elimination constraints (applied only for non-depot nodes).\n    def mtz_rule(model, i, j):\n        if i != j and i != 1 and j != 1:\n            return model.u[i] - model.u[j] + n * model.x[i, j] <= n - 1\n        return pyo.Constraint.Skip\n    model.subtour_elimination = pyo.Constraint(model.N, model.N, rule=mtz_rule)\n\n    # Bounds on u for non-depot nodes: u[i] in [2, n] for i != 1.\n    model.u_lower = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] >= 2 if i != 1 else pyo.Constraint.Skip)\n    model.u_upper = pyo.Constraint(model.N, rule=lambda m, i: m.u[i] <= n if i != 1 else pyo.Constraint.Skip)\n\n    # Fix depot's position: set u[1] == 1.\n    model.u_fix = pyo.Constraint(expr=model.u[1] == 1)\n\n    # Additional constraints placeholder.\n    # Mutated Strategy: DL Lifting + Explicit 2-Cycle + Conditional Domain Tightening\n    \n    # 1. Explicit 2-cycle elimination\n    # Retained from individual: Provides sparse, strong cuts for LP relaxation.\n    def sec2_cut_rule(model, i, j):\n        if i < j:\n            return model.x[i, j] + model.x[j, i] <= 1\n        return pyo.Constraint.Skip\n    model.sec2_cuts = pyo.Constraint(model.N, model.N, rule=sec2_cut_rule)\n    \n    # 2. Desrochers-Laporte (DL) Lifting & Depot Fixing\n    # Retained: Strengthens subtour elimination and fixes u when connected to depot.\n    def dl_lifting_rule(model, i, j):\n        if i == j: return pyo.Constraint.Skip\n        \n        # Internal Nodes (i, j != 1): Lifted MTZ constraint\n        if i != 1 and j != 1:\n            return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n    \n        # Depot Outgoing (1 -> j): If x_1j=1, force u_j=2\n        if i == 1:\n            return model.u[j] + (n - 2) * model.x[i, j] <= n\n    \n        # Depot Incoming (i -> 1): If x_i1=1, force u_i=n\n        if j == 1:\n            return model.u[i] - (n - 2) * model.x[i, j] >= 2\n    \n        return pyo.Constraint.Skip\n    model.enhanced_dl_mtz = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)\n    \n    # 3. Conditional Depot Bounds (Added Mutation)\n    # Enhances the strategy by tightening u-bounds for nodes NOT connected to the depot.\n    # Complements the fixing constraints above to partition the domain of u.\n    \n    # Lower Bound Tightening: If node i is NOT the first visited (x_1i=0), u_i must be >= 3.\n    # Logic: u_i >= 2 + (1 - x_1i) => u_i >= 3 - x_1i\n    def depot_lb_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        return model.u[i] >= 3 - model.x[1, i]\n    model.depot_conditional_lb = pyo.Constraint(model.N, rule=depot_lb_rule)\n    \n    # Upper Bound Tightening: If node i is NOT the last visited (x_i1=0), u_i must be <= n-1.\n    # Logic: u_i <= n - (1 - x_i1) => u_i <= n - 1 + x_i1\n    def depot_ub_rule(model, i):\n        if i == 1: return pyo.Constraint.Skip\n        return model.u[i] <= (n - 1) + model.x[i, 1]\n    model.depot_conditional_ub = pyo.Constraint(model.N, rule=depot_ub_rule)\n\n    return model\n",
            "added_cut": "# Mutated Strategy: DL Lifting + Explicit 2-Cycle + Conditional Domain Tightening\n\n# 1. Explicit 2-cycle elimination\n# Retained from individual: Provides sparse, strong cuts for LP relaxation.\ndef sec2_cut_rule(model, i, j):\n    if i < j:\n        return model.x[i, j] + model.x[j, i] <= 1\n    return pyo.Constraint.Skip\nmodel.sec2_cuts = pyo.Constraint(model.N, model.N, rule=sec2_cut_rule)\n\n# 2. Desrochers-Laporte (DL) Lifting & Depot Fixing\n# Retained: Strengthens subtour elimination and fixes u when connected to depot.\ndef dl_lifting_rule(model, i, j):\n    if i == j: return pyo.Constraint.Skip\n    \n    # Internal Nodes (i, j != 1): Lifted MTZ constraint\n    if i != 1 and j != 1:\n        return model.u[i] - model.u[j] + (n - 1) * model.x[i, j] + (n - 3) * model.x[j, i] <= n - 2\n\n    # Depot Outgoing (1 -> j): If x_1j=1, force u_j=2\n    if i == 1:\n        return model.u[j] + (n - 2) * model.x[i, j] <= n\n\n    # Depot Incoming (i -> 1): If x_i1=1, force u_i=n\n    if j == 1:\n        return model.u[i] - (n - 2) * model.x[i, j] >= 2\n\n    return pyo.Constraint.Skip\nmodel.enhanced_dl_mtz = pyo.Constraint(model.N, model.N, rule=dl_lifting_rule)\n\n# 3. Conditional Depot Bounds (Added Mutation)\n# Enhances the strategy by tightening u-bounds for nodes NOT connected to the depot.\n# Complements the fixing constraints above to partition the domain of u.\n\n# Lower Bound Tightening: If node i is NOT the first visited (x_1i=0), u_i must be >= 3.\n# Logic: u_i >= 2 + (1 - x_1i) => u_i >= 3 - x_1i\ndef depot_lb_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    return model.u[i] >= 3 - model.x[1, i]\nmodel.depot_conditional_lb = pyo.Constraint(model.N, rule=depot_lb_rule)\n\n# Upper Bound Tightening: If node i is NOT the last visited (x_i1=0), u_i must be <= n-1.\n# Logic: u_i <= n - (1 - x_i1) => u_i <= n - 1 + x_i1\ndef depot_ub_rule(model, i):\n    if i == 1: return pyo.Constraint.Skip\n    return model.u[i] <= (n - 1) + model.x[i, 1]\nmodel.depot_conditional_ub = pyo.Constraint(model.N, rule=depot_ub_rule)",
            "idea": "This mutation augments the Desrochers-Laporte and 2-cycle strategy with Conditional Domain Tightening. While the original cuts fixed u[i] to 2 or n when connected to the depot, the new constraints strictly tighten the bounds for the 'unconnected' case (forcing u[i] into [3, n-1] when x[1,i]=0 or x[i,1]=0). This strictly partitions the continuous domain of u based on depot adjacency, significantly tightening the LP relaxation and strengthening the Big-M implications for all internal DL constraints."
        },
        "fitness": 12.559533054020575,
        "solver_reports": [
            {
                "gap": 9.983,
                "total_time": 14.25,
                "explored_nodes": 1,
                "simplex_iterations": 2480,
                "explored_time": 14.21,
                "work_units": 10.0
            },
            {
                "total_time": 11.61,
                "explored_nodes": 1,
                "simplex_iterations": 2767,
                "explored_time": 11.53,
                "work_units": 10.0
            },
            {
                "gap": 13.5723,
                "total_time": 12.08,
                "explored_nodes": 369,
                "simplex_iterations": 10792,
                "explored_time": 12.06,
                "work_units": 10.06
            },
            {
                "total_time": 12.46,
                "explored_nodes": 1,
                "simplex_iterations": 1950,
                "explored_time": 12.34,
                "work_units": 10.0
            },
            {
                "gap": 1.1852,
                "total_time": 14.17,
                "explored_nodes": 10783,
                "simplex_iterations": 287126,
                "explored_time": 14.16,
                "work_units": 10.02
            },
            {
                "gap": 17.5923,
                "total_time": 12.82,
                "explored_nodes": 1,
                "simplex_iterations": 1661,
                "explored_time": 12.73,
                "work_units": 10.0
            },
            {
                "gap": 0.0,
                "total_time": 2.88,
                "postsolve": 0.0,
                "explored_nodes": 42403,
                "simplex_iterations": 292937,
                "explored_time": 2.88,
                "work_units": 1.53
            },
            {
                "gap": 1.9875,
                "total_time": 14.65,
                "explored_nodes": 2958,
                "simplex_iterations": 57432,
                "explored_time": 14.61,
                "work_units": 10.0
            },
            {
                "gap": 6.2986,
                "total_time": 12.42,
                "explored_nodes": 1,
                "simplex_iterations": 1777,
                "explored_time": 12.37,
                "work_units": 10.0
            },
            {
                "total_time": 13.63,
                "explored_nodes": 1,
                "simplex_iterations": 2314,
                "explored_time": 13.56,
                "work_units": 10.0
            }
        ],
        "generator": "General",
        "parents_id": [
            "dac64902-bc73-4360-b06f-a785302741fa"
        ]
    },
    "state": 19
}